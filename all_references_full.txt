src/y4m_cmp.rs:3:use crate::h264::tables::MB_WIDTH;
src/h264/pps.rs:40:// Section 7.4.2.2 Picture parameter set RBSP semantics
src/h264/pps.rs:47:    // false: Exp-Golomb coded, see section 9.1 or CAVLC, see section 9.2.
src/h264/pps.rs:48:    // true: CABAC coded, see section 9.3. (Only available in profiles Main and higher)
src/h264/rbsp.rs:38:    // Parsing process for Exp-Golomb codes. Section 9.1
src/h264/rbsp.rs:58:    // Mapping process for signed Exp-Golomb codes Section 9.1.1
src/h264/rbsp.rs:66:    // Truncated Exp-Golomb entropy coding. Section 9.1.2
src/h264/slice.rs:9:use super::{tables, ColorPlane, Point};
src/h264/slice.rs:69:// Table 7-7 – modification_of_pic_nums_idc operations for modification of reference picture lists
src/h264/slice.rs:101:/// Represents the `pred_weight_table()` syntax structure.
src/h264/slice.rs:104:pub struct PredWeightTable {
src/h264/slice.rs:120:// Section 7.4.3 Slice header semantics
src/h264/slice.rs:146:    pub pred_weight_table: Option<PredWeightTable>,
src/h264/slice.rs:248:        let x = addr % (width_in_mbs as u32) * (tables::MB_WIDTH as u32);
src/h264/slice.rs:249:        let y = addr / (width_in_mbs as u32) * (tables::MB_HEIGHT as u32);
src/h264/slice.rs:254:        let mb_x = x / tables::MB_WIDTH as i32;
src/h264/slice.rs:255:        let mb_y = y / tables::MB_HEIGHT as i32;
src/h264/poc.rs:32:        // Section 8.2.1.1 Decoding process for picture order count type 0
src/h264/poc.rs:68:        // Section 8.2.1.2 Decoding process for picture order count type 1
src/h264/poc.rs:140:        // Section 8.2.1.3 Decoding process for picture order count type 2
src/h264/inter_pred.rs:6:/// Section 8.4.2.2.1 Luma sample interpolation process.
src/h264/inter_pred.rs:20:/// depending on the fractional part of the motion vector, as described in Table 8-10.
src/h264/inter_pred.rs:34:    // Equation 8-223, 8-224: Full sample units (Int) and Equation 8-225, 8-226: Fractional units (Frac)
src/h264/inter_pred.rs:65:        // Slow path: clamping for boundary pixels (Section 8.4.2.2.1, RefLayerFrame behavior)
src/h264/inter_pred.rs:108:            // Half-sample interpolation using 6-tap filter (Equation 8-241, 8-243)
src/h264/inter_pred.rs:123:            // Averaging for quarter-sample positions (Equation 8-250 to 8-252)
src/h264/inter_pred.rs:131:                // Quarter-pel positions (Table 8-12)
src/h264/inter_pred.rs:143:                // of applying the 6-tap filter horizontally (or vice versa). (Equation 8-247)
src/h264/inter_pred.rs:175:/// Section 8.4.2.2.2 Chroma sample interpolation process.
src/h264/inter_pred.rs:206:    // This corresponds to Equation 8-227, 8-228, 8-229, 8-230 for 4:2:0:
src/h264/inter_pred.rs:227:        // Equation 8-270: Bilinear interpolation
src/h264/inter_pred.rs:247:                // Equation 8-270:
src/h264/inter_pred.rs:290:/// Applies the 6-tap filter specified in Equation 8-246.
src/h264/inter_pred.rs:300:/// Corresponds to Equations 8-243, 8-244, 8-248, 8-249 (final clipping for half-sample values).
src/h264/inter_pred.rs:321:/// This corresponds to Equation 8-247, but operating on the intermediate values
src/h264/macroblock.rs:7:use super::tables::{MB_HEIGHT, MB_WIDTH};
src/h264/macroblock.rs:25:// Section 6.4.8 Derivation process of the availability for macroblock addresses
src/h264/macroblock.rs:26:// Section 6.4.9 Derivation process for neighboring macroblock addresses and their availability
src/h264/macroblock.rs:84:// Section 6.4.3 Inverse 4x4 luma block scanning process
src/h264/macroblock.rs:107:// Section 6.4.7 Inverse 4x4 chroma block scanning process
src/h264/macroblock.rs:118:// Section 6.4.13.1 Derivation process for 4x4 luma block indices
src/h264/macroblock.rs:124:// Section 6.4.13.2 Derivation process for 4x4 chroma block indices
src/h264/macroblock.rs:130:// Section 6.4.11.4 Derivation process for neighboring 4x4 luma blocks
src/h264/macroblock.rs:151:// Section 6.4.11.5 Derivation process for neighboring 4x4 chroma blocks
src/h264/macroblock.rs:172:// Table 7-11 – Macroblock types for I slices
src/h264/macroblock.rs:212:// Table 7-13 – Macroblock type values 0 to 4 for P and SP slices
src/h264/macroblock.rs:261:// Section 8.3.1.2 Intra_4x4 sample prediction
src/h264/macroblock.rs:315:// Table 7-16
src/h264/macroblock.rs:407:// Table 7-17 - Sub-macroblock types in P macroblock
src/h264/macroblock.rs:427:    // Table 7-17 – Sub-macroblock types in P macroblocks
src/h264/macroblock.rs:522:        // Section 9.2.1
src/h264/decoder.rs:6:use crate::h264::tables::mb_type_to_16x16_pred_mode;
src/h264/decoder.rs:19:use super::tables::{MB_HEIGHT, MB_WIDTH};
src/h264/decoder.rs:20:use super::{deblocking, nal, parser, pps, slice, sps, tables, ChromaFormat, Point};
src/h264/decoder.rs:259:                            plane_slice.rows_iter_mut().take(tables::MB_HEIGHT).enumerate()
src/h264/decoder.rs:261:                            let row_range = idx * tables::MB_WIDTH..(idx + 1) * tables::MB_WIDTH;
src/h264/decoder.rs:262:                            row[..tables::MB_WIDTH]
src/h264/decoder.rs:373:    // Section 8.2.4.1 Decoding process for picture numbers
src/h264/decoder.rs:395:    // Section 8.2.4.2 Initialization process for reference picture lists
src/h264/decoder.rs:434:    // Section 8.2.4.3 Reordering process for reference picture lists
src/h264/decoder.rs:562:                // Section 8.3.1.2 Intra_4x4 sample prediction
src/h264/decoder.rs:745:// Section 8.5.8 Derivation process for chroma quantization parameters
src/h264/decoder.rs:749:    // 2. Look up qP_C from qP_I using Table 8-15
src/h264/decoder.rs:780:// Section 8.3.1.1 Derivation process for Intra4x4PredMode
src/h264/decoder.rs:789:    // Equations 8-53, 8-54, etc.: (A + 2*B + C + 2) >> 2
src/h264/decoder.rs:818:                // Section 8.3.1.2.1 Specification of Intra_4x4_Vertical prediction mode
src/h264/decoder.rs:819:                // Equation 8-46: pred4x4L[x, y] = p[x, -1]
src/h264/decoder.rs:826:                // Section 8.3.1.2.2 Specification of Intra_4x4_Horizontal prediction mode
src/h264/decoder.rs:827:                // Equation 8-47: pred4x4L[x, y] = p[-1, y]
src/h264/decoder.rs:834:                // Section 8.3.1.2.3 Specification of Intra_4x4_DC prediction mode
src/h264/decoder.rs:851:                // Equations 8-48 to 8-51: averaging top and/or left neighbors
src/h264/decoder.rs:866:                // Section 8.3.1.2.4 Specification of Intra_4x4_Diagonal_Down_Left prediction mode
src/h264/decoder.rs:872:                            // Equation 8-52
src/h264/decoder.rs:875:                            // Equation 8-53
src/h264/decoder.rs:882:                // Section 8.3.1.2.5 Specification of Intra_4x4_Diagonal_Down_Right prediction mode
src/h264/decoder.rs:883:                // Equations 8-54 to 8-56
src/h264/decoder.rs:903:                // Section 8.3.1.2.6 Specification of Intra_4x4_Vertical_Right prediction mode
src/h264/decoder.rs:904:                // Equations 8-57 to 8-60
src/h264/decoder.rs:924:                // Section 8.3.1.2.7 Specification of Intra_4x4_Horizontal_Down prediction mode
src/h264/decoder.rs:925:                // Equations 8-61 to 8-64
src/h264/decoder.rs:942:                // Section 8.3.1.2.8 Specification of Intra_4x4_Vertical_Left prediction mode
src/h264/decoder.rs:943:                // Equations 8-65, 8-66
src/h264/decoder.rs:957:                // Section 8.3.1.2.9 Specification of Intra_4x4_Horizontal_Up prediction mode
src/h264/decoder.rs:958:                // Equations 8-67 to 8-70
src/h264/decoder.rs:999:            // Section 8.3.3.1 Specification of Intra_16x16_Vertical prediction mode
src/h264/decoder.rs:1000:            // Equation 8-116: predL[x, y] = p[x, -1]
src/h264/decoder.rs:1009:            // Section 8.3.3.2 Specification of Intra_16x16_Horizontal prediction mode
src/h264/decoder.rs:1010:            // Equation 8-117: predL[x, y] = p[-1, y]
src/h264/decoder.rs:1018:            // Section 8.3.3.3 Specification of Intra_16x16_DC prediction mode
src/h264/decoder.rs:1034:            // Equations 8-118 to 8-121
src/h264/decoder.rs:1050:            // Section 8.3.3.4 Specification of Intra_16x16_Plane prediction mode
src/h264/decoder.rs:1059:            // Equations 8-126, 8-127
src/h264/decoder.rs:1066:            // Equation 8-123: a
src/h264/decoder.rs:1068:            // Equation 8-124: b
src/h264/decoder.rs:1070:            // Equation 8-125: c
src/h264/decoder.rs:1078:                    // Equation 8-122
src/h264/decoder.rs:1108:    // Section 8.3.4 Intra prediction process for chroma samples
src/h264/decoder.rs:1122:            // Section 8.3.4.3 Specification of Intra_Chroma_Vertical prediction mode
src/h264/decoder.rs:1123:            // Equation 8-143
src/h264/decoder.rs:1134:            // Section 8.3.4.2 Specification of Intra_Chroma_Horizontal prediction mode
src/h264/decoder.rs:1135:            // Equation 8-142
src/h264/decoder.rs:1143:            // Section 8.3.4.1 Specification of Intra_Chroma_DC prediction mode
src/h264/decoder.rs:1168:                // Equations 8-132 to 8-141 (derivation of prediction values based on availability)
src/h264/decoder.rs:1227:            // Section 8.3.4.4 Specification of Intra_Chroma_Plane prediction mode
src/h264/decoder.rs:1233:            // Equation 8-148: H
src/h264/decoder.rs:1243:            // Equation 8-149: V
src/h264/decoder.rs:1249:            // Equation 8-145: a
src/h264/decoder.rs:1251:            // Equation 8-146: b
src/h264/decoder.rs:1253:            // Equation 8-147: c
src/h264/decoder.rs:1261:                    // Equation 8-144
src/h264/sps.rs:1:use super::{tables, ChromaFormat, Profile};
src/h264/sps.rs:57:// Section 7.4.2.1.1 Sequence parameter set data semantics
src/h264/sps.rs:127:        self.pic_width_in_mbs() * tables::MB_WIDTH
src/h264/sps.rs:135:        self.pic_hight_in_mbs() * tables::MB_HEIGHT
src/h264/mod.rs:15:pub mod tables;
src/h264/dpb.rs:5:// Section 8.2.5: Decoded reference picture marking process
src/h264/dpb.rs:81:    /// Section C.4.5.3: Implements the "bumping" process to output frames when the DPB is full.
src/h264/dpb.rs:120:    // Section 8.2.5 Decoded reference picture marking process
src/h264/dpb.rs:147:        // Section 8.2.5.1
src/h264/dpb.rs:170:        // Section 8.2.5.4 Adaptive memory control decoded reference picture marking process
src/h264/dpb.rs:243:        // Section 8.2.5.3 Sliding window decoded reference picture marking process
src/h264/profiles.txt:17:– The level constraints specified for the Baseline profile in clause A.3 shall be fulfilled.
src/h264/residual.rs:8:    tables, ColorPlane,
src/h264/residual.rs:112:                // Section 8.5.2 Specification of transform decoding process for luma samples
src/h264/residual.rs:149:            // Section 8.5.8, 8.5.11 Specification of transform decoding process for chroma samples
src/h264/residual.rs:185:// Figure 8-6 – Assignment of the indices of dcY to luma4x4BlkIdx
src/h264/residual.rs:188:    const TABLE: [(usize, usize); 16] = [
src/h264/residual.rs:206:    TABLE[idx]
src/h264/residual.rs:214:// Figure 8-7 – Assignment of the indices of dcC to chroma4x4BlkIdx
src/h264/residual.rs:217:    const TABLE: [(usize, usize); 4] = [(0, 0), (0, 1), (1, 0), (1, 1)];
src/h264/residual.rs:218:    TABLE[idx]
src/h264/residual.rs:221:// Table 8-13 – Specification of mapping of idx to Cij for zig-zag scan
src/h264/residual.rs:224:    const TABLE: [(usize, usize); 16] = [
src/h264/residual.rs:242:    TABLE[idx]
src/h264/residual.rs:248:    const TABLE: [usize; 16] =
src/h264/residual.rs:250:    TABLE[row * 4 + column]
src/h264/residual.rs:261:// Section 8.5.9 Derivation process for scaling functions
src/h264/residual.rs:269:// Section 8.5.12.1 Scaling process for residual 4x4 blocks
src/h264/residual.rs:276:            // Equation 8-336
src/h264/residual.rs:279:            // Equation 8-337
src/h264/residual.rs:286:// Section 8.5.10 Scaling and transformation process for DC transform coefficients for Intra_16x16
src/h264/residual.rs:293:                // Equation 8-321
src/h264/residual.rs:296:                // Equation 8-322
src/h264/residual.rs:304:// Section 8.5.11.2 Scaling and transformation process for chroma DC transform coefficients
src/h264/residual.rs:310:            // Equation 8-326 (approximated)
src/h264/residual.rs:317:// Section 8.5.10 Scaling and transformation process for DC transform coefficients for Intra_16x16
src/h264/residual.rs:324:    Equation 8-320 (Inverse Hadamard Transform)
src/h264/residual.rs:363:// Section 8.5.11.1 Transformation process for chroma DC transform coefficients
src/h264/residual.rs:368:    // Equation 8-324
src/h264/residual.rs:398:// Section 8.5.12.2 Transformation process for residual 4x4 blocks
src/h264/residual.rs:403:        // (8-338)
src/h264/residual.rs:405:        // (8-339)
src/h264/residual.rs:407:        // (8-340)
src/h264/residual.rs:409:        // (8-341)
src/h264/residual.rs:412:        // (8-342)
src/h264/residual.rs:414:        // (8-343)
src/h264/residual.rs:416:        // (8-344)
src/h264/residual.rs:418:        // (8-345)
src/h264/residual.rs:423:        // (8-346)
src/h264/residual.rs:425:        // (8-347)
src/h264/residual.rs:427:        // (8-348)
src/h264/residual.rs:429:        // (8-349)
src/h264/residual.rs:432:        // (8-350)
src/h264/residual.rs:434:        // (8-351)
src/h264/residual.rs:436:        // (8-352)
src/h264/residual.rs:438:        // (8-353)
src/h264/parser.rs:9:use super::tables;
src/h264/parser.rs:24:    DeblockingFilterIdc, DecRefPicMarking, MemoryManagementControlOperation, PredWeightTable,
src/h264/parser.rs:90:// Section 7.4.1
src/h264/parser.rs:98:// Section 7.2
src/h264/parser.rs:188:// Section 7.3.2.1.1 Sequence parameter set data syntax
src/h264/parser.rs:354:// Section 7.3.2.2 Picture parameter set RBSP syntax
src/h264/parser.rs:470:// Section 7.3.3.1 Reference picture list modification syntax
src/h264/parser.rs:552:// Section 7.3.3.2 Prediction weight table syntax
src/h264/parser.rs:553:pub fn parse_pred_weight_table(
src/h264/parser.rs:558:) -> ParseResult<PredWeightTable> {
src/h264/parser.rs:572:    let mut table = PredWeightTable::default();
src/h264/parser.rs:573:    read_value!(input, table.luma_log2_weight_denom, ue, 8);
src/h264/parser.rs:575:        read_value!(input, table.chroma_log2_weight_denom, ue, 8);
src/h264/parser.rs:580:            luma_weight: 1 << table.luma_log2_weight_denom,
src/h264/parser.rs:583:                1 << table.chroma_log2_weight_denom,
src/h264/parser.rs:584:                1 << table.chroma_log2_weight_denom,
src/h264/parser.rs:606:        table.list0.push(factors);
src/h264/parser.rs:612:                luma_weight: 1 << table.luma_log2_weight_denom,
src/h264/parser.rs:615:                    1 << table.chroma_log2_weight_denom,
src/h264/parser.rs:616:                    1 << table.chroma_log2_weight_denom,
src/h264/parser.rs:638:            table.list1.push(factors);
src/h264/parser.rs:642:    Ok(table)
src/h264/parser.rs:645:// Section 7.3.3.3 Decoded reference picture marking syntax
src/h264/parser.rs:721:// Section 7.3.3 Slice header syntax
src/h264/parser.rs:810:        header.pred_weight_table = Some(parse_pred_weight_table(input, &header, sps, pps)?);
src/h264/parser.rs:899:                let nc = -1; // Section 9.2.1, If ChromaArrayType is 1, nC = −1,
src/h264/parser.rs:921:// Section 8.3.1.1 Derivation process for Intra4x4PredMode
src/h264/parser.rs:954:// Section 7.3.5 Macroblock layer syntax
src/h264/parser.rs:963:        // The macroblock types for P and SP slices are specified in Tables 7-13 and 7-11.
src/h264/parser.rs:964:        // mb_type values 0 to 4 are specified in Table 7-13 and mb_type values 5 to 30 are
src/h264/parser.rs:965:        // specified in Table 7-11, indexed by subtracting 5 from the value of mb_type.
src/h264/parser.rs:1019:// Section 8.4.1.2 Derivation process for motion vector prediction
src/h264/parser.rs:1045:    // Directional segmentation prediction (8-203 to 8-206)
src/h264/parser.rs:1084:    // Median prediction (Section 8.4.1.3.1)
src/h264/parser.rs:1087:    // C is replaced by D if C is unavailable (8-214)
src/h264/parser.rs:1092:    // If B and C are unavailable and A is available, use A for everything (8-207)
src/h264/parser.rs:1110:    // use that motion vector (8-211).
src/h264/parser.rs:1129:    // Step 3: Median of components (8-212, 8-213)
src/h264/parser.rs:1184:            // Section 8.4.1.1 Derivation process for luma motion vectors for skipped macroblocks in P and SP slices
src/h264/parser.rs:1220:            // Section 8.4.1 Derivation process for motion vector components and reference indices
src/h264/parser.rs:1227:                    // Table 7-18 – Sub-macroblock types in P macroblocks
src/h264/parser.rs:1252:            // Section 8.4.1 Derivation process for motion vector components and reference indices
src/h264/parser.rs:1261:                // Table 7-13 – Macroblock type values 0 to 4 for P and SP slices
src/h264/parser.rs:1365:        tables::code_num_to_inter_coded_block_pattern(coded_block_pattern_num)
src/h264/parser.rs:1390:            tables::MB_WIDTH * tables::MB_HEIGHT * tables::BIT_DEPTH / (u8::BITS as usize);
src/h264/parser.rs:1443:            block.coded_block_pattern = tables::mb_type_to_coded_block_pattern(block.mb_type)
src/h264/parser.rs:1449:                tables::code_num_to_intra_coded_block_pattern(coded_block_pattern_num)
src/h264/parser.rs:1472:// Section 7.3.4 Slice data syntax
src/h264/cavlc.rs:2:use super::tables;
src/h264/cavlc.rs:21:// Generates a 16KB Lookup Table (LUT) for `total_zeros` decoding at compile time.
src/h264/cavlc.rs:29:// The table `TABLE9_7AND8` contains variable-length codes.
src/h264/cavlc.rs:39:            let row = tables::TABLE9_7AND8[row_idx];
src/h264/cavlc.rs:79:// Naive implementation of Tables 9-7, 9-8 lookup for total_zeros patterns
src/h264/cavlc.rs:96:            let row = tables::TABLE9_9A[row_idx];
src/h264/cavlc.rs:124:// Naive implementation of Tables 9-9 total_zeros patterns
src/h264/cavlc.rs:133:// Naive implementation of Table 9-10 – Tables for run_before
src/h264/cavlc.rs:135:    for row in tables::TABLE9_10 {
src/h264/cavlc.rs:158:// Naive implementation of Table 9-5 lookup for coeff_token patterns
src/h264/cavlc.rs:160:    for row in tables::TABLE95 {
src/h264/cavlc.rs:183:// Section 9.2.2.1 Parsing process for level_prefix
src/h264/cavlc.rs:216:    // Section 9.2.2 Parsing process for level information
src/h264/cavlc.rs:269:    // Section 9.2.3 Parsing process for run information
src/h264/cavlc.rs:309:    // Section 9.2.4 Combining level and run information
src/h264/tables.rs:12:// Table 7-3 – Specification of default scaling lists Default_4x4_Intra and Default_4x4_Inter
src/h264/tables.rs:18:// Table 9-4 – Assignment of codeNum to values of coded_block_pattern for
src/h264/tables.rs:46:// Table 7-11 – Macroblock types for I slices
src/h264/tables.rs:77:// Table 7-11 – Macroblock types for I slices
src/h264/tables.rs:109:pub const TABLE95: [(
src/h264/tables.rs:117:); 62] = include!("table_9-5.rs");
src/h264/tables.rs:120:pub const TABLE9_7AND8: [(
src/h264/tables.rs:137:); 16] = include!("tables_9-7and8.rs");
src/h264/tables.rs:140:pub const TABLE9_9A: [(u8, BitPattern, BitPattern, BitPattern); 4] = include!("table_9-9_a.rs");
src/h264/tables.rs:143:pub const TABLE9_9B: [(
src/h264/tables.rs:152:); 8] = include!("table_9-9_b.rs");
src/h264/tables.rs:155:pub const TABLE9_10: [(
src/h264/tables.rs:164:); 15] = include!("table_9-10.rs");
src/h264/deblocking.rs:6:use super::tables::{MB_HEIGHT, MB_WIDTH};
src/h264/deblocking.rs:18:// Table 8-16
src/h264/deblocking.rs:19:const ALPHA_TABLE: [u8; 52] = [
src/h264/deblocking.rs:25:const BETA_TABLE: [u8; 52] = [
src/h264/deblocking.rs:30:// Table 8-17
src/h264/deblocking.rs:31:const TC0_TABLE: [[u8; 52]; 3] = [
src/h264/deblocking.rs:133:        // Section 8.7, Step 2.c:
src/h264/deblocking.rs:169:        // Section 8.7, Step 2.d:
src/h264/deblocking.rs:233:    // Equation 8-453: qp_av calculation
src/h264/deblocking.rs:235:    // Equation 8-454: indexA, Equation 8-455: indexB
src/h264/deblocking.rs:239:    let alpha = ALPHA_TABLE[index_a];
src/h264/deblocking.rs:240:    let beta = BETA_TABLE[index_b];
src/h264/deblocking.rs:273:        // Check filter condition (Equation 8-460, alpha/beta from 8-456/8-457)
src/h264/deblocking.rs:303:                // Section 8.7.2.3 Filtering process for edges with bS < 4
src/h264/deblocking.rs:304:                // Calculate tc0 (Table 8-17)
src/h264/deblocking.rs:305:                let tc0 = TC0_TABLE[(bs - 1) as usize][index_a];
src/h264/deblocking.rs:311:                // Equation 8-465
src/h264/deblocking.rs:320:                // Equation 8-467: Delta
src/h264/deblocking.rs:326:                // Equation 8-468, 8-469
src/h264/deblocking.rs:334:                // Filter p1 (Section 8.7.2.3) if condition met
src/h264/deblocking.rs:338:                    // Equation 8-470
src/h264/deblocking.rs:340:                    // Equation 8-470 (application)
src/h264/deblocking.rs:350:                    // Equation 8-472
src/h264/deblocking.rs:352:                    // Equation 8-472 (application)
src/h264/deblocking.rs:358:                // Section 8.7.2.4 Filtering process for edges with bS equal to 4
src/h264/deblocking.rs:363:                // Equation 8-476
src/h264/deblocking.rs:374:                    // Equation 8-477
src/h264/deblocking.rs:376:                    // Equation 8-478
src/h264/deblocking.rs:378:                    // Equation 8-479
src/h264/deblocking.rs:382:                    // Equation 8-480
src/h264/deblocking.rs:397:                    // Equation 8-484
src/h264/deblocking.rs:399:                    // Equation 8-485
src/h264/deblocking.rs:401:                    // Equation 8-486
src/h264/deblocking.rs:405:                    // Equation 8-487
src/h264/deblocking.rs:472:            // Equation 8-453 (qPav) and Clause 8.5.8 (QPC)
src/h264/deblocking.rs:482:            let alpha = ALPHA_TABLE[index_a];
src/h264/deblocking.rs:483:            let beta = BETA_TABLE[index_b];
src/h264/deblocking.rs:513:            // Equation 8-460
src/h264/deblocking.rs:519:                    let tc0 = TC0_TABLE[(bs - 1) as usize][index_a];
src/h264/deblocking.rs:520:                    let tc = tc0 as i32 + 1; // Chroma always adds 1 to tc0 (Equation 8-466)
src/h264/deblocking.rs:522:                    // Equation 8-467
src/h264/deblocking.rs:526:                    // Equation 8-468, Equation 8-469
src/h264/deblocking.rs:533:                    // Equation 8-480 (p0_new), Equation 8-487 (q0_new)
src/h264/deblocking.rs:557:    // Section 8.7.2.1 Derivation process for the luma content dependent boundary filtering strength
src/h264/deblocking.rs:617:    // Clause 8.7.2.1: check if the 4x4 luma transform block contains non-zero transform coefficient levels.
src/h264/deblocking.rs:641:    // This implements the check "contains non-zero transform coefficient levels" from Clause 8.7.2.1.
