**7.4** **Semantics**


Semantics associated with the syntax structures and with the syntax elements within these structures are specified in this
clause. When the semantics of a syntax element are specified using a table or a set of tables, any values that are not specified
in the table(s) shall not be present in the bitstream unless otherwise specified in this Recommendation | International
Standard.


**7.4.1** **NAL unit semantics**
NOTE 1 – The VCL is specified to efficiently represent the content of the video data. The NAL is specified to format that data and
provide header information in a manner appropriate for conveyance on a variety of communication channels or storage media. All
data are contained in NAL units, each of which contains an integer number of bytes. A NAL unit specifies a generic format for use
in both packet-oriented and bitstream systems. The format of NAL units for both packet-oriented transport and byte stream is
identical except that each NAL unit can be preceded by a start code prefix and extra padding bytes in the byte stream format.


NumBytesInNALunit specifies the size of the NAL unit in bytes. This value is required for decoding of the NAL unit.
Some form of demarcation of NAL unit boundaries is necessary to enable inference of NumBytesInNALunit. One such
demarcation method is specified in Annex B for the byte stream format. Other methods of demarcation may be specified
outside of this Recommendation | International Standard.


**forbidden_zero_bit** shall be equal to 0.





**nal_ref_idc** not equal to 0 specifies that the content of the NAL unit contains a sequence parameter set, a sequence
parameter set extension, a subset sequence parameter set, a picture parameter set, a slice of a reference picture, a slice data
partition of a reference picture, or a prefix NAL unit preceding a slice of a reference picture.


For coded video sequences conforming to one or more of the profiles specified in Annex A that are decoded using the
decoding process specified in clauses 2 to 9, nal_ref_idc equal to 0 for a NAL unit containing a slice or slice data partition
indicates that the slice or slice data partition is part of a non-reference picture.


nal_ref_idc shall not be equal to 0 for sequence parameter set or sequence parameter set extension or subset sequence
parameter set or picture parameter set NAL units. When nal_ref_idc is equal to 0 for one NAL unit with nal_unit_type in
the range of 1 to 4, inclusive, of a particular picture, it shall be equal to 0 for all NAL units with nal_unit_type in the range
of 1 to 4, inclusive, of the picture.


nal_ref_idc shall not be equal to 0 for NAL units with nal_unit_type equal to 5.


nal_ref_idc shall be equal to 0 for all NAL units having nal_unit_type equal to 6, 9, 10, 11, or 12.


**nal_unit_type** specifies the type of RBSP data structure contained in the NAL unit as specified in Table 7-1.


The column marked "C" in Table 7-1 lists the categories of the syntax elements that may be present in the NAL unit. In
addition, syntax elements with syntax category "All" may be present, as determined by the syntax and semantics of the
RBSP data structure. The presence or absence of any syntax elements of a particular listed category is determined from the
syntax and semantics of the associated RBSP data structure. nal_unit_type shall not be equal to 3 or 4 unless at least one
syntax element is present in the RBSP data structure having a syntax element category value equal to the value of
nal_unit_type and not categorized as "All".


For coded video sequences conforming to one or more of the profiles specified in Annex A that are decoded using the
decoding process specified in clauses 2-9, VCL and non-VCL NAL units are specified in Table 7-1 in the column labelled
"Annex A NAL unit type class". For coded video sequences conforming to one or more of the profiles specified in Annex G
that are decoded using the decoding process specified in Annex G and for coded video sequences conforming to one or
more of the profiles specified in Annex H that are decoded using the decoding process specified in Annex H, VCL and
non-VCL NAL units are specified in Table 7-1 in the column labelled "Annex G and Annex H NAL unit type class". The
entry "suffix dependent" for nal_unit_type equal to 14 is specified as follows:

- If the NAL unit directly following in decoding order a NAL unit with nal_unit_type equal to 14 is a NAL unit with
nal_unit_type equal to 1 or 5, the NAL unit with nal_unit_type equal to 14 is a VCL NAL unit.

- Otherwise (the NAL unit directly following in decoding order a NAL unit with nal_unit_type equal to 14 is a NAL
unit with nal_unit_type not equal to 1 or 5), the NAL unit with nal_unit_type equal to 14 is a non-VCL NAL unit.
Decoders shall ignore (remove from the bitstream and discard) the NAL unit with nal_unit_type equal to 14 and the
NAL unit directly following (in decoding order) the NAL unit with nal_unit_type equal to 14.





**Table 7-1 – NAL unit type codes, syntax element categories, and NAL unit type classes**









































|nal_unit_type|Content of NAL unit and RBSP<br>syntax structure|C|Annex A<br>NAL unit<br>type class|Annex G<br>and<br>Annex H<br>NAL unit<br>type class|Annex I<br>and<br>Annex J<br>NAL unit<br>type class|
|---|---|---|---|---|---|
|0|Unspecified||non-VCL|non-VCL|non-VCL|
|1|Coded slice of a non-IDR picture<br>slice_layer_without_partitioning_rbsp( )|2, 3, 4|VCL|VCL|VCL|
|2|Coded slice data partition A<br>slice_data_partition_a_layer_rbsp( )|2|VCL|not applicable|not applicable|
|3|Coded slice data partition B<br>slice_data_partition_b_layer_rbsp( )|3|VCL|not applicable|not applicable|
|4|Coded slice data partition C<br>slice_data_partition_c_layer_rbsp( )|4|VCL|not applicable|not applicable|
|5|Coded slice of an IDR picture<br>slice_layer_without_partitioning_rbsp( )|2, 3|VCL|VCL|VCL|
|6|Supplemental enhancement information<br>(SEI)<br>sei_rbsp( )|5|non-VCL|non-VCL|non-VCL|
|7|Sequence parameter set<br>seq_parameter_set_rbsp( )|0|non-VCL|non-VCL|non-VCL|
|8|Picture parameter set<br>pic_parameter_set_rbsp( )|1|non-VCL|non-VCL|non-VCL|
|9|Access unit delimiter<br>access_unit_delimiter_rbsp( )|6|non-VCL|non-VCL|non-VCL|
|10|End of sequence<br>end_of_seq_rbsp( )|7|non-VCL|non-VCL|non-VCL|
|11|End of stream<br>end_of_stream_rbsp( )|8|non-VCL|non-VCL|non-VCL|
|12|Filler data<br>filler_data_rbsp( )|9|non-VCL|non-VCL|non-VCL|
|13|Sequence parameter set extension<br>seq_parameter_set_extension_rbsp( )|10|non-VCL|non-VCL|non-VCL|
|14|Prefix NAL unit<br>prefix_nal_unit_rbsp( )|2|non-VCL|suffix<br>dependent|suffix<br>dependent|
|15|Subset sequence parameter set<br>subset_seq_parameter_set_rbsp( )|0|non-VCL|non-VCL|non-VCL|
|16|Depth parameter set<br>depth_parameter_set_rbsp( )|11|non-VCL|non-VCL|non-VCL|
|17..18|Reserved||non-VCL|non-VCL|non-VCL|
|19|Coded slice of an auxiliary coded<br>picture without partitioning<br>slice_layer_without_partitioning_rbsp( )|2, 3, 4|non-VCL|non-VCL|non-VCL|
|20|Coded slice extension<br>slice_layer_extension_rbsp( )|2, 3, 4|non-VCL|VCL|VCL|
|21|Coded slice extension for a depth view<br>component or a 3D-AVC texture view<br>component<br>slice_layer_extension_rbsp( )|2, 3, 4|non-VCL|non-VCL|VCL|
|22..23|Reserved||non-VCL|non-VCL|VCL|
|24..31|Unspecified|<br>|non-VCL|non-VCL|non-VCL|


When NAL units with nal_unit_type equal to 13 or 19 are present in a coded video sequence, decoders shall either perform
the (optional) decoding process specified for these NAL units or shall ignore (remove from the bitstream and discard) the
contents of these NAL units.


Decoders that conform to one or more of the profiles specified in Annex A rather than the profiles specified in Annexes G
or H shall ignore (remove from the bitstream and discard) the contents of all NAL units with nal_unit_type equal to 14,
15, or 20.





NAL units that use nal_unit_type equal to 0 or in the range of 24..31, inclusive, shall not affect the decoding process
specified in this Recommendation | International Standard.

NOTE 2 – NAL unit types 0 and 24..31 may be used as determined by the application. No decoding process for these values of
nal_unit_type is specified in this Recommendation | International Standard. Since different applications might use NAL unit types
0 and 24..31 for different purposes, particular care must be exercised in the design of encoders that generate NAL units with
nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, and in the design of decoders that interpret the content of NAL units
with nal_unit_type equal to 0 or in the range of 24 to 31, inclusive.


Decoders shall ignore (remove from the bitstream and discard) the contents of all NAL units that use reserved values of
nal_unit_type.

NOTE 3 – This requirement allows future definition of compatible extensions to this Recommendation | International Standard.
NOTE 4 – In previous editions of this Recommendation | International Standard, the NAL unit types 13..15 and 19..20 (or a subset
of these NAL unit types) were reserved and no decoding process for NAL units having these values of nal_unit_type was specified.
In later editions of this Recommendation | International Standard, currently reserved values of nal_unit_type might become nonreserved and a decoding process for these values of nal_unit_type might be specified. Encoders should take into consideration that
the values of nal_unit_type that were reserved in previous editions of this Recommendation | International Standard might be ignored
by decoders.


In the text, coded slice NAL unit collectively refers to a coded slice of a non-IDR picture NAL unit or to a coded slice of
an IDR picture NAL unit. The variable IdrPicFlag is specified as


IdrPicFlag = ( ( nal_unit_type = = 5 ) ? 1 : 0 ) (7-1)


When the value of nal_unit_type is equal to 5 for a NAL unit containing a slice of a particular picture, the picture shall not
contain NAL units with nal_unit_type in the range of 1 to 4, inclusive. For coded video sequences conforming to one or
more of the profiles specified in Annex A that are decoded using the decoding process specified in clauses 2 to 9, such a
picture is referred to as an IDR picture.

NOTE 5 – Slice data partitioning cannot be used for IDR pictures.


**svc_extension_flag** indicates whether a nal_unit_header_svc_extension( ) or nal_unit_header_mvc_extension( ) will
follow next in the syntax structure.


When svc_extension_flag is not present, the value of svc_extension_flag is inferred to be equal to 0.


The value of svc_extension_flag shall be equal to 1 for coded video sequences conforming to one or more profiles specified
in Annex G. Decoders conforming to one or more profiles specified in Annex G shall ignore (remove from the bitstream
and discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 0.


The value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified
in Annex H. Decoders conforming to one or more profiles specified in Annex H shall ignore (remove from the bitstream
and discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 1.


The value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified
in Annex I. Decoders conforming to one or more profiles specified in Annex I shall ignore (remove from the bitstream and
discard) NAL units for which nal_unit_type is equal to 14, 20, or 21 and for which svc_extension_flag is equal to 1.


The value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified
in Annex J. Decoders conforming to one or more profiles specified in Annex J shall ignore (remove from the bitstream
and discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 1.


**avc_3d_extension_flag** indicates for NAL units having nal_unit_type equal to 21 whether a
nal_unit_header_mvc_extension( ) or nal_unit_header_3davc_extension( ) will follow next in the syntax structure.


When avc_3d_extension_flag is not present, the value of avc_3d_extension_flag is inferred to be equal to 0.


The value of DepthFlag is specified as follows:


DepthFlag = ( nal_unit_type ! = 21 ) ? 0 : ( avc_3d_extension_flag ? depth_flag : 1 ) (7-2)


The value of avc_3d_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles
specified in Annex I. Decoders conforming to one or more profiles specified in Annex I shall ignore (remove from the
bitstream and discard) NAL units for which nal_unit_type is equal to 21 and for which avc_3d_extension_flag is equal
to 1.


**rbsp_byte[** i **]** is the i-th byte of an RBSP. An RBSP is specified as an ordered sequence of bytes as follows.


The RBSP contains an SODB as follows:

- If the SODB is empty (i.e., zero bits in length), the RBSP is also empty.





- Otherwise, the RBSP contains the SODB as follows:

1) The first byte of the RBSP contains the first (most significant, left-most) eight bits of the SODB; the next byte
of the RBSP contains the next eight bits of the SODB, etc., until fewer than eight bits of the SODB remain.

2) The rbsp_trailing_bits( ) syntax structure is present after the SODB as follows:

i) The first (most significant, left-most) bits of the final RBSP byte contain the remaining bits of the SODB
(if any).

ii) The next bit consists of a single bit equal to 1 (i.e., rbsp_stop_one_bit).

iii) When the rbsp_stop_one_bit is not the last bit of a byte-aligned byte, one or more zero-valued bits

(i.e., instances of rbsp_alignment_zero_bit) are present to result in byte alignment.

3) One or more cabac_zero_word 16-bit syntax elements equal to 0x0000 may be present in some RBSPs after the
rbsp_trailing_bits( ) at the end of the RBSP.


Syntax structures having these RBSP properties are denoted in the syntax tables using an "_rbsp" suffix. These structures
shall be carried within NAL units as the content of the rbsp_byte[ i ] data bytes. The association of the RBSP syntax
structures to the NAL units shall be as specified in Table 7-1.

NOTE 6 – When the boundaries of the RBSP are known, the decoder can extract the SODB from the RBSP by concatenating the
bits of the bytes of the RBSP and discarding the rbsp_stop_one_bit, which is the last (least significant, right-most) bit equal to 1,
and discarding any following (less significant, farther to the right) bits that follow it, which are equal to 0. The data necessary for
the decoding process is contained in the SODB part of the RBSP.


**emulation_prevention_three_byte** is a byte equal to 0x03. When an emulation_prevention_three_byte is present in the
NAL unit, it shall be discarded by the decoding process.


The last byte of the NAL unit shall not be equal to 0x00.


Within the NAL unit, the following three-byte sequences shall not occur at any byte-aligned position:

- 0x000000

- 0x000001

- 0x000002


Within the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences shall not occur
at any byte-aligned position:

- 0x00000300

- 0x00000301

- 0x00000302

- 0x00000303
NOTE 7 – When nal_unit_type is equal to 0, particular care must be exercised in the design of encoders to avoid the presence of the
above-listed three-byte and four-byte patterns at the beginning of the NAL unit syntax structure, as the syntax element
emulation_prevention_three_byte cannot be the third byte of a NAL unit.


**7.4.1.1** **Encapsulation of an SODB within an RBSP (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


The form of encapsulation of an SODB within an RBSP and the use of the emulation_prevention_three_byte for
encapsulation of an RBSP within a NAL unit is specified for the following purposes:

- to prevent the emulation of start codes within NAL units while allowing any arbitrary SODB to be represented within
a NAL unit,

- to enable identification of the end of the SODB within the NAL unit by searching the RBSP for the rbsp_stop_one_bit
starting at the end of the RBSP,

- to enable a NAL unit to have a size larger than that of the SODB under some circumstances (using one or more
cabac_zero_word).


The encoder can produce a NAL unit from an RBSP by the following procedure:

1. The RBSP data is searched for byte-aligned bits of the following binary patterns:


'00000000 00000000 000000xx' (where xx represents any 2 bit pattern: 00, 01, 10, or 11),


and a byte equal to 0x03 is inserted to replace these bit patterns with the patterns:


'00000000 00000000 00000011 000000xx',





and finally, when the last byte of the RBSP data is equal to 0x00 (which can only occur when the RBSP ends in
a cabac_zero_word), a final byte equal to 0x03 is appended to the end of the data. The last zero byte of a
byte-aligned three-byte sequence 0x000000 in the RBSP (which is replaced by the four-byte sequence
0x00000300) is taken into account when searching the RBSP data for the next occurrence of byte-aligned bits
with the binary patterns specified above.

2. The resulting sequence of bytes is then prefixed as follows:

     - If nal_unit_type is not equal to 14 or 20, the sequence of bytes is prefixed with the first byte of the NAL unit
containing the syntax elements forbidden_zero_bit, nal_ref_idc, and nal_unit_type, where nal_unit_type
indicates the type of RBSP data structure the NAL unit contains.

     - Otherwise (nal_unit_type is equal to 14 or 20), the sequence of bytes is prefixed with the first four bytes of
the NAL unit, where the first byte contains the syntax elements forbidden_zero_bit, nal_ref_idc, and
nal_unit_type and the following three bytes contain the syntax structure nal_unit_header_svc_extension( ).
The syntax element nal_unit_type in the first byte indicates the presence of the syntax structure
nal_unit_header_svc_extension( ) in the following three bytes and the type of RBSP data structure the NAL
unit contains.

The process specified above results in the construction of the entire NAL unit.


This process can allow any SODB to be represented in a NAL unit while ensuring that

- no byte-aligned start code prefix is emulated within the NAL unit,

- no sequence of 8 zero-valued bits followed by a start code prefix, regardless of byte-alignment, is emulated within
the NAL unit.


**7.4.1.2** **Order of NAL units and association to coded pictures, access units, and video sequences**


This clause specifies constraints on the order of NAL units in the bitstream.


Any order of NAL units in the bitstream obeying these constraints is referred to in the text as the decoding order of NAL
units. Within a NAL unit, the syntax in clauses 7.3, D.1, and E.1 specifies the decoding order of syntax elements. Decoders
shall be capable of receiving NAL units and their syntax elements in decoding order.


**7.4.1.2.1** **Order of sequence and picture parameter set RBSPs and their activation**


This clause specifies the activation process of picture and sequence parameter sets for coded video sequences that conform
to one or more of the profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9.

NOTE 1 – The sequence and picture parameter set mechanism decouples the transmission of infrequently changing information
from the transmission of coded macroblock data. Sequence and picture parameter sets may, in some applications, be conveyed "outof-band" using a reliable transport mechanism.


A picture parameter set RBSP includes parameters that can be referred to by the coded slice NAL units or coded slice data
partition A NAL units of one or more coded pictures. Each picture parameter set RBSP is initially considered not active at
the start of the operation of the decoding process. At most one picture parameter set RBSP is considered active at any given
moment during the operation of the decoding process, and the activation of any particular picture parameter set RBSP
results in the deactivation of the previously-active picture parameter set RBSP (if any).


When a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not active and it is referred to by
a coded slice NAL unit or coded slice data partition A NAL unit (using that value of pic_parameter_set_id), it is activated.
This picture parameter set RBSP is called the active picture parameter set RBSP until it is deactivated by the activation of
another picture parameter set RBSP. A picture parameter set RBSP, with that particular value of pic_parameter_set_id,
shall be available to the decoding process prior to its activation.


Any picture parameter set NAL unit containing the value of pic_parameter_set_id for the active picture parameter set
RBSP for a coded picture shall have the same content as that of the active picture parameter set RBSP for the coded picture
unless it follows the last VCL NAL unit of the coded picture and precedes the first VCL NAL unit of another coded picture.


When a picture parameter set NAL unit with a particular value of pic_parameter_set_id is received, its content replaces
the content of the previous picture parameter set NAL unit, in decoding order, with the same value of pic_parameter_set_id
(when a previous picture parameter set NAL unit with the same value of pic_parameter_set_id was present in the
bitstream).

NOTE 2 – A decoder must be capable of simultaneously storing the contents of the picture parameter sets for all values of
pic_parameter_set_id. The content of the picture parameter set with a particular value of pic_parameter_set_id is overwritten when
a new picture parameter set NAL unit with the same value of pic_parameter_set_id is received.


A sequence parameter set RBSP includes parameters that can be referred to by one or more picture parameter set RBSPs
or one or more SEI NAL units containing a buffering period SEI message. Each sequence parameter set RBSP is initially
considered not active at the start of the operation of the decoding process. At most one sequence parameter set RBSP is





considered active at any given moment during the operation of the decoding process, and the activation of any particular
sequence parameter set RBSP results in the deactivation of the previously-active sequence parameter set RBSP (if any).


When a sequence parameter set RBSP (with a particular value of seq_parameter_set_id) is not already active and it is
referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) or is referred to by an
SEI NAL unit containing a buffering period SEI message (using that value of seq_parameter_set_id), it is activated. This
sequence parameter set RBSP is called the active sequence parameter set RBSP until it is deactivated by the activation of
another sequence parameter set RBSP. A sequence parameter set RBSP, with that particular value of seq_parameter_set_id,
shall be available to the decoding process prior to its activation. An activated sequence parameter set RBSP shall remain
active for the entire coded video sequence.

NOTE 3 – Because an IDR access unit begins a new coded video sequence and an activated sequence parameter set RBSP must
remain active for the entire coded video sequence, a sequence parameter set RBSP can only be activated by a buffering period SEI
message when the buffering period SEI message is part of an IDR access unit.


Any sequence parameter set NAL unit containing the value of seq_parameter_set_id for the active sequence parameter set
RBSP for a coded video sequence shall have the same content as that of the active sequence parameter set RBSP for the
coded video sequence unless it follows the last access unit of the coded video sequence and precedes the first VCL NAL
unit and the first SEI NAL unit containing a buffering period SEI message (when present) of another coded video sequence.

NOTE 4 – If picture parameter set RBSP or sequence parameter set RBSP are conveyed within the bitstream, these constraints
impose an order constraint on the NAL units that contain the picture parameter set RBSP or sequence parameter set RBSP,
respectively. Otherwise (picture parameter set RBSP or sequence parameter set RBSP are conveyed by other means not specified in
this Recommendation | International Standard), they must be available to the decoding process in a timely fashion such that these
constraints are obeyed.


When a sequence parameter set NAL unit with a particular value of seq_parameter_set_id is received, its content replaces
the content of the previous sequence parameter set NAL unit, in decoding order, with the same value of
seq_parameter_set_id (when a previous sequence parameter set NAL unit with the same value of seq_parameter_set_id
was present in the bitstream).

NOTE 5 – A decoder must be capable of simultaneously storing the contents of the sequence parameter sets for all values of
seq_parameter_set_id. The content of the sequence parameter set with a particular value of seq_parameter_set_id is overwritten
when a new sequence parameter set NAL unit with the same value of seq_parameter_set_id is received.


When present, a sequence parameter set extension RBSP includes parameters having a similar function to those of a
sequence parameter set RBSP. For purposes of establishing constraints on the syntax elements of the sequence parameter
set extension RBSP and for purposes of determining activation of a sequence parameter set extension RBSP, the sequence
parameter set extension RBSP shall be considered part of the preceding sequence parameter set RBSP with the same value
of seq_parameter_set_id. When a sequence parameter set RBSP is present that is not followed by a sequence parameter
set extension RBSP with the same value of seq_parameter_set_id prior to the activation of the sequence parameter set
RBSP, the sequence parameter set extension RBSP and its syntax elements shall be considered not present for the active
sequence parameter set RBSP.


All constraints that are expressed on the relationship between the values of the syntax elements (and the values of variables
derived from those syntax elements) in sequence parameter sets and picture parameter sets and other syntax elements are
expressions of constraints that apply only to the active sequence parameter set and the active picture parameter set. If any
sequence parameter set RBSP is present that is not activated in the bitstream, its syntax elements shall have values that
would conform to the specified constraints if it were activated by reference in an otherwise-conforming bitstream. If any
picture parameter set RBSP is present that is not ever activated in the bitstream, its syntax elements shall have values that
would conform to the specified constraints if it were activated by reference in an otherwise-conforming bitstream.


During operation of the decoding process (see clause 8), the values of parameters of the active picture parameter set and
the active sequence parameter set shall be considered in effect. For interpretation of SEI messages, the values of the
parameters of the picture parameter set and sequence parameter set that are active for the operation of the decoding process
for the VCL NAL units of the primary coded picture in the same access unit shall be considered in effect unless otherwise
specified in the SEI message semantics.


**7.4.1.2.2** **Order of access units and association to coded video sequences**


A bitstream conforming to this Recommendation | International Standard consists of one or more coded video sequences.


A coded video sequence consists of one or more access units. For coded video sequences that conform to one or more of
the profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9, the order of NAL
units and coded pictures and their association to access units is described in clause 7.4.1.2.3.


The first access unit of each coded video sequence is an IDR access unit. All subsequent access units in the coded video
sequence are non-IDR access units.


It is a requirement of bitstream conformance that, when two consecutive access units in decoding order within a coded
video sequence both contain non-reference pictures, the value of picture order count for each coded field or field of a coded





frame in the first such access unit shall be less than or equal to the value of picture order count for each coded field or field
of a coded frame in the second such access unit.


It is a requirement of bitstream conformance that, when present, an access unit following an access unit that contains an
end of sequence NAL unit shall be an IDR access unit.


It is a requirement of bitstream conformance that, when an SEI NAL unit contains data that pertain to more than one access
unit (for example, when the SEI NAL unit has a coded video sequence as its scope), it shall be contained in the first access
unit to which it applies.


It is a requirement of bitstream conformance that, when an end of stream NAL unit is present in an access unit, this access
unit shall be the last access unit in the bitstream and the end of stream NAL unit shall be the last NAL unit in that access
unit.


**7.4.1.2.3** **Order of NAL units and coded pictures and association to access units**


This clause specifies the order of NAL units and coded pictures and association to access unit for coded video sequences
that conform to one or more of the profiles specified in Annex A and are decoded using the decoding process specified in
clauses 2 to 9.

NOTE 1 – Some bitstreams that conform to profiles specified in Annexes G or H may violate the NAL unit order specified in this
clause. Conditions under which such a violation of the NAL unit order occurs are specified in clauses G.7.4.1.2.3 and H.7.4.1.2.3.


An access unit consists of one primary coded picture, zero or more corresponding redundant coded pictures, and zero or
more non-VCL NAL units. The association of VCL NAL units to primary or redundant coded pictures is described in
clause 7.4.1.2.5.


The first access unit in the bitstream starts with the first NAL unit of the bitstream.


The first of any of the following NAL units after the last VCL NAL unit of a primary coded picture specifies the start of a
new access unit:


- access unit delimiter NAL unit (when present),


- sequence parameter set NAL unit (when present),


- picture parameter set NAL unit (when present),


- SEI NAL unit (when present),


- NAL units with nal_unit_type in the range of 14 to 18, inclusive (when present),


- first VCL NAL unit of a primary coded picture (always present).


The constraints for the detection of the first VCL NAL unit of a primary coded picture are specified in clause 7.4.1.2.4.


The following constraints shall be obeyed by the order of the coded pictures and non-VCL NAL units within an access
unit:


- When an access unit delimiter NAL unit is present, it shall be the first NAL unit. There shall be at most one access
unit delimiter NAL unit in any access unit.


- When any SEI NAL units are present, they shall precede the primary coded picture.


- When an SEI NAL unit containing a buffering period SEI message is present, the buffering period SEI message shall
be the first SEI message payload of the first SEI NAL unit in the access unit.


- The primary coded picture shall precede the corresponding redundant coded pictures.


- When redundant coded pictures are present, they shall be ordered in ascending order of the value of
redundant_pic_cnt.


- When a sequence parameter set extension NAL unit is present, it shall be the next NAL unit after a sequence parameter
set NAL unit having the same value of seq_parameter_set_id as in the sequence parameter set extension NAL unit.


- When one or more coded slice of an auxiliary coded picture without partitioning NAL units is present, they shall
follow the primary coded picture and all redundant coded pictures (if any).


- When an end of sequence NAL unit is present, it shall follow the primary coded picture and all redundant coded
pictures (if any) and all coded slice of an auxiliary coded picture without partitioning NAL units (if any).


- When an end of stream NAL unit is present, it shall be the last NAL unit.


- NAL units having nal_unit_type equal to 0, 12, or in the range of 20 to 31, inclusive, shall not precede the first VCL
NAL unit of the primary coded picture.





NOTE 2 – Sequence parameter set NAL units or picture parameter set NAL units may be present in an access unit, but cannot follow
the last VCL NAL unit of the primary coded picture within the access unit, as this condition would specify the start of a new access
unit.
NOTE 3 – When a NAL unit having nal_unit_type equal to 7 or 8 is present in an access unit, it may or may not be referred to in
the coded pictures of the access unit in which it is present, and may be referred to in coded pictures of subsequent access units.


The structure of access units not containing any NAL units with nal_unit_type equal to 0, 7, 8, or in the range of 12 to 18,
inclusive, or in the range of 20 to 31, inclusive, is shown in Figure 7-1.


start

















end


**Figure 7-1 – Structure of an access unit not containing any NAL units with nal_unit_type equal to 0, 7, 8,**

**or in the range of 12 to 18, inclusive, or in the range of 20 to 31, inclusive**


**7.4.1.2.4** **Detection of the first VCL NAL unit of a primary coded picture**


This clause specifies constraints on VCL NAL unit syntax that are sufficient to enable the detection of the first VCL NAL
unit of each primary coded picture for coded video sequences that conform to one or more of the profiles specified in
Annex A and are decoded using the decoding process specified in clauses 2 to 9.


Any coded slice NAL unit or coded slice data partition A NAL unit of the primary coded picture of the current access unit
shall be different from any coded slice NAL unit or coded slice data partition A NAL unit of the primary coded picture of
the previous access unit in one or more of the following ways:


- frame_num differs in value. The value of frame_num used to test this condition is the value of frame_num that appears
in the syntax of the slice header, regardless of whether that value is inferred to have been equal to 0 for subsequent
use in the decoding process due to the presence of memory_management_control_operation equal to 5.

NOTE 1 – A consequence of the above statement is that a primary coded picture having frame_num equal to 1 cannot
contain a memory_management_control_operation equal to 5 unless some other condition listed below is fulfilled for the
next primary coded picture that follows after it (if any).


- pic_parameter_set_id differs in value.





- field_pic_flag differs in value.


- bottom_field_flag is present in both and differs in value.


- nal_ref_idc differs in value with one of the nal_ref_idc values being equal to 0.


- pic_order_cnt_type is equal to 0 for both and either pic_order_cnt_lsb differs in value, or delta_pic_order_cnt_bottom
differs in value.


- pic_order_cnt_type is equal to 1 for both and either delta_pic_order_cnt[ 0 ] differs in value, or
delta_pic_order_cnt[ 1 ] differs in value.


- IdrPicFlag differs in value.


- IdrPicFlag is equal to 1 for both and idr_pic_id differs in value.
NOTE 2 – Some of the VCL NAL units in redundant coded pictures or some non-VCL NAL units (e.g., an access unit delimiter
NAL unit) may also be used for the detection of the boundary between access units, and may therefore aid in the detection of the
start of a new primary coded picture.


**7.4.1.2.5** **Order of VCL NAL units and association to coded pictures**


This clause specifies the order of VCL NAL units and association to coded pictures for coded video sequences that conform
to one or more of the profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9.


Each VCL NAL unit is part of a coded picture.


The order of the VCL NAL units within a coded IDR picture is constrained as follows:


- If arbitrary slice order is allowed as specified in Annex A, coded slice of an IDR picture NAL units may have any
order relative to each other.


- Otherwise (arbitrary slice order is not allowed), the following applies:


   - If separate_colour_plane_flag is equal to 0, coded slice of an IDR picture NAL units of a slice group shall not
be interleaved with coded slice of an IDR picture NAL units of another slice group and the order of coded slice
of an IDR picture NAL units within a slice group shall be in the order of increasing macroblock address for the
first macroblock of each coded slice of an IDR picture NAL unit of the particular slice group.


   - Otherwise (separate_colour_plane_flag is equal to 1), coded slice of an IDR picture NAL units of a slice group
for a particular value of colour_plane_id shall not be interleaved with coded slice of an IDR picture NAL units
of another slice group with the same value of colour_plane_id and the order of coded slices of IDR picture NAL
units within a slice group for a particular value of colour_plane_id shall be in the order of increasing macroblock
address for the first macroblock of each coded slice of an IDR picture NAL unit of the particular slice group
having the particular value of colour_plane_id.

NOTE 1 – When separate_colour_plane_flag is equal to 1, the relative ordering of coded slices having different values
of colour_plane_id is not constrained.


The order of the VCL NAL units within a coded non-IDR picture is constrained as follows:


- If arbitrary slice order is allowed as specified in Annex A, coded slice of a non-IDR picture NAL units or coded slice
data partition A NAL units may have any order relative to each other. A coded slice data partition A NAL unit with a
particular value of slice_id shall precede any present coded slice data partition B NAL unit with the same value of
slice_id. A coded slice data partition A NAL unit with a particular value of slice_id shall precede any present coded
slice data partition C NAL unit with the same value of slice_id. When a coded slice data partition B NAL unit with a
particular value of slice_id is present, it shall precede any present coded slice data partition C NAL unit with the same
value of slice_id.


- Otherwise (arbitrary slice order is not allowed), the following applies:


   - If separate_colour_plane_flag is equal to 0, coded slice of a non-IDR picture NAL units or coded slice data
partition NAL units of a slice group shall not be interleaved with coded slice of a non-IDR picture NAL units
or coded slice data partition NAL units of another slice group and the order of coded slice of a non-IDR picture
NAL units or coded slice data partition A NAL units within a slice group shall be in the order of increasing
macroblock address for the first macroblock of each coded slice of a non-IDR picture NAL unit or coded slice
data partition A NAL unit of the particular slice group. A coded slice data partition A NAL unit with a particular
value of slice_id shall immediately precede any present coded slice data partition B NAL unit with the same
value of slice_id. A coded slice data partition A NAL unit with a particular value of slice_id shall immediately
precede any present coded slice data partition C NAL unit with the same value of slice_id, when a coded slice
data partition B NAL unit with the same value of slice_id is not present. When a coded slice data partition B
NAL unit with a particular value of slice_id is present, it shall immediately precede any present coded slice data
partition C NAL unit with the same value of slice_id.





   - Otherwise (separate_colour_plane_flag is equal to 1), coded slice of a non-IDR picture NAL units or coded slice
data partition NAL units of a slice group for a particular value of colour_plane_id shall not be interleaved with
coded slice of a non-IDR picture NAL units or coded slice data partition NAL units of another slice group with
the same value of colour_plane_id and the order of coded slice of a non-IDR picture NAL units or coded slice
data partition A NAL units within a slice group for particular value of colour_plane_id shall be in the order of
increasing macroblock address for the first macroblock of each coded slice of a non-IDR picture NAL unit or
coded slice data partition A NAL unit of the particular slice group having the particular value of colour_plane_id.
A coded slice data partition A NAL unit associated with a particular value of slice_id and colour_plane_id shall
immediately precede any present coded slice data partition B NAL unit with the same value of slice_id and
colour_plane_id. A coded slice data partition A NAL unit associated with a particular value of slice_id and
colour_plane_id shall immediately precede any present coded slice data partition C NAL unit with the same
value of slice_id and colour_plane_id, when a coded slice data partition B NAL unit with the same value of
slice_id and colour_plane_id is not present. When a coded slice data partition B NAL unit with a particular
value of slice_id and colour_plane_id is present, it shall immediately precede any present coded slice data
partition C NAL unit with the same value of slice_id and colour_plane_id.

NOTE 2 – When separate_colour_plane_flag is equal to 1, the relative ordering of coded slices having different values
of colour_plane_id is not constrained.


NAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL
unit of the primary coded picture within the access unit.


NAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in
the access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit.


NAL units having nal_unit_type in the range of 20 to 23, inclusive, shall not precede the first VCL NAL unit of the primary
coded picture within the access unit.


**7.4.2** **Raw byte sequence payloads and RBSP trailing bits semantics**


**7.4.2.1** **Sequence parameter set RBSP semantics**


**7.4.2.1.1** **Sequence parameter set data semantics**


**profile_idc** and **level_idc** indicate the profile and level to which the coded video sequence conforms.


**constraint_set0_flag** equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.1.
constraint_set0_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in
clause A.2.1.


**constraint_set1_flag** equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.2.
constraint_set1_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in
clause A.2.2.


**constraint_set2_flag** equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.3.
constraint_set2_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in
clause A.2.3.

NOTE 1 – When one or more than one of constraint_set0_flag, constraint_set1_flag, or constraint_set2_flag are equal to 1, the coded
video sequence must obey the constraints of all of the indicated subclauses of clause A.2. When profile_idc is equal to 44, 100, 110,
122, or 244, the values of constraint_set0_flag, constraint_set1_flag, and constraint_set2_flag must all be equal to 0.


**constraint_set3_flag** is specified as follows:

- If profile_idc is equal to 66, 77, or 88 and level_idc is equal to 11, constraint_set3_flag equal to 1 indicates that the
coded video sequence obeys all constraints specified in Annex A for level 1b and constraint_set3_flag equal to 0
indicates that the coded video sequence obeys all constraints specified in Annex A for level 1.1.

- Otherwise, if profile_idc is equal to 100 or 110, constraint_set3_flag equal to 1 indicates that the coded video
sequence obeys all constraints specified in Annex A for the High 10 Intra profile, and constraint_set3_flag equal to
0 indicates that the coded video sequence may or may not obey these corresponding constraints.

- Otherwise, if profile_idc is equal to 122, constraint_set3_flag equal to 1 indicates that the coded video sequence obeys
all constraints specified in Annex A for the High 4:2:2 Intra profile, and constraint_set3_flag equal to 0 indicates that
the coded video sequence may or may not obey these corresponding constraints.

- Otherwise, if profile_idc is equal to 44, constraint_set3_flag shall be equal to 1. When profile_idc is equal to 44, the
value of 0 for constraint_set3_flag is forbidden.

- Otherwise, if profile_idc is equal to 244, constraint_set3_flag equal to 1 indicates that the coded video sequence obeys
all constraints specified in Annex A for the High 4:4:4 Intra profile, and constraint_set3_flag equal to 0 indicates that
the coded video sequence may or may not obey these corresponding constraints.





- Otherwise (profile_idc is equal to 66, 77, or 88 and level_idc is not equal to 11, or profile_idc is not equal to 66, 77,
88, 100, 110, 122, 244, or 44), the value of 1 for constraint_set3_flag is reserved for future use by ITU-T | ISO/IEC.
constraint_set3_flag shall be equal to 0 for coded video sequences with profile_idc equal to 66, 77, or 88 and level_idc
not equal to 11 and for coded video sequences with profile_idc not equal to 66, 77, 88, 100, 110, 122, 244, or 44 in
bitstreams conforming to this Recommendation | International Standard. Decoders shall ignore the value of
constraint_set3_flag when profile_idc is equal to 66, 77, or 88 and level_idc is not equal to 11 or when profile_idc is
not equal to 66, 77, 88, 100, 110, 122, 244, or 44.


**constraint_set4_flag** is specified as follows:

- If profile_idc is equal to 77, 88, 100, or 110, constraint_set4_flag equal to 1 indicates that the value of
frame_mbs_only_flag is equal to 1. constraint_set4_flag equal to 0 indicates that the value of frame_mbs_only_flag
may or may not be equal to 1.

- Otherwise, if profile_idc is equal to 118, 128, or 134, constraint_set4_flag equal to 1 indicates that the coded video
sequence obeys all constraints specified in clause H.10.1.1. constraint_set4_flag equal to 0 indicates that the coded
video sequence may or may not obey the constraints specified in clause H.10.1.1.

- Otherwise (profile_idc is not equal to 77, 88, 100, 110, 118, 128, or 134), the value of 1 for constraint_set4_flag is
reserved for future use by ITU-T | ISO/IEC. constraint_set4_flag shall be equal to 0 for coded video sequences with
profile_idc not equal to 77, 88, 100, 110, 118, 128, or 134 in bitstreams conforming to this Recommendation |
International Standard. Decoders shall ignore the value of constraint_set4_flag when profile_idc is not equal to 77,
88, 100, 110, 118, 128, or 134.


**constraint_set5_flag** is specified as follows:


`–` If profile_idc is equal to 77, 88, or 100, constraint_set5_flag equal to 1 indicates that B slice types are not present in
the coded video sequence. constraint_set5_flag equal to 0 indicates that B slice types may or may not be present in the
coded video sequence.


`–` Otherwise, if profile_idc is equal to 118, constraint_set5_flag equal to 1 indicates that the coded video sequence obeys
all constraints specified in clause H.10.1.2 and constraint_set5_flag equal to 0 indicates that the coded video sequence
may or may not obey all constraints specified in clause H.10.1.2.


`–` Otherwise (profile_idc is not equal to 77, 88, 100, or 118), the value of 1 for constraint_set5_flag is reserved for future
use by ITU-T | ISO/IEC. constraint_set5_flag shall be equal to 0 when profile_idc is not equal to 77, 88, 100, or 118
in bitstreams conforming to this Recommendation | International Standard. Decoders shall ignore the value of
constraint_set5_flag when profile_idc is not equal to 77, 88, 100, or 118.

NOTE 2 – For a coded video sequence conforming to both the Multiview High and Stereo High profiles, a corresponding
combination would use profile_idc equal to 118 and constraint_set5_flag equal to 1.


**reserved_zero_2bits** shall be equal to 0. Other values of reserved_zero_2bits may be specified in the future by ITU-T |
ISO/IEC. Decoders shall ignore the value of reserved_zero_2bits.


**seq_parameter_set_id** identifies the sequence parameter set that is referred to by the picture parameter set. The value of
seq_parameter_set_id shall be in the range of 0 to 31, inclusive.

NOTE 3 – When feasible, encoders should use distinct values of seq_parameter_set_id when the values of other sequence parameter
set syntax elements differ rather than changing the values of the syntax elements associated with a specific value of
seq_parameter_set_id.


**chroma_format_idc** specifies the chroma sampling relative to the luma sampling as specified in clause 6.2. The value of
chroma_format_idc shall be in the range of 0 to 3, inclusive. When chroma_format_idc is not present, it shall be inferred
to be equal to 1 (4:2:0 chroma format).


**separate_colour_plane_flag** equal to 1 specifies that the three colour components of the 4:4:4 chroma format are coded
separately. separate_colour_plane_flag equal to 0 specifies that the colour components are not coded separately. When
separate_colour_plane_flag is not present, it shall be inferred to be equal to 0. When separate_colour_plane_flag is equal
to 1, the primary coded picture consists of three separate components, each of which consists of coded samples of one
colour plane (Y, Cb or Cr) that each use the monochrome coding syntax. In this case, each colour plane is associated with
a specific colour_plane_id value.

NOTE 4 – There is no dependency in decoding processes between the colour planes having different colour_plane_id values. For
example, the decoding process of a monochrome picture with one value of colour_plane_id does not use any data from monochrome
pictures having different values of colour_plane_id for inter prediction.


Depending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows:

- If separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.

- Otherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.





**bit_depth_luma_minus8** specifies the bit depth of the samples of the luma array and the value of the luma quantization
parameter range offset QpBdOffsetY, as specified by


BitDepthY = 8 + bit_depth_luma_minus8 (7-3)


QpBdOffsetY = 6 * bit_depth_luma_minus8 (7-4)


When bit_depth_luma_minus8 is not present, it shall be inferred to be equal to 0. bit_depth_luma_minus8 shall be in the
range of 0 to 6, inclusive.


**bit_depth_chroma_minus8** specifies the bit depth of the samples of the chroma arrays and the value of the chroma
quantization parameter range offset QpBdOffsetC, as specified by


BitDepthC = 8 + bit_depth_chroma_minus8 (7-5)


QpBdOffsetC = 6 * bit_depth_chroma_minus8 (7-6)


When bit_depth_chroma_minus8 is not present, it shall be inferred to be equal to 0. bit_depth_chroma_minus8 shall be in
the range of 0 to 6, inclusive.

NOTE 5 – The value of bit_depth_chroma_minus8 is not used in the decoding process when ChromaArrayType is equal to 0. In
particular, when separate_colour_plane_flag is equal to 1, each colour plane is decoded as a distinct monochrome picture using the
luma component decoding process (except for the selection of scaling matrices) and the luma bit depth is used for all three colour
components.


The variable RawMbBits is derived as


RawMbBits = 256 * BitDepthY + 2 * MbWidthC * MbHeightC * BitDepthC (7-7)


**qpprime_y_zero_transform_bypass_flag** equal to 1 specifies that, when QP′Y is equal to 0, a transform bypass operation
for the transform coefficient decoding process and picture construction process prior to deblocking filter process as
specified in clause 8.5 shall be applied. qpprime_y_zero_transform_bypass_flag equal to 0 specifies that the transform
coefficient decoding process and picture construction process prior to deblocking filter process shall not use the transform
bypass operation. When qpprime_y_zero_transform_bypass_flag is not present, it shall be inferred to be equal to 0.


**seq_scaling_matrix_present_flag** equal to 1 specifies that the flags seq_scaling_list_present_flag[ i ] for i = 0..7 or
i = 0..11 are present. seq_scaling_matrix_present_flag equal to 0 specifies that these flags are not present and the sequencelevel scaling list specified by Flat_4x4_16 shall be inferred for i = 0..5 and the sequence-level scaling list specified by
Flat_8x8_16 shall be inferred for i = 6..11. When seq_scaling_matrix_present_flag is not present, it shall be inferred to be
equal to 0.


The scaling lists Flat_4x4_16 and Flat_8x8_16 are specified as follows:


Flat_4x4_16[ k ] = 16,   with k = 0..15, (7-8)


Flat_8x8_16[ k ] = 16,   with k = 0..63. (7-9)


**seq_scaling_list_present_flag[** i **]** equal to 1 specifies that the syntax structure for scaling list i is present in the sequence
parameter set. seq_scaling_list_present_flag[ i ] equal to 0 specifies that the syntax structure for scaling list i is not present
in the sequence parameter set and the scaling list fall-back rule set A specified in Table 7-2 shall be used to infer the
sequence-level scaling list for index i.





**Table 7-2 – Assignment of mnemonic names to scaling list indices and specification of fall-back rule**








































|Value of<br>scaling list<br>index|Mnemonic name|Block<br>size|MB<br>prediction<br>type|Component|Scaling list<br>fall-back rule<br>set A|Scaling list<br>fall-back rule<br>set B|Default<br>scaling list|
|---|---|---|---|---|---|---|---|
|0|Sl_4x4_Intra_Y|4x4|Intra|Y|default<br>scaling list|sequence-level<br>scaling list|Default_4x4_Intra|
|1|Sl_4x4_Intra_Cb|4x4|Intra|Cb|scaling list<br>for i = 0|scaling list<br>for i = 0|Default_4x4_Intra|
|2|Sl_4x4_Intra_Cr|4x4|Intra|Cr|scaling list<br>for i = 1|scaling list<br>for i = 1|Default_4x4_Intra|
|3|Sl_4x4_Inter_Y|4x4|Inter|Y|default<br>scaling list|sequence-level<br>scaling list|Default_4x4_Inter|
|4|Sl_4x4_Inter_Cb|4x4|Inter|Cb|scaling list<br>for i = 3|scaling list<br>for i = 3|Default_4x4_Inter|
|5|Sl_4x4_Inter_Cr|4x4|Inter|Cr|scaling list<br>for i = 4|scaling list<br>for i = 4|Default_4x4_Inter|
|6|Sl_8x8_Intra_Y|8x8|Intra|Y|default<br>scaling list|sequence-level<br>scaling list|Default_8x8_Intra|
|7|Sl_8x8_Inter_Y|8x8|Inter|Y|default<br>scaling list|sequence-level<br>scaling list|Default_8x8_Inter|
|8|Sl_8x8_Intra_Cb|8x8|Intra|Cb|scaling list<br>for i = 6|scaling list<br>for i = 6|Default_8x8_Intra|
|9|Sl_8x8_Inter_Cb|8x8|Inter|Cb|scaling list<br>for i = 7|scaling list<br>for i = 7|Default_8x8_Inter|
|10|Sl_8x8_Intra_Cr|8x8|Intra|Cr|scaling list<br>for i = 8|scaling list<br>for i = 8|Default_8x8_Intra|
|11|Sl_8x8_Inter_Cr|8x8|Inter|Cr|scaling list<br>for i = 9|scaling list<br>for i = 9|Default_8x8_Inter|



Table 7-3 specifies the default scaling lists Default_4x4_Intra and Default_4x4_Inter. Table 7-4 specifies the default
scaling lists Default_8x8_Intra and Default_8x8_Inter.


**Table 7-3 – Specification of default scaling lists Default_4x4_Intra and Default_4x4_Inter**

|idx|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Default_4x4_Intra[ idx ]**|6|13|13|20|20|20|28|28|28|28|32|32|32|37|37|42|
|**Default_4x4_Inter[ idx ]**|10|14|14|20|20|20|24|24|24|24|27|27|27|30|30|34|






**Table 7-4 – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter**

|idx|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Default_8x8_Intra[ idx ]**|6|10|10|13|11|13|16|16|16|16|18|18|18|18|18|23|
|**Default_8x8_Inter[ idx ]**|9|13|13|15|13|15|17|17|17|17|19|19|19|19|19|21|



**Table 7-4 (continued) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter**

|idx|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Default_8x8_Intra[ idx ]**|23|23|23|23|23|25|25|25|25|25|25|25|27|27|27|27|
|**Default_8x8_Inter[ idx ]**|21|21|21|21|21|22|22|22|22|22|22|22|24|24|24|24|



**Table 7-4 (continued) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter**

|idx|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Default_8x8_Intra[ idx ]**|27|27|27|27|29|29|29|29|29|29|29|31|31|31|31|31|
|**Default_8x8_Inter[ idx ]**|24|24|24|24|25|25|25|25|25|25|25|27|27|27|27|27|



**Table 7-4 (concluded) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter**

|idx|48|49|50|51|52|53|54|55|56|57|58|59|60|61|62|63|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Default_8x8_Intra[ idx ]**|31|33|33|33|33|33|36|36|36|36|38|38|38|40|40|42|
|**Default_8x8_Inter[ idx ]**|27|28|28|28|28|28|30|30|30|30|32|32|32|33|33|35|



**log2_max_frame_num_minus4** specifies the value of the variable MaxFrameNum that is used in frame_num related
derivations as follows:


MaxFrameNum = 2 [( log2_max_frame_num_minus4 + 4 )] (7-10)


The value of log2_max_frame_num_minus4 shall be in the range of 0 to 12, inclusive.


**pic_order_cnt_type** specifies the method to decode picture order count (as specified in clause 8.2.1). The value of
pic_order_cnt_type shall be in the range of 0 to 2, inclusive.


pic_order_cnt_type shall not be equal to 2 in a coded video sequence that contains any of the following:


- an access unit containing a non-reference frame followed immediately by an access unit containing a non-reference
picture,


- two access units each containing a field with the two fields together forming a complementary non-reference field
pair followed immediately by an access unit containing a non-reference picture,


- an access unit containing a non-reference field followed immediately by an access unit containing another nonreference picture that does not form a complementary non-reference field pair with the first of the two access units.


**log2_max_pic_order_cnt_lsb_minus4** specifies the value of the variable MaxPicOrderCntLsb that is used in the decoding
process for picture order count as specified in clause 8.2.1 as follows:


MaxPicOrderCntLsb = 2 [( log2_max_pic_order_cnt_lsb_minus4 + 4 )] (7-11)


The value of log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12, inclusive.


**delta_pic_order_always_zero_flag** equal to 1 specifies that delta_pic_order_cnt[ 0 ] and delta_pic_order_cnt[ 1 ] are not
present in the slice headers of the sequence and shall be inferred to be equal to 0. delta_pic_order_always_zero_flag equal
to 0 specifies that delta_pic_order_cnt[ 0 ] is present in the slice headers of the sequence and delta_pic_order_cnt[ 1 ] may
be present in the slice headers of the sequence.





**offset_for_non_ref_pic** is used to calculate the picture order count of a non-reference picture as specified in clause 8.2.1.
The value of offset_for_non_ref_pic shall be in the range of −2 [31] + 1 to 2 [31] - 1, inclusive.


**offset_for_top_to_bottom_field** is used to calculate the picture order count of a bottom field as specified in clause 8.2.1.
The value of offset_for_top_to_bottom_field shall be in the range of −2 [31] + 1 to 2 [31] - 1, inclusive.


**num_ref_frames_in_pic_order_cnt_cycle** is used in the decoding process for picture order count as specified in
clause 8.2.1. The value of num_ref_frames_in_pic_order_cnt_cycle shall be in the range of 0 to 255, inclusive.


**offset_for_ref_frame[** i **]** is an element of a list of num_ref_frames_in_pic_order_cnt_cycle values used in the decoding
process for picture order count as specified in clause 8.2.1. The value of offset_for_ref_frame[ i ] shall be in the range of
−2 [31] + 1 to 2 [31] - 1, inclusive.


When pic_order_cnt_type is equal to 1, the variable ExpectedDeltaPerPicOrderCntCycle is derived by


ExpectedDeltaPerPicOrderCntCycle = 0
for( i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++ )
ExpectedDeltaPerPicOrderCntCycle += offset_for_ref_frame[ i ] (7-12)


**max_num_ref_frames** specifies the maximum number of short-term and long-term reference frames, complementary
reference field pairs, and non-paired reference fields that may be used by the decoding process for inter prediction of any
picture in the coded video sequence. max_num_ref_frames also determines the size of the sliding window operation as
specified in clause 8.2.5.3. The value of max_num_ref_frames shall be in the range of 0 to MaxDpbFrames (as specified
in clause A.3.1 or A.3.2), inclusive.


**gaps_in_frame_num_value_allowed_flag** specifies the allowed values of frame_num as specified in clause 7.4.3 and the
decoding process in case of an inferred gap between values of frame_num as specified in clause 8.2.5.2.


**pic_width_in_mbs_minus1** plus 1 specifies the width of each decoded picture in units of macroblocks.


The variable for the picture width in units of macroblocks is derived as


PicWidthInMbs = pic_width_in_mbs_minus1 + 1 (7-13)


The variable for picture width for the luma component is derived as


PicWidthInSamplesL = PicWidthInMbs * 16 (7-14)


The variable for picture width for the chroma components is derived as


PicWidthInSamplesC = PicWidthInMbs * MbWidthC (7-15)


**pic_height_in_map_units_minus1** plus 1 specifies the height in slice group map units of a decoded frame or field.


The variables PicHeightInMapUnits and PicSizeInMapUnits are derived as


PicHeightInMapUnits = pic_height_in_map_units_minus1 + 1 (7-16)


PicSizeInMapUnits = PicWidthInMbs * PicHeightInMapUnits (7-17)


**frame_mbs_only_flag** equal to 0 specifies that coded pictures of the coded video sequence may either be coded fields or
coded frames. frame_mbs_only_flag equal to 1 specifies that every coded picture of the coded video sequence is a coded
frame containing only frame macroblocks.


The allowed range of values for pic_width_in_mbs_minus1, pic_height_in_map_units_minus1, and frame_mbs_only_flag
is specified by constraints in Annex A.


Depending on frame_mbs_only_flag, semantics are assigned to pic_height_in_map_units_minus1 as follows:


- If frame_mbs_only_flag is equal to 0, pic_height_in_map_units_minus1 plus 1 is the height of a field in units of
macroblocks.


- Otherwise (frame_mbs_only_flag is equal to 1), pic_height_in_map_units_minus1 plus 1 is the height of a frame in
units of macroblocks.


The variable FrameHeightInMbs is derived as


FrameHeightInMbs = ( 2 − frame_mbs_only_flag ) * PicHeightInMapUnits (7-18)





**mb_adaptive_frame_field_flag** equal to 0 specifies no switching between frame and field macroblocks within a picture.
mb_adaptive_frame_field_flag equal to 1 specifies the possible use of switching between frame and field macroblocks
within frames. When mb_adaptive_frame_field_flag is not present, it shall be inferred to be equal to 0.


**direct_8x8_inference_flag** specifies the method used in the derivation process for luma motion vectors for B_Skip,
B_Direct_16x16 and B_Direct_8x8 as specified in clause 8.4.1.2. When frame_mbs_only_flag is equal to 0,
direct_8x8_inference_flag shall be equal to 1.


**frame_cropping_flag** equal to 1 specifies that the frame cropping offset parameters follow next in the sequence parameter
set. frame_cropping_flag equal to 0 specifies that the frame cropping offset parameters are not present.


**frame_crop_left_offset, frame_crop_right_offset, frame_crop_top_offset, frame_crop_bottom_offset** specify the
samples of the pictures in the coded video sequence that are output from the decoding process, in terms of a rectangular
region specified in frame coordinates for output.


The variables CropUnitX and CropUnitY are derived as follows:

- If ChromaArrayType is equal to 0, CropUnitX and CropUnitY are derived as:


CropUnitX = 1 (7-19)
CropUnitY = 2 − frame_mbs_only_flag (7-20)


- Otherwise (ChromaArrayType is equal to 1, 2, or 3), CropUnitX and CropUnitY are derived as:


CropUnitX = SubWidthC (7-21)
CropUnitY = SubHeightC * ( 2 − frame_mbs_only_flag ) (7-22)


The frame cropping rectangle contains luma samples with horizontal frame coordinates from
CropUnitX * frame_crop_left_offset to PicWidthInSamplesL − ( CropUnitX * frame_crop_right_offset + 1 ) and vertical
frame coordinates from CropUnitY * frame_crop_top_offset to ( 16 * FrameHeightInMbs ) −
( CropUnitY * frame_crop_bottom_offset + 1 ), inclusive. The value of frame_crop_left_offset shall be in the range of 0
to ( PicWidthInSamplesL / CropUnitX ) − ( frame_crop_right_offset + 1 ), inclusive; and the value of
frame_crop_top_offset shall be in the range of 0 to ( 16 * FrameHeightInMbs / CropUnitY ) −
( frame_crop_bottom_offset + 1 ), inclusive.


When frame_cropping_flag is equal to 0, the values of frame_crop_left_offset, frame_crop_right_offset,
frame_crop_top_offset, and frame_crop_bottom_offset shall be inferred to be equal to 0.


When ChromaArrayType is not equal to 0, the corresponding specified samples of the two chroma arrays are the samples
having frame coordinates ( x / SubWidthC, y / SubHeightC ), where ( x, y ) are the frame coordinates of the specified luma
samples.


For decoded fields, the specified samples of the decoded field are the samples that fall within the rectangle specified in
frame coordinates.


**vui_parameters_present_flag** equal to 1 specifies that the vui_parameters( ) syntax structure as specified in Annex E is
present. vui_parameters_present_flag equal to 0 specifies that the vui_parameters( ) syntax structure as specified in
Annex E is not present.


**7.4.2.1.1.1** **Scaling list semantics**


**delta_scale** is used to derive the j-th element of the scaling list for j in the range of 0 to sizeOfScalingList − 1, inclusive.
The value of delta_scale shall be in the range of −128 to +127, inclusive.


When useDefaultScalingMatrixFlag is derived to be equal to 1, the scaling list shall be inferred to be equal to the default
scaling list as specified in Table 7-2.


**7.4.2.1.2** **Sequence parameter set extension RBSP semantics**


**seq_parameter_set_id** identifies the sequence parameter set associated with the sequence parameter set extension. The
value of seq_parameter_set_id shall be in the range of 0 to 31, inclusive.


**aux_format_idc** equal to 0 indicates that there are no auxiliary coded pictures in the coded video sequence. aux_format_idc
equal to 1 indicates that exactly one auxiliary coded picture is present in each access unit of the coded video sequence, and
that for alpha blending purposes the decoded samples of the associated primary coded picture in each access unit should
be multiplied by the interpretation sample values of the auxiliary coded picture in the access unit in the display process
after output from the decoding process. aux_format_idc equal to 2 indicates that exactly one auxiliary coded picture exists
in each access unit of the coded video sequence, and that for alpha blending purposes the decoded samples of the associated
primary coded picture in each access unit should not be multiplied by the interpretation sample values of the auxiliary





coded picture in the access unit in the display process after output from the decoding process. aux_format_idc equal to 3
indicates that exactly one auxiliary coded picture exists in each access unit of the coded video sequence, and that the usage
of the auxiliary coded pictures is unspecified. The value of aux_format_idc shall be in the range of 0 to 3, inclusive. Values
greater than 3 for aux_format_idc are reserved to indicate the presence of exactly one auxiliary coded picture in each access
unit of the coded video sequence for purposes to be specified in the future by ITU-T | ISO/IEC. When aux_format_idc is
not present, it shall be inferred to be equal to 0.

NOTE 1 – Decoders are not required to decode auxiliary coded pictures.


**bit_depth_aux_minus8** specifies the bit depth of the samples of the sample array of the auxiliary coded picture.
bit_depth_aux_minus8 shall be in the range of 0 to 4, inclusive.


**alpha_incr_flag** equal to 0 indicates that the interpretation sample value for each decoded auxiliary coded picture sample
value is equal to the decoded auxiliary coded picture sample value for purposes of alpha blending. alpha_incr_flag equal
to 1 indicates that, for purposes of alpha blending, after decoding the auxiliary coded picture samples, any auxiliary coded
picture sample value that is greater than Min(alpha_opaque_value, alpha_transparent_value) should be increased by one
to obtain the interpretation sample value for the auxiliary coded picture sample, and any auxiliary coded picture sample
value that is less than or equal to Min(alpha_opaque_value, alpha_transparent_value) should be used without alteration as
the interpretation sample value for the decoded auxiliary coded picture sample value.


**alpha_opaque_value** specifies the interpretation sample value of an auxiliary coded picture sample for which the
associated luma and chroma samples of the same access unit are considered opaque for purposes of alpha blending. The
number of bits used for the representation of the alpha_opaque_value syntax element is bit_depth_aux_minus8 + 9 bits.


**alpha_transparent_value** specifies the interpretation sample value of an auxiliary coded picture sample for which the
associated luma and chroma samples of the same access unit are considered transparent for purposes of alpha blending.
The number of bits used for the representation of the alpha_transparent_value syntax element is bit_depth_aux_minus8 + 9
bits.


When alpha_incr_flag is equal to 1, alpha_transparent_value shall not be equal to alpha_opaque_value and
Log2( Abs( alpha_opaque_value − alpha_transparent_value ) ) shall have an integer value. A value of
alpha_transparent_value that is equal to alpha_opaque_value indicates that the auxiliary coded picture is not intended for
alpha blending purposes.

NOTE 2 – For alpha blending purposes, alpha_opaque_value may be greater than alpha_transparent_value, or it may be less than
alpha_transparent_value. Interpretation sample values should be clipped to the range of alpha_opaque_value to
alpha_transparent_value, inclusive.


The decoding of the sequence parameter set extension and the decoding of auxiliary coded pictures is not required for
conformance with this Recommendation | International Standard.


The syntax of each coded slice of an auxiliary coded picture shall obey the same constraints as a coded slice of a redundant
picture, with the following differences of constraints:


a) In regard to whether the primary coded picture is an IDR picture, the following applies:


     - If the primary coded picture is an IDR picture, the auxiliary coded slice syntax shall correspond to that of a

slice having nal_unit_type equal to 5 (a slice of an IDR picture).


     - Otherwise (the primary coded picture is not an IDR picture), the auxiliary coded slice syntax shall correspond

to that of a slice having nal_unit_type equal to 1 (a slice of a non-IDR picture).


b) The slices of an auxiliary coded picture (when present) shall contain all macroblocks corresponding to those of

the primary coded picture.


c) redundant_pic_cnt shall be equal to 0 in all auxiliary coded slices.


The (optional) decoding process for the decoding of auxiliary coded pictures is the same as if the auxiliary coded pictures
were primary coded pictures in a separate coded video stream that differs from the primary coded pictures in the current
coded video stream in the following ways:


- The IDR or non-IDR status of each auxiliary coded picture shall be inferred to be the same as the IDR or non-IDR
status of the primary picture in the same access unit, rather than being inferred from the value of nal_unit_type.


- The value of chroma_format_idc and the value of ChromaArrayType shall be inferred to be equal to 0 for the decoding
of the auxiliary coded pictures.


- The value of bit_depth_luma_minus8 shall be inferred to be equal to bit_depth_aux_minus8 for the decoding of the
auxiliary coded pictures.
NOTE 3 – Alpha blending composition is normally performed with a background picture B, a foreground picture F, and a decoded
auxiliary coded picture A, all of the same size. Assume for purposes of example illustration that the chroma resolution of B and F





have been upsampled to the same resolution as the luma. Denote corresponding samples of B, F and A by b, f and a, respectively.
Denote luma and chroma samples by subscripts Y, Cb and Cr.
Define the variables alphaRange, alphaFwt and alphaBwt as follows:
alphaRange = Abs( alpha_opaque_value − alpha_transparent_value )
alphaFwt = Abs( a − alpha_transparent_value )
alphaBwt = Abs( a − alpha_opaque_value )
Then, in alpha blending composition, samples d of the displayed picture D may be calculated as
dY = ( alphaFwt * fY + alphaBwt * bY + alphaRange / 2 ) / alphaRange
dCb = ( alphaFwt * fCb + alphaBwt * bCb + alphaRange / 2 ) / alphaRange
dCr = ( alphaFwt * fCr + alphaBwt * bCr + alphaRange / 2 ) / alphaRange
The samples of pictures D, F and B could also represent red, green, and blue component values (see clause E.2.1). Here we have
assumed Y, Cb and Cr component values. Each component, e.g., Y, is assumed for purposes of example illustration above to have
the same bit depth in each of the pictures D, F and B. However, different components, e.g., Y and Cb, need not have the same bit
depth in this example.
When aux_format_idc is equal to 1, F would be the decoded picture obtained from the decoded luma and chroma, and A would be
the decoded picture obtained from the decoded auxiliary coded picture. In this case, the indicated example alpha blending
composition involves multiplying the samples of F by factors obtained from the samples of A.
A picture format that is useful for editing or direct viewing, and that is commonly used, is called pre-multiplied-black video. If the
foreground picture was F, then the pre-multiplied-black video S is given by
sY = ( alphaFwt * fY ) / alphaRange
sCb = ( alphaFwt * fCb ) / alphaRange
sCr = ( alphaFwt * fCr ) / alphaRange
Pre-multiplied-black video has the characteristic that the picture S will appear correct if displayed against a black background. For
a non-black background B, the composition of the displayed picture D may be calculated as
dY = sY + ( alphaBwt * bY + alphaRange / 2 ) / alphaRange
dCb = sCb + ( alphaBwt * bCb + alphaRange / 2 ) / alphaRange
dCr = sCr + ( alphaBwt * bCr + alphaRange / 2 ) / alphaRange
When aux_format_idc is equal to 2, S would be the decoded picture obtained from the decoded luma and chroma, and A would
again be the decoded picture obtained from the decoded auxiliary coded picture. In this case, alpha blending composition does not
involve multiplication of the samples of S by factors obtained from the samples of A.


**additional_extension_flag** equal to 0 indicates that no additional data follows within the sequence parameter set extension
syntax structure prior to the RBSP trailing bits. The value of additional_extension_flag shall be equal to 0. The value of 1
for additional_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore all data that follows
the value of 1 for additional_extension_flag in a sequence parameter set extension NAL unit.


**7.4.2.1.3** **Subset sequence parameter set RBSP semantics**


**svc_vui_parameters_present_flag** equal to 0 specifies that the syntax structure svc_vui_parameters_extension( ) is not
present. svc_vui_parameters_present_flag equal to 1 specifies that the syntax structure svc_vui_parameters_extension( )
is present.


**bit_equal_to_one** shall be equal to 1.


**mvc_vui_parameters_present_flag** equal to 0 specifies that the syntax structure mvc_vui_parameters_extension( ) is not
present. mvc_vui_parameters_present_flag equal to 1 specifies that the syntax structure mvc_vui_parameters_extension( )
is present.


**additional_extension2_flag** equal to 0 specifies that no additional_extension2_data_flag syntax elements are present in
the subset sequence parameter set RBSP syntax structure. additional_extension2_flag shall be equal to 0 in bitstreams
conforming to this Recommendation | International Standard. The value of 1 for additional_extension2_flag is reserved for
future use by ITU-T | ISO/IEC. Decoders shall ignore all data that follow the value 1 for additional_extension2_flag in a
subset sequence parameter set NAL unit.


**additional_extension2_data_flag** may have any value. It shall not affect the conformance to profiles specified in
Annex A, G, H, or I.


**7.4.2.2** **Picture parameter set RBSP semantics**


**pic_parameter_set_id** identifies the picture parameter set that is referred to in the slice header. The value of
pic_parameter_set_id shall be in the range of 0 to 255, inclusive.


**seq_parameter_set_id** refers to the active sequence parameter set. The value of seq_parameter_set_id shall be in the range
of 0 to 31, inclusive.





**entropy_coding_mode_flag** selects the entropy decoding method to be applied for the syntax elements for which two
descriptors appear in the syntax tables as follows:


- If entropy_coding_mode_flag is equal to 0, the method specified by the left descriptor in the syntax table is applied
(Exp-Golomb coded, see clause 9.1 or CAVLC, see clause 9.2).


- Otherwise (entropy_coding_mode_flag is equal to 1), the method specified by the right descriptor in the syntax table
is applied (CABAC, see clause 9.3).


**bottom_field_pic_order_in_frame_present_flag** equal to 1 specifies that the syntax elements
delta_pic_order_cnt_bottom (when pic_order_cnt_type is equal to 0) or delta_pic_order_cnt[ 1 ] (when
pic_order_cnt_type is equal to 1), which are related to picture order counts for the bottom field of a coded frame, are
present in the slice headers for coded frames as specified in clause 7.3.3. bottom_field_pic_order_in_frame_present_flag
equal to 0 specifies that the syntax elements delta_pic_order_cnt_bottom and delta_pic_order_cnt[ 1 ] are not present in
the slice headers.


**num_slice_groups_minus1** plus 1 specifies the number of slice groups for a picture. When num_slice_groups_minus1 is
equal to 0, all slices of the picture belong to the same slice group. The allowed range of num_slice_groups_minus1 is
specified in Annex A.


**slice_group_map_type** specifies how the mapping of slice group map units to slice groups is coded. The value of
slice_group_map_type shall be in the range of 0 to 6, inclusive.


slice_group_map_type equal to 0 specifies interleaved slice groups.


slice_group_map_type equal to 1 specifies a dispersed slice group mapping.


slice_group_map_type equal to 2 specifies one or more "foreground" slice groups and a "leftover" slice group.


slice_group_map_type values equal to 3, 4, and 5 specify changing slice groups. When num_slice_groups_minus1 is not
equal to 1, slice_group_map_type shall not be equal to 3, 4, or 5.


slice_group_map_type equal to 6 specifies an explicit assignment of a slice group to each slice group map unit.


Slice group map units are specified as follows:

- If frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 1 and the coded picture is a frame,
the slice group map units are macroblock pair units.

- Otherwise, if frame_mbs_only_flag is equal to 1 or the coded picture is a field, the slice group map units are units of
macroblocks.

- Otherwise (frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 0 and the coded picture
is a frame), the slice group map units are units of two macroblocks that are vertically contiguous as in a frame
macroblock pair of an MBAFF frame.


**run_length_minus1[** i **]** is used to specify the number of consecutive slice group map units to be assigned to the i-th slice
group in raster scan order of slice group map units. The value of run_length_minus1[ i ] shall be in the range of 0 to
PicSizeInMapUnits − 1, inclusive.


**top_left[** i **]** and **bottom_right[** i **]** specify the top-left and bottom-right corners of a rectangle, respectively. top_left[ i ]
and bottom_right[ i ] are slice group map unit positions in a raster scan of the picture for the slice group map units. For
each rectangle i, all of the following constraints shall be obeyed by the values of the syntax elements top_left[ i ] and
bottom_right[ i ]:

- top_left[ i ] shall be less than or equal to bottom_right[ i ] and bottom_right[ i ] shall be less than PicSizeInMapUnits.

- ( top_left[ i ] % PicWidthInMbs ) shall be less than or equal to the value of ( bottom_right[ i ] % PicWidthInMbs ).


**slice_group_change_direction_flag** is used with slice_group_map_type to specify the refined map type when
slice_group_map_type is 3, 4, or 5.


**slice_group_change_rate_minus1** is used to specify the variable SliceGroupChangeRate. SliceGroupChangeRate
specifies the multiple in number of slice group map units by which the size of a slice group can change from one picture
to the next. The value of slice_group_change_rate_minus1 shall be in the range of 0 to PicSizeInMapUnits − 1, inclusive.
The SliceGroupChangeRate variable is specified as follows:


SliceGroupChangeRate = slice_group_change_rate_minus1 + 1 (7-23)


**pic_size_in_map_units_minus1** is used to specify the number of slice group map units in the picture.
pic_size_in_map_units_minus1 shall be equal to PicSizeInMapUnits − 1.





**slice_group_id[** i **]** identifies a slice group of the i-th slice group map unit in raster scan order. The length of the
slice_group_id[ i ] syntax element is Ceil( Log2( num_slice_groups_minus1 + 1 ) ) bits. The value of slice_group_id[ i ]
shall be in the range of 0 to num_slice_groups_minus1, inclusive.


**num_ref_idx_l0_default_active_minus1** specifies how num_ref_idx_l0_active_minus1 is inferred for P, SP, and B slices
with num_ref_idx_active_override_flag equal to 0. The value of num_ref_idx_l0_default_active_minus1 shall be in the
range of 0 to 31, inclusive.


**num_ref_idx_l1_default_active_minus1** specifies how num_ref_idx_l1_active_minus1 is inferred for B slices with
num_ref_idx_active_override_flag equal to 0. The value of num_ref_idx_l1_default_active_minus1 shall be in the range
of 0 to 31, inclusive.


**weighted_pred_flag** equal to 0 specifies that the default weighted prediction shall be applied to P and SP slices.
weighted_pred_flag equal to 1 specifies that explicit weighted prediction shall be applied to P and SP slices.


**weighted_bipred_idc** equal to 0 specifies that the default weighted prediction shall be applied to B slices.
weighted_bipred_idc equal to 1 specifies that explicit weighted prediction shall be applied to B slices. weighted_bipred_idc
equal to 2 specifies that implicit weighted prediction shall be applied to B slices. The value of weighted_bipred_idc shall
be in the range of 0 to 2, inclusive.


**pic_init_qp_minus26** specifies the initial value minus 26 of SliceQPY for each slice. The initial value is modified at the
slice layer when a non-zero value of slice_qp_delta is decoded, and is modified further when a non-zero value of
mb_qp_delta is decoded at the macroblock layer. The value of pic_init_qp_minus26 shall be in the range of
−(26 + QpBdOffsetY ) to +25, inclusive.


**pic_init_qs_minus26** specifies the initial value minus 26 of SliceQSY for all macroblocks in SP or SI slices. The initial
value is modified at the slice layer when a non-zero value of slice_qs_delta is decoded. The value of pic_init_qs_minus26
shall be in the range of −26 to +25, inclusive.


**chroma_qp_index_offset** specifies the offset that shall be added to QPY and QSY for addressing the table of QPC values
for the Cb chroma component. The value of chroma_qp_index_offset shall be in the range of −12 to +12, inclusive.


**deblocking_filter_control_present_flag** equal to 1 specifies that a set of syntax elements controlling the characteristics
of the deblocking filter is present in the slice header. deblocking_filter_control_present_flag equal to 0 specifies that the
set of syntax elements controlling the characteristics of the deblocking filter is not present in the slice headers and their
inferred values are in effect.


**constrained_intra_pred_flag** equal to 0 specifies that intra prediction allows usage of residual data and decoded samples
of neighbouring macroblocks coded using Inter macroblock prediction modes for the prediction of macroblocks coded
using Intra macroblock prediction modes. constrained_intra_pred_flag equal to 1 specifies constrained intra prediction, in
which case prediction of macroblocks coded using Intra macroblock prediction modes only uses residual data and decoded
samples from I or SI macroblock types.


**redundant_pic_cnt_present_flag** equal to 0 specifies that the redundant_pic_cnt syntax element is not present in slice
headers, coded slice data partition B NAL units, and coded slice data partition C NAL units that refer (either directly or by
association with a corresponding coded slice data partition A NAL unit) to the picture parameter set.
redundant_pic_cnt_present_flag equal to 1 specifies that the redundant_pic_cnt syntax element is present in all slice
headers, coded slice data partition B NAL units, and coded slice data partition C NAL units that refer (either directly or by
association with a corresponding coded slice data partition A NAL unit) to the picture parameter set.


**transform_8x8_mode_flag** equal to 1 specifies that the 8x8 transform decoding process may be in use (see clause 8.5).
transform_8x8_mode_flag equal to 0 specifies that the 8x8 transform decoding process is not in use. When
transform_8x8_mode_flag is not present, it shall be inferred to be 0.


**pic_scaling_matrix_present_flag** equal to 1 specifies that parameters are present to modify the scaling lists specified in
the sequence parameter set. pic_scaling_matrix_present_flag equal to 0 specifies that the scaling lists used for the picture
shall be inferred to be equal to those specified by the sequence parameter set. When pic_scaling_matrix_present_flag is
not present, it shall be inferred to be equal to 0.


**pic_scaling_list_present_flag[** i **]** equal to 1 specifies that the scaling list syntax structure is present to specify the scaling
list for index i. pic_scaling_list_present_flag[ i ] equal to 0 specifies that the syntax structure for scaling list i is not present
in the picture parameter set and that depending on the value of seq_scaling_matrix_present_flag, the following applies:


- If seq_scaling_matrix_present_flag is equal to 0, the scaling list fall-back rule set A as specified in Table 7-2 shall be
used to derive the picture-level scaling list for index i.


- Otherwise (seq_scaling_matrix_present_flag is equal to 1), the scaling list fall-back rule set B as specified
in Table 7-2 shall be used to derive the picture-level scaling list for index i.





**second_chroma_qp_index_offset** specifies the offset that shall be added to QPY and QSY for addressing the table of QPC
values for the Cr chroma component. The value of second_chroma_qp_index_offset shall be in the range of −12 to +12,
inclusive.


When second_chroma_qp_index_offset is not present, it shall be inferred to be equal to chroma_qp_index_offset.

NOTE – When ChromaArrayType is equal to 0, the values of bit_depth_chroma_minus8, chroma_qp_index_offset and
second_chroma_qp_index_offset are not used in the decoding process. In particular, when separate_colour_plane_flag is equal to 1,
each colour plane is decoded as a distinct monochrome picture using the luma component decoding process (except for the selection
of scaling matrices), including the application of the luma quantization parameter derivation process without application of an offset
for the decoding of the pictures having colour_plane_id not equal to 0.


**7.4.2.3** **Supplemental enhancement information RBSP semantics**


Supplemental Enhancement Information (SEI) contains information that is not necessary to decode the samples of coded
pictures from VCL NAL units.


**7.4.2.3.1** **Supplemental enhancement information message semantics**


An SEI RBSP contains one or more SEI messages. Each SEI message consists of the variables specifying the type
payloadType and size payloadSize of the SEI payload. SEI payloads are specified in Annex D. The derived SEI payload
size payloadSize is specified in bytes and shall be equal to the number of RBSP bytes in the SEI payload.

NOTE – The NAL unit byte sequence containing the SEI message might include one or more emulation prevention bytes
(represented by emulation_prevention_three_byte syntax elements). Since the payload size of an SEI message is specified in RBSP
bytes, the quantity of emulation prevention bytes is not included in the size payloadSize of an SEI payload.


**ff_byte** is a byte equal to 0xFF identifying a need for a longer representation of the syntax structure that it is used within.


**last_payload_type_byte** is the last byte of the payload type of an SEI message.


**last_payload_size_byte** is the last byte of the payload size of an SEI message.


**7.4.2.4** **Access unit delimiter RBSP semantics**


The access unit delimiter may be used to indicate the type of slices present in a primary coded picture and to simplify the
detection of the boundary between access units. There is no normative decoding process associated with the access unit
delimiter.


**primary_pic_type** indicates that the slice_type values for all slices of the primary coded picture are members of the set
listed in Table 7-5 for the given value of primary_pic_type.

NOTE – The value of primary_pic_type applies to the slice_type values in all slice headers of the primary coded picture, including
the slice_type syntax elements in all NAL units with nal_unit_type equal to 1, 2, or 5.


**Table 7-5 – Meaning of primary_pic_type**

|primary_pic_type|slice_type values that may be present in the primary coded picture|
|---|---|
|0|2, 7|
|1|0, 2, 5, 7|
|2|0, 1, 2, 5, 6, 7|
|3|4, 9|
|4|3, 4, 8, 9|
|5|2, 4, 7, 9|
|6|0, 2, 3, 4, 5, 7, 8, 9|
|7|0, 1, 2, 3, 4, 5, 6, 7, 8, 9|



**7.4.2.5** **End of sequence RBSP semantics**


The end of sequence RBSP specifies that the next subsequent access unit in the bitstream in decoding order (if any) shall
be an IDR access unit. The syntax content of the SODB and RBSP for the end of sequence RBSP are empty. No normative
decoding process is specified for an end of sequence RBSP.


**7.4.2.6** **End of stream RBSP semantics**


The end of stream RBSP indicates that no additional NAL units shall be present in the bitstream that are subsequent to the
end of stream RBSP in decoding order. The syntax content of the SODB and RBSP for the end of stream RBSP are empty.
No normative decoding process is specified for an end of stream RBSP.





NOTE – When an end of stream NAL unit is present, the bitstream is considered to end (for purposes of the scope of this
Recommendation | International Standard). In some system environments, another bitstream may follow after the bitstream that has
ended, either immediately or at some time thereafter, possibly within the same communication channel. Under such circumstances,
the scope of this Recommendation | International Standard applies only to the processing of each of these individual bitstreams. No
requirements are specified herein regarding the transition between such bitstreams (e.g., in regard to timing, buffering operation,
etc.).


**7.4.2.7** **Filler data RBSP semantics**


The filler data RBSP contains zero or more bytes. No normative decoding process is specified for a filler data RBSP.


**ff_byte** is a byte. It is a requirement of bitstream conformance that the value of ff_byte shall be equal to 0xFF.


**7.4.2.8** **Slice layer without partitioning RBSP semantics**


The slice layer without partitioning RBSP consists of a slice header and slice data.


**7.4.2.9** **Slice data partition RBSP semantics**


**7.4.2.9.1** **Slice data partition A RBSP semantics**


When slice data partitioning is in use, the coded data for a single slice is divided into three separate partitions. Slice data
partition A contains all syntax elements of category 2.


Category 2 syntax elements include all syntax elements in the slice header and slice data syntax structures other than the
syntax elements in the residual( ) syntax structure.


**slice_id** identifies the slice associated with the slice data partition. The value of slice_id is constrained as follows:


- If separate_colour_plane_flag is equal to 0, the following applies:


   - If arbitrary slice order is not allowed as specified in Annex A, the first slice of a coded picture, in decoding order,
shall have slice_id equal to 0 and the value of slice_id shall be incremented by one for each subsequent slice of
the coded picture in decoding order.


   - Otherwise (arbitrary slice order is allowed), each slice shall have a unique slice_id value within the set of slices
of the coded picture.


- Otherwise (separate_colour_plane_flag is equal to 1), the following applies:


   - If arbitrary slice order is not allowed as specified in Annex A, the first slice of a coded picture having each value
of colour_plane_id, in decoding order, shall have slice_id equal to 0 and the value of slice_id shall be
incremented by one for each subsequent slice of the coded picture having the same value of colour_plane_id, in
decoding order.


   - Otherwise (arbitrary slice order is allowed) each slice shall have a unique slice_id value within each set of slices
of the coded picture that have the same value of colour_plane_id.


The range of slice_id is specified as follows:


- If MbaffFrameFlag is equal to 0, slice_id shall be in the range of 0 to PicSizeInMbs − 1, inclusive.


- Otherwise (MbaffFrameFlag is equal to 1), slice_id shall be in the range of 0 to PicSizeInMbs / 2 − 1, inclusive.


**7.4.2.9.2** **Slice data partition B RBSP semantics**


When slice data partitioning is in use, the coded data for a single slice is divided into one to three separate partitions. Slice
data partition B contains all syntax elements of category 3.


Category 3 syntax elements include all syntax elements in the residual( ) syntax structure and in syntax structures used
within that syntax structure for collective macroblock types I and SI as specified in Table 7-10.


**slice_id** has the same semantics as specified in clause 7.4.2.9.1.


**colour_plane_id** specifies the colour plane associated with the current slice RBSP when separate_colour_plane_flag is
equal to 1. The value of colour_plane_id shall be in the range of 0 to 2, inclusive. colour_plane_id equal to 0, 1, and 2
correspond to the Y, Cb, and Cr planes, respectively.

NOTE – There is no dependency between the decoding processes of pictures having different values of colour_plane_id.


**redundant_pic_cnt** shall be equal to 0 for coded slices and coded slice data partitions belonging to the primary coded
picture. The redundant_pic_cnt shall be greater than 0 for coded slices and coded slice data partitions in redundant coded
pictures. When redundant_pic_cnt is not present, its value shall be inferred to be equal to 0. The value of redundant_pic_cnt
shall be in the range of 0 to 127, inclusive.





The presence of a slice data partition B RBSP is specified as follows:


- If the syntax elements of a slice data partition A RBSP indicate the presence of any syntax elements of category 3 in
the slice data for a slice, a slice data partition B RBSP shall be present having the same value of slice_id and
redundant_pic_cnt as in the slice data partition A RBSP.


- Otherwise (the syntax elements of a slice data partition A RBSP do not indicate the presence of any syntax elements
of category 3 in the slice data for a slice), no slice data partition B RBSP shall be present having the same value of
slice_id and redundant_pic_cnt as in the slice data partition A RBSP.


**7.4.2.9.3** **Slice data partition C RBSP semantics**


When slice data partitioning is in use, the coded data for a single slice is divided into three separate partitions. Slice data
partition C contains all syntax elements of category 4.


Category 4 syntax elements include all syntax elements in the residual( ) syntax structure and in syntax structures used
within that syntax structure for collective macroblock types P and B as specified in Table 7-10.


**slice_id** has the same semantics as specified in clause 7.4.2.9.1.


**colour_plane_id** has the same semantics as specified in clause 7.4.2.9.2.


**redundant_pic_cnt** has the same semantics as specified in clause 7.4.2.9.2.


The presence of a slice data partition C RBSP is specified as follows:


- If the syntax elements of a slice data partition A RBSP indicate the presence of any syntax elements of category 4 in
the slice data for a slice, a slice data partition C RBSP shall be present having the same value of slice_id and
redundant_pic_cnt as in the slice data partition A RBSP.


- Otherwise (the syntax elements of a slice data partition A RBSP do not indicate the presence of any syntax elements
of category 4 in the slice data for a slice), no slice data partition C RBSP shall be present having the same value of
slice_id and redundant_pic_cnt as in the slice data partition A RBSP.


**7.4.2.10** **RBSP slice trailing bits semantics**


**cabac_zero_word** is a byte-aligned sequence of two bytes equal to 0x0000.


Let NumBytesInVclNALunits be the sum of the values of NumBytesInNALunit for all VCL NAL units of a coded picture.


Let BinCountsInNALunits be the number of times that the parsing process function DecodeBin( ), specified in
clause 9.3.3.2, is invoked to decode the contents of all VCL NAL units of a coded picture. When
entropy_coding_mode_flag is equal to 1, it is a requirement of bitstream conformance that BinCountsInNALunits shall
not exceed ( 32 ÷ 3 ) * NumBytesInVclNALunits + ( RawMbBits * PicSizeInMbs ) ÷ 32.

NOTE – The constraint on the maximum number of bins resulting from decoding the contents of the slice layer NAL units can be
met by inserting a number of cabac_zero_word syntax elements to increase the value of NumBytesInVclNALunits. Each
cabac_zero_word is represented in a NAL unit by the three-byte sequence 0x000003 (as a result of the constraints on NAL unit
contents that result in requiring inclusion of an emulation_prevention_three_byte for each cabac_zero_word).


**7.4.2.11** **RBSP trailing bits semantics**


**rbsp_stop_one_bit** shall be equal to 1.


**rbsp_alignment_zero_bit** shall be equal to 0.


**7.4.2.12** **Prefix NAL unit RBSP semantics**


The content of the prefix NAL unit RBSP is dependent on the value of svc_extension_flag.


**7.4.2.13** **Slice layer extension RBSP semantics**


The content of the slice layer extension RBSP is dependent on the value of svc_extension_flag.


Coded slice extension NAL units with svc_extension_flag equal to 1 are also referred to as coded slice in scalable extension
NAL units and coded slice extension NAL units with svc_extension_flag equal to 0 are also referred to as coded slice
MVC extension NAL units.


**7.4.3** **Slice header semantics**


When present, the value of the slice header syntax elements pic_parameter_set_id, frame_num, field_pic_flag,
bottom_field_flag, idr_pic_id, pic_order_cnt_lsb, delta_pic_order_cnt_bottom, delta_pic_order_cnt[ 0 ],
delta_pic_order_cnt[ 1 ], sp_for_switch_flag, and slice_group_change_cycle shall be the same in all slice headers of a
coded picture.





**first_mb_in_slice** specifies the address of the first macroblock in the slice. When arbitrary slice order is not allowed as
specified in Annex A, the value of first_mb_in_slice is constrained as follows:


- If separate_colour_plane_flag is equal to 0, the value of first_mb_in_slice shall not be less than the value of
first_mb_in_slice for any other slice of the current picture that precedes the current slice in decoding order.


- Otherwise (separate_colour_plane_flag is equal to 1), the value of first_mb_in_slice shall not be less than the value
of first_mb_in_slice for any other slice of the current picture that precedes the current slice in decoding order and has
the same value of colour_plane_id.


The first macroblock address of the slice is derived as follows:


- If MbaffFrameFlag is equal to 0, first_mb_in_slice is the macroblock address of the first macroblock in the slice, and
first_mb_in_slice shall be in the range of 0 to PicSizeInMbs − 1, inclusive.


- Otherwise (MbaffFrameFlag is equal to 1), first_mb_in_slice * 2 is the macroblock address of the first macroblock in
the slice, which is the top macroblock of the first macroblock pair in the slice, and first_mb_in_slice shall be in the
range of 0 to PicSizeInMbs / 2 − 1, inclusive.


**slice_type** specifies the coding type of the slice according to Table **7-6** .


**Table 7-6 – Name association to slice_type**

|slice_type|Name of slice_type|
|---|---|
|0|P (P slice)|
|1|B (B slice)|
|2|I (I slice)|
|3|SP (SP slice)|
|4|SI (SI slice)|
|5|P (P slice)|
|6|B (B slice)|
|7|I (I slice)|
|8|SP (SP slice)|
|9|SI (SI slice)|



When slice_type has a value in the range 5..9, it is a requirement of bitstream conformance that all other slices of the
current coded picture shall have a value of slice_type equal to the current value of slice_type or equal to the current value
of slice_type minus 5.

NOTE 1 – Values of slice_type in the range 5..9 can be used by an encoder to indicate that all slices of a picture have the same value
of (slice_type % 5). Values of slice_type in the range 5..9 are otherwise equivalent to corresponding values in the range 0..4.


When nal_unit_type is equal to 5 (IDR picture), slice_type shall be equal to 2, 4, 7, or 9.


When max_num_ref_frames is equal to 0, slice_type shall be equal to 2, 4, 7, or 9.


**pic_parameter_set_id** specifies the picture parameter set in use. The value of pic_parameter_set_id shall be in the range
of 0 to 255, inclusive.


**colour_plane_id** specifies the colour plane associated with the current slice RBSP when separate_colour_plane_flag is
equal to 1. The value of colour_plane_id shall be in the range of 0 to 2, inclusive. colour_plane_id equal to 0, 1, and 2
correspond to the Y, Cb, and Cr planes, respectively.

NOTE 2 – There is no dependency between the decoding processes of pictures having different values of colour_plane_id.


**frame_num** is used as an identifier for pictures and shall be represented by log2_max_frame_num_minus4 + 4 bits in the
bitstream. frame_num is constrained as follows:


The variable PrevRefFrameNum is derived as follows:


- If the current picture is an IDR picture, PrevRefFrameNum is set equal to 0.


- Otherwise (the current picture is not an IDR picture), PrevRefFrameNum is set as follows:


   - If the decoding process for gaps in frame_num specified in clause 8.2.5.2 was invoked by the decoding process
for an access unit that contained a non-reference picture that followed the previous access unit in decoding order
that contained a reference picture, PrevRefFrameNum is set equal to the value of frame_num for the last of the





"non-existing" reference frames inferred by the decoding process for gaps in frame_num specified in
clause 8.2.5.2.


   - Otherwise, PrevRefFrameNum is set equal to the value of frame_num for the previous access unit in decoding
order that contained a reference picture.


The value of frame_num is constrained as follows:


- If the current picture is an IDR picture, frame_num shall be equal to 0.


- Otherwise (the current picture is not an IDR picture), referring to the primary coded picture in the previous access
unit in decoding order that contains a reference picture as the preceding reference picture, the value of frame_num
for the current picture shall not be equal to PrevRefFrameNum unless all of the following three conditions are true:


a) The current picture and the preceding reference picture belong to consecutive access units in decoding order.


b) The current picture and the preceding reference picture are reference fields having opposite parity.


c) One or more of the following conditions is true:

      - The preceding reference picture is an IDR picture,

      - The preceding reference picture includes a memory_management_control_operation syntax element equal
to 5,

NOTE 3 – When the preceding reference picture includes a memory_management_control_operation syntax
element equal to 5, PrevRefFrameNum is equal to 0.

      - There is a primary coded picture that precedes the preceding reference picture and the primary coded picture
that precedes the preceding reference picture does not have frame_num equal to PrevRefFrameNum,

      - There is a primary coded picture that precedes the preceding reference picture and the primary coded picture
that precedes the preceding reference picture is not a reference picture.


When the value of frame_num is not equal to PrevRefFrameNum, it is a requirement of bitstream conformance that the
following constraints shall be obeyed:


a) There shall not be any previous field or frame in decoding order that is currently marked as "used for short-term

reference" that has a value of frame_num equal to any value taken on by the variable
UnusedShortTermFrameNum in the following:


UnusedShortTermFrameNum = ( PrevRefFrameNum + 1 ) % MaxFrameNum
while( UnusedShortTermFrameNum != frame_num ) (7-24)
UnusedShortTermFrameNum = ( UnusedShortTermFrameNum + 1 ) % MaxFrameNum


b) The value of frame_num is constrained as follows:

     - If gaps_in_frame_num_value_allowed_flag is equal to 0, the value of frame_num for the current picture
shall be equal to ( PrevRefFrameNum + 1 ) % MaxFrameNum.

     - Otherwise (gaps_in_frame_num_value_allowed_flag is equal to 1), the following applies:

        - If frame_num is greater than PrevRefFrameNum, there shall not be any non-reference pictures in the
bitstream that follow the previous reference picture and precede the current picture in decoding order
in which either of the following conditions is true:

           - The value of frame_num for the non-reference picture is less than PrevRefFrameNum,

           - The value of frame_num for the non-reference picture is greater than the value of frame_num for
the current picture.

        - Otherwise (frame_num is less than PrevRefFrameNum), there shall not be any non-reference pictures
in the bitstream that follow the previous reference picture and precede the current picture in decoding
order in which both of the following conditions are true:

           - The value of frame_num for the non-reference picture is less than PrevRefFrameNum,

           - The value of frame_num for the non-reference picture is greater than the value of frame_num for
the current picture.


A picture including a memory_management_control_operation equal to 5 shall have frame_num constraints as described
above and, after the decoding of the current picture and the processing of the memory management control operations, the
picture shall be inferred to have had frame_num equal to 0 for all subsequent use in the decoding process, except as
specified in clause 7.4.1.2.4.

NOTE 4 – When the primary coded picture is not an IDR picture and does not contain memory_management_control_operation
syntax element equal to 5, the value of frame_num of a corresponding redundant coded picture is the same as the value of frame_num





in the primary coded picture. Alternatively, the redundant coded picture includes a memory_management_control_operation syntax
element equal to 5 and the corresponding primary coded picture is an IDR picture.


**field_pic_flag** equal to 1 specifies that the slice is a slice of a coded field. field_pic_flag equal to 0 specifies that the slice
is a slice of a coded frame. When field_pic_flag is not present it shall be inferred to be equal to 0.


The variable MbaffFrameFlag is derived as


MbaffFrameFlag = ( mb_adaptive_frame_field_flag && !field_pic_flag ) (7-25)


The variable for the picture height in units of macroblocks is derived as


PicHeightInMbs = FrameHeightInMbs / ( 1 + field_pic_flag ) (7-26)


The variable for picture height for the luma component is derived as


PicHeightInSamplesL = PicHeightInMbs * 16 (7-27)


The variable for picture height for the chroma component is derived as


PicHeightInSamplesC = PicHeightInMbs * MbHeightC (7-28)


The variable PicSizeInMbs for the current picture is derived as


PicSizeInMbs = PicWidthInMbs * PicHeightInMbs (7-29)


The variable MaxPicNum is derived as follows:


- If field_pic_flag is equal to 0, MaxPicNum is set equal to MaxFrameNum.


- Otherwise (field_pic_flag is equal to 1), MaxPicNum is set equal to 2*MaxFrameNum.


The variable CurrPicNum is derived as follows:


- If field_pic_flag is equal to 0, CurrPicNum is set equal to frame_num.


- Otherwise (field_pic_flag is equal to 1), CurrPicNum is set equal to 2 * frame_num + 1.


**bottom_field_flag** equal to 1 specifies that the slice is part of a coded bottom field. bottom_field_flag equal to 0 specifies
that the picture is a coded top field. When this syntax element is not present for the current slice, it shall be inferred to be
equal to 0.


**idr_pic_id** identifies an IDR picture. The values of idr_pic_id in all the slices of an IDR picture shall remain unchanged.
When two consecutive access units in decoding order are both IDR access units, the value of idr_pic_id in the slices of the
first such IDR access unit shall differ from the idr_pic_id in the second such IDR access unit. The value of idr_pic_id shall
be in the range of 0 to 65535, inclusive.

NOTE 5 – It is not prohibited for multiple IDR pictures in a bitstream to have the same value of idr_pic_id unless such pictures
occur in two consecutive access units in decoding order.


**pic_order_cnt_lsb** specifies the picture order count modulo MaxPicOrderCntLsb for the top field of a coded frame or for
a coded field. The length of the pic_order_cnt_lsb syntax element is log2_max_pic_order_cnt_lsb_minus4 + 4 bits. The
value of the pic_order_cnt_lsb shall be in the range of 0 to MaxPicOrderCntLsb − 1, inclusive.


**delta_pic_order_cnt_bottom** specifies the picture order count difference between the bottom field and the top field of a
coded frame as follows:


- If the current picture includes a memory_management_control_operation equal to 5, the value of
delta_pic_order_cnt_bottom shall be in the range of ( 1 − MaxPicOrderCntLsb ) to 2 [31]   - 1, inclusive.


- Otherwise (the current picture does not include a memory_management_control_operation equal to 5), the value of
delta_pic_order_cnt_bottom shall be in the range of −2 [31] + 1 to 2 [31]   - 1, inclusive.


When this syntax element is not present in the bitstream for the current slice, it shall be inferred to be equal to 0.


**delta_pic_order_cnt[** 0 **]** specifies the picture order count difference from the expected picture order count for the top
field of a coded frame or for a coded field as specified in clause 8.2.1. The value of delta_pic_order_cnt[ 0 ] shall be in the
range of −2 [31] + 1 to 2 [31] - 1, inclusive. When this syntax element is not present in the bitstream for the current slice, it shall
be inferred to be equal to 0.





**delta_pic_order_cnt[** 1 **]** specifies the picture order count difference from the expected picture order count for the bottom
field of a coded frame specified in clause 8.2.1. The value of delta_pic_order_cnt[ 1 ] shall be in the range of −2 [31] + 1
to 2 [31] - 1, inclusive. When this syntax element is not present in the bitstream for the current slice, it shall be inferred to be
equal to 0.


**redundant_pic_cnt** shall be equal to 0 for slices and slice data partitions belonging to the primary coded picture. The
value of redundant_pic_cnt shall be greater than 0 for coded slices or coded slice data partitions of a redundant coded
picture. When redundant_pic_cnt is not present in the bitstream, its value shall be inferred to be equal to 0. The value of
redundant_pic_cnt shall be in the range of 0 to 127, inclusive.

NOTE 6 – Any area of the decoded primary picture and the corresponding area that would result from application of the decoding
process specified in clause 8 for any redundant picture in the same access unit should be visually similar in appearance.


The value of pic_parameter_set_id in a coded slice or coded slice data partition of a redundant coded picture shall be such
that the value of bottom_field_pic_order_in_frame_present_flag in the picture parameter set in use in a redundant coded
picture is equal to the value of bottom_field_pic_order_in_frame_present_flag in the picture parameter set in use in the
corresponding primary coded picture.


When present in the primary coded picture and any redundant coded picture, the following syntax elements shall have the
same value: field_pic_flag, bottom_field_flag, and idr_pic_id.


When the value of nal_ref_idc in one VCL NAL unit of an access unit is equal to 0, the value of nal_ref_idc in all other
VCL NAL units of the same access unit shall be equal to 0.

NOTE 7 – The above constraint also has the following implications. If the value of nal_ref_idc for the VCL NAL units of the primary
coded picture is equal to 0, the value of nal_ref_idc for the VCL NAL units of any corresponding redundant coded picture are equal
to 0; otherwise (the value of nal_ref_idc for the VCL NAL units of the primary coded picture is greater than 0), the value of
nal_ref_idc for the VCL NAL units of any corresponding redundant coded picture are also greater than 0.


The marking status of reference pictures and the value of frame_num after the decoded reference picture marking process
as specified in clause 8.2.5 is invoked for the primary coded picture or any redundant coded picture of the same access unit
shall be identical regardless whether the primary coded picture or any redundant coded picture (instead of the primary
coded picture) of the access unit would be decoded.

NOTE 8 – The above constraint also has the following implications.
When the primary coded picture is an IDR picture and a redundant coded picture corresponding to the primary coded picture is an
IDR picture, the contents of the dec_ref_pic_marking( ) syntax structure must be identical in all slice headers of the primary coded
picture and the redundant coded picture corresponding to the primary coded picture.
When the primary coded picture is an IDR picture and a redundant coded picture corresponding to the primary coded picture is not
an IDR picture, all slice headers of the redundant picture must contain a dec_ref_pic_marking syntax( ) structure including a
memory_management_control_operation syntax element equal to 5, and the following applies:

  - If the value of long_term_reference_flag in the primary coded picture is equal to 0, the dec_ref_pic_marking syntax structure
of the redundant coded picture must not include a memory_management_control_operation syntax element equal to 6.

  - Otherwise (the value of long_term_reference_flag in the primary coded picture is equal to 1), the dec_ref_pic_marking syntax
structure of the redundant coded picture must include memory_management_control_operation syntax elements equal to 5, 4,
and 6 in decoding order, and the value of max_long_term_frame_idx_plus1 must be equal to 1, and the value of
long_term_frame_idx must be equal to 0.


The values of TopFieldOrderCnt and BottomFieldOrderCnt (if applicable) that result after completion of the decoding
process for any redundant coded picture or the primary coded picture of the same access unit shall be identical regardless
whether the primary coded picture or any redundant coded picture (instead of the primary coded picture) of the access unit
would be decoded.


There is no required decoding process for a coded slice or coded slice data partition of a redundant coded picture. When
the redundant_pic_cnt in the slice header of a coded slice is greater than 0, the decoder may discard the coded slice.
However, a coded slice or coded slice data partition of any redundant coded picture shall obey the same constraints as a
coded slice or coded slice data partition of a primary picture.

NOTE 9 – When some of the samples in the decoded primary picture cannot be correctly decoded due to errors or losses in
transmission of the sequence and one or more coded slices of a redundant coded picture can be correctly decoded, the decoder should
replace the samples of the decoded primary picture with the corresponding samples of the decoded slice or decoded slices of the
redundant coded picture. When slices of more than one redundant coded picture cover the relevant region of the primary coded
picture, the slice or slices of the redundant coded picture having the lowest value of redundant_pic_cnt should be used.


Slices and slice data partitions having the same value of redundant_pic_cnt belong to the same coded picture. If the value
of redundant_pic_cnt is equal to 0, they belong to the primary coded picture; otherwise (the value of redundant_pic_cnt is
greater than 0), they belong to the same redundant coded picture. Decoded slices within the same redundant coded picture
need not cover the entire picture area and shall not overlap.


**direct_spatial_mv_pred_flag** specifies the method used in the decoding process to derive motion vectors and reference
indices for inter prediction as follows:





- If direct_spatial_mv_pred_flag is equal to 1, the derivation process for luma motion vectors for B_Skip,
B_Direct_16x16, and B_Direct_8x8 in clause 8.4.1.2 shall use spatial direct mode prediction as specified in
clause 8.4.1.2.2.


- Otherwise (direct_spatial_mv_pred_flag is equal to 0), the derivation process for luma motion vectors for B_Skip,
B_Direct_16x16, and B_Direct_8x8 in clause 8.4.1.2 shall use temporal direct mode prediction as specified in
clause 8.4.1.2.3.


**num_ref_idx_active_override_flag** equal to 1 specifies that the syntax element num_ref_idx_l0_active_minus1 is present
for P, SP, and B slices and that the syntax element num_ref_idx_l1_active_minus1 is present for B slices.
num_ref_idx_active_override_flag equal to 0 specifies that the syntax elements num_ref_idx_l0_active_minus1 and
num_ref_idx_l1_active_minus1 are not present.


When the current slice is a P, SP, or B slice and field_pic_flag is equal to 0 and the value of
num_ref_idx_l0_default_active_minus1 in the picture parameter set exceeds 15, num_ref_idx_active_override_flag shall
be equal to 1.


When the current slice is a B slice and field_pic_flag is equal to 0 and the value of num_ref_idx_l1_default_active_minus1
in the picture parameter set exceeds 15, num_ref_idx_active_override_flag shall be equal to 1.


**num_ref_idx_l0_active_minus1** specifies the maximum reference index for reference picture list 0 that shall be used to
decode the slice.


When the current slice is a P, SP, or B slice and num_ref_idx_l0_active_minus1 is not present,
num_ref_idx_l0_active_minus1 shall be inferred to be equal to num_ref_idx_l0_default_active_minus1.


The range of num_ref_idx_l0_active_minus1 is specified as follows:


- If field_pic_flag is equal to 0, num_ref_idx_l0_active_minus1 shall be in the range of 0 to 15, inclusive. When
MbaffFrameFlag is equal to 1, num_ref_idx_l0_active_minus1 is the maximum index value for the decoding of frame
macroblocks and 2 * num_ref_idx_l0_active_minus1 + 1 is the maximum index value for the decoding of field
macroblocks.


- Otherwise (field_pic_flag is equal to 1), num_ref_idx_l0_active_minus1 shall be in the range of 0 to 31, inclusive.


**num_ref_idx_l1_active_minus1** specifies the maximum reference index for reference picture list 1 that shall be used to
decode the slice.


When the current slice is a B slice and num_ref_idx_l1_active_minus1 is not present, num_ref_idx_l1_active_minus1 shall
be inferred to be equal to num_ref_idx_l1_default_active_minus1.


The range of num_ref_idx_l1_active_minus1 is constrained as specified in the semantics for
num_ref_idx_l0_active_minus1 with l0 and list 0 replaced by l1 and list 1, respectively.


**cabac_init_idc** specifies the index for determining the initialization table used in the initialization process for context
variables. The value of cabac_init_idc shall be in the range of 0 to 2, inclusive.


**slice_qp_delta** specifies the initial value of QPY to be used for all the macroblocks in the slice until modified by the value
of mb_qp_delta in the macroblock layer. The initial QPY quantization parameter for the slice is computed as


SliceQPY = 26 + pic_init_qp_minus26 + slice_qp_delta (7-30)


The value of slice_qp_delta shall be limited such that SliceQPY is in the range of −QpBdOffsetY to +51, inclusive.


**sp_for_switch_flag** specifies the decoding process to be used to decode P macroblocks in an SP slice as follows:


- If sp_for_switch_flag is equal to 0, the P macroblocks in the SP slice shall be decoded using the SP decoding process
for non-switching pictures as specified in clause 8.6.1.


- Otherwise (sp_for_switch_flag is equal to 1), the P macroblocks in the SP slice shall be decoded using the SP and SI
decoding process for switching pictures as specified in clause 8.6.2.


**slice_qs_delta** specifies the value of QSY for all the macroblocks in SP and SI slices. The QSY quantization parameter for
the slice is computed as


QSY = 26 + pic_init_qs_minus26 + slice_qs_delta (7-31)


The value of slice_qs_delta shall be limited such that QSY is in the range of 0 to 51, inclusive. This value of QSY is used
for the decoding of all macroblocks in SI slices with mb_type equal to SI and all macroblocks in SP slices that are coded
in an Inter macroblock prediction mode.





**disable_deblocking_filter_idc** specifies whether the operation of the deblocking filter shall be disabled across some block
edges of the slice and specifies for which edges the filtering is disabled. When disable_deblocking_filter_idc is not present
in the slice header, the value of disable_deblocking_filter_idc shall be inferred to be equal to 0.


The value of disable_deblocking_filter_idc shall be in the range of 0 to 2, inclusive.


**slice_alpha_c0_offset_div2** specifies the offset used in accessing the α and tC0 deblocking filter tables for filtering
operations controlled by the macroblocks within the slice. From this value, the offset that shall be applied when addressing
these tables shall be computed as


FilterOffsetA = slice_alpha_c0_offset_div2 << 1 (7-32)


The value of slice_alpha_c0_offset_div2 shall be in the range of −6 to +6, inclusive. When slice_alpha_c0_offset_div2 is
not present in the slice header, the value of slice_alpha_c0_offset_div2 shall be inferred to be equal to 0.


**slice_beta_offset_div2** specifies the offset used in accessing the β deblocking filter table for filtering operations controlled
by the macroblocks within the slice. From this value, the offset that is applied when addressing the β table of the deblocking
filter shall be computed as


FilterOffsetB = slice_beta_offset_div2 << 1 (7-33)


The value of slice_beta_offset_div2 shall be in the range of −6 to +6, inclusive. When slice_beta_offset_div2 is not present
in the slice header the value of slice_beta_offset_div2 shall be inferred to be equal to 0.


**slice_group_change_cycle** is used to derive the number of slice group map units in slice group 0 when
slice_group_map_type is equal to 3, 4, or 5, as specified by


MapUnitsInSliceGroup0 = Min( slice_group_change_cycle * SliceGroupChangeRate,
PicSizeInMapUnits ) (7-34)


The value of slice_group_change_cycle is represented in the bitstream by the following number of bits


Ceil( Log2( PicSizeInMapUnits ÷ SliceGroupChangeRate + 1 ) ) (7-35)


The value of slice_group_change_cycle shall be in the range of 0 to Ceil( PicSizeInMapUnits÷SliceGroupChangeRate ),
inclusive.


**7.4.3.1** **Reference picture list modification semantics**


The syntax elements modification_of_pic_nums_idc, abs_diff_pic_num_minus1, and long_term_pic_num specify the
change from the initial reference picture lists to the reference picture lists to be used for decoding the slice.


**ref_pic_list_modification_flag_l0** equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present
for specifying reference picture list 0. ref_pic_list_modification_flag_l0 equal to 0 specifies that this syntax element is not
present.


When ref_pic_list_modification_flag_l0 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal
to 3 following ref_pic_list_modification_flag_l0 shall not exceed num_ref_idx_l0_active_minus1 + 1.


When RefPicList0[ num_ref_idx_l0_active_minus1 ] in the initial reference picture list produced as specified in
clause 8.2.4.2 is equal to "no reference picture", ref_pic_list_modification_flag_l0 shall be equal to 1 and
modification_of_pic_nums_idc shall not be equal to 3 until RefPicList0[ num_ref_idx_l0_active_minus1 ] in the modified
list produced as specified in clause 8.2.4.3 is not equal to "no reference picture".


**ref_pic_list_modification_flag_l1** equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present
for specifying reference picture list 1. ref_pic_list_modification_flag_l1 equal to 0 specifies that this syntax element is not
present.


When ref_pic_list_modification_flag_l1 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal
to 3 following ref_pic_list_modification_flag_l1 shall not exceed num_ref_idx_l1_active_minus1 + 1.


When decoding a slice with slice_type equal to 1 or 6 and RefPicList1[ num_ref_idx_l1_active_minus1 ] in the initial
reference picture list produced as specified in clause 8.2.4.2 is equal to "no reference picture",
ref_pic_list_modification_flag_l1 shall be equal to 1 and modification_of_pic_nums_idc shall not be equal to 3 until
RefPicList1[ num_ref_idx_l1_active_minus1 ] in the modified list produced as specified in clause 8.2.4.3 is not equal to
"no reference picture".





**modification_of_pic_nums_idc** together with abs_diff_pic_num_minus1 or long_term_pic_num specifies which of the
reference pictures are re-mapped. The values of modification_of_pic_nums_idc are specified in Table 7-7. The value of
the first modification_of_pic_nums_idc that follows immediately after ref_pic_list_modification_flag_l0 or
ref_pic_list_modification_flag_l1 shall not be equal to 3.


**Table 7-7 – modification_of_pic_nums_idc operations for modification of reference picture lists**

|modification_of_pic_nums_idc|modification specified|
|---|---|
|0|abs_diff_pic_num_minus1 is present and corresponds to a difference to<br>subtract from a picture number prediction value|
|1|abs_diff_pic_num_minus1 is present and corresponds to a difference to add<br>to a picture number prediction value|
|2|long_term_pic_num is present and specifies the long-term picture number<br>for a reference picture|
|3|End loop for modification of the initial reference picture list|



**abs_diff_pic_num_minus1** plus 1 specifies the absolute difference between the picture number of the picture being moved
to the current index in the list and the picture number prediction value. abs_diff_pic_num_minus1 shall be in the range of
0 to MaxPicNum − 1. The allowed values of abs_diff_pic_num_minus1 are further restricted as specified in
clause 8.2.4.3.1.


**long_term_pic_num** specifies the long-term picture number of the picture being moved to the current index in the list.
When decoding a coded frame, long_term_pic_num shall be equal to a LongTermPicNum assigned to one of the reference
frames or complementary reference field pairs marked as "used for long-term reference". When decoding a coded field,
long_term_pic_num shall be equal to a LongTermPicNum assigned to one of the reference fields marked as "used for longterm reference".


**7.4.3.2** **Prediction weight table semantics**


**luma_log2_weight_denom** is the base 2 logarithm of the denominator for all luma weighting factors. The value of
luma_log2_weight_denom shall be in the range of 0 to 7, inclusive.


**chroma_log2_weight_denom** is the base 2 logarithm of the denominator for all chroma weighting factors. The value of
chroma_log2_weight_denom shall be in the range of 0 to 7, inclusive.


**luma_weight_l0_flag** equal to 1 specifies that weighting factors for the luma component of list 0 prediction are present.
luma_weight_l0_flag equal to 0 specifies that these weighting factors are not present.


**luma_weight_l0[** i **]** is the weighting factor applied to the luma prediction value for list 0 prediction using RefPicList0[ i ].
When luma_weight_l0_flag is equal to 1, the value of luma_weight_l0[ i ] shall be in the range of −128 to 127, inclusive.
When luma_weight_l0_flag is equal to 0, luma_weight_l0[ i ] shall be inferred to be equal to 2 [luma_log2_weight_denom] for
RefPicList0[ i ].


**luma_offset_l0[** i **]** is the additive offset applied to the luma prediction value for list 0 prediction using RefPicList0[ i ].
The value of luma_offset_l0[ i ] shall be in the range of −128 to 127, inclusive. When luma_weight_l0_flag is equal to 0,
luma_offset_l0[ i ] shall be inferred as equal to 0 for RefPicList0[ i ].


**chroma_weight_l0_flag** equal to 1 specifies that weighting factors for the chroma prediction values of list 0 prediction
are present. chroma_weight_l0_flag equal to 0 specifies that these weighting factors are not present.


**chroma_weight_l0[** i **][** j **]** is the weighting factor applied to the chroma prediction values for list 0 prediction using
RefPicList0[ i ] with j equal to 0 for Cb and j equal to 1 for Cr. When chroma_weight_l0_flag is equal to 1, the value of
chroma_weight_l0[ i ][ j ] shall be in the range of −128 to 127, inclusive. When chroma_weight_l0_flag is equal to 0 **,**
chroma_weight_l0[ i ][ j ] shall be inferred to be equal to 2 [chroma_log2_weight_denom] for RefPicList0[ i ].


**chroma_offset_l0[** i **][** j **]** is the additive offset applied to the chroma prediction values for list 0 prediction using
RefPicList0[ i ] with j equal to 0 for Cb and j equal to 1 for Cr. The value of chroma_offset_l0[ i ][ j ] shall be in the range
of −128 to 127, inclusive. When chroma_weight_l0_flag is equal to 0 **,** chroma_offset_l0[ i ][ j ] shall be inferred to be
equal to 0 for RefPicList0[ i ].


**luma_weight_l1_flag,** **luma_weight_l1**, **luma_offset_l1**, **chroma_weight_l1_flag**, **chroma_weight_l1**,
**chroma_offset_l1** have the same semantics as luma_weight_l0_flag, luma_weight_l0, luma_offset_l0,
chroma_weight_l0_flag, chroma_weight_l0, chroma_offset_l0, respectively, with l0, list 0, and List0 replaced by l1, list 1,
and List1, respectively.





**7.4.3.3** **Decoded reference picture marking semantics**


The syntax elements no_output_of_prior_pics_flag, long_term_reference_flag, adaptive_ref_pic_marking_mode_flag,
memory_management_control_operation, difference_of_pic_nums_minus1, long_term_frame_idx, long_term_pic_num,
and max_long_term_frame_idx_plus1 specify marking of the reference pictures.


The marking of a reference picture can be "unused for reference", "used for short-term reference", or "used for long-term
reference", but only one among these three. When a reference picture is referred to as being marked as "used for reference",
this collectively refers to the picture being marked as "used for short-term reference" or "used for long-term reference"
(but not both). A reference picture that is marked as "used for short-term reference" is referred to as a short-term reference
picture. A reference picture that is marked as "used for long-term reference" is referred to as a long-term reference picture _._


The content of the decoded reference picture marking syntax structure shall be the same in all slice headers of the primary
coded picture. When one or more redundant coded pictures are present, the content of the decoded reference picture
marking syntax structure shall be the same in all slice headers of a redundant coded picture with a particular value of
redundant_pic_cnt.

NOTE 1 – It is not required that the content of the decoded reference picture marking syntax structure in a redundant coded picture
with a particular value of redundant_pic_cnt is identical to the content of the decoded reference picture marking syntax structure in
the corresponding primary coded picture or a redundant coded picture with a different value of redundant_pic_cnt. However, as
specified in clause 7.4.3, the content of the decoded reference picture marking syntax structure in a redundant coded picture is
constrained in the way that the marking status of reference pictures and the value of frame_num after the decoded reference picture
marking process in clause 8.2.5 must be identical regardless whether the primary coded picture or any redundant coded picture of
the access unit would be decoded.


The syntax category of the decoded reference picture marking syntax structure shall be inferred as follows:


- If the decoded reference picture marking syntax structure is in a slice header, the syntax category of the decoded
reference picture marking syntax structure is inferred to be equal to 2.


- Otherwise (the decoded reference picture marking syntax structure is in a decoded reference picture marking repetition
SEI message as specified in Annex D), the syntax category of the decoded reference picture marking syntax structure
is inferred to be equal to 5.


**no_output_of_prior_pics_flag** specifies how the previously-decoded pictures in the decoded picture buffer are treated
after decoding of an IDR picture. See Annex C. When the IDR picture is the first IDR picture in the bitstream, the value
of no_output_of_prior_pics_flag has no effect on the decoding process. When the IDR picture is not the first IDR picture
in the bitstream and the value of PicWidthInMbs, FrameHeightInMbs, or max_dec_frame_buffering derived from the
active sequence parameter set is different from the value of PicWidthInMbs, FrameHeightInMbs, or
max_dec_frame_buffering derived from the sequence parameter set active for the preceding picture,
no_output_of_prior_pics_flag equal to 1 may (but should not) be inferred by the decoder, regardless of the actual value of
no_output_of_prior_pics_flag.


**long_term_reference_flag** equal to 0 specifies that the MaxLongTermFrameIdx variable is set equal to "no long-term
frame indices" and that the IDR picture is marked as "used for short-term reference". long_term_reference_flag equal to 1
specifies that the MaxLongTermFrameIdx variable is set equal to 0 and that the current IDR picture is marked "used for
long-term reference" and is assigned LongTermFrameIdx equal to 0. When max_num_ref_frames is equal to 0,
long_term_reference_flag shall be equal to 0.


**adaptive_ref_pic_marking_mode_flag** selects the reference picture marking mode of the currently decoded picture as
specified in Table 7-8. adaptive_ref_pic_marking_mode_flag shall be equal to 1 when the number of frames,
complementary field pairs, and non-paired fields that are currently marked as "used for long-term reference" is equal to
Max( max_num_ref_frames, 1 ).


**Table 7-8 – Interpretation of adaptive_ref_pic_marking_mode_flag**

|adaptive_ref_pic_marking_mode_flag|Reference picture marking mode specified|
|---|---|
|0|Sliding window reference picture marking mode: A marking mode<br>providing a first-in first-out mechanism for short-term reference<br>pictures.|
|1|Adaptive reference picture marking mode: A reference picture<br>marking mode providing syntax elements to specify marking of<br>reference pictures as "unused for reference" and to assign long-term<br>frame indices.|






**memory_management_control_operation** specifies a control operation to be applied to affect the reference picture
marking. The memory_management_control_operation syntax element is followed by data necessary for the operation
specified by the value of memory_management_control_operation. The values and control operations associated with
memory_management_control_operation are specified in Table 7-9. The memory_management_control_operation syntax
elements are processed by the decoding process in the order in which they appear in the slice header, and the semantics
constraints expressed for each memory_management_control_operation apply at the specific position in that order at which
that individual memory_management_control_operation is processed.


For interpretation of memory_management_control_operation, the term reference picture is interpreted as follows:


- If the current picture is a frame, the term reference picture refers either to a reference frame or a complementary
reference field pair.


- Otherwise (the current picture is a field), the term reference picture refers either to a reference field or a field of a
reference frame.


memory_management_control_operation shall not be equal to 1 in a slice header unless the specified reference picture is
marked as "used for short-term reference" when the memory_management_control_operation is processed by the decoding
process.


memory_management_control_operation shall not be equal to 2 in a slice header unless the specified long-term picture
number refers to a reference picture that is marked as "used for long-term reference" when the
memory_management_control_operation is processed by the decoding process.


memory_management_control_operation shall not be equal to 3 in a slice header unless the specified reference picture is
marked as "used for short-term reference" when the memory_management_control_operation is processed by the decoding
process.


memory_management_control_operation shall not be equal to 3 or 6 if the value of the variable MaxLongTermFrameIdx
is equal to "no long-term frame indices" when the memory_management_control_operation is processed by the decoding
process.


Not more than one memory_management_control_operation equal to 4 shall be present in a slice header.


Not more than one memory_management_control_operation equal to 5 shall be present in a slice header.


Not more than one memory_management_control_operation equal to 6 shall be present in a slice header.


memory_management_control_operation shall not be equal to 5 in a slice header unless no
memory_management_control_operation in the range of 1 to 3 is present in the same decoded reference picture marking
syntax structure.


A memory_management_control_operation equal to 5 shall not follow a memory_management_control_operation equal
to 6 in the same slice header.


When a memory_management_control_operation equal to 6 is present, any memory_management_control_operation
equal to 2, 3, or 4 that follows the memory_management_control_operation equal to 6 within the same slice header shall
not specify the current picture to be marked as "unused for reference".

NOTE 2 – These constraints prohibit any combination of multiple memory_management_control_operation syntax elements that
would specify the current picture to be marked as "unused for reference". However, some other combinations of
memory_management_control_operation syntax elements are permitted that may affect the marking status of other reference
pictures more than once in the same slice header. In particular, it is permitted for a memory_management_control_operation equal
to 3 that specifies a long-term frame index to be assigned to a particular short-term reference picture to be followed in the same slice
header by a memory_management_control_operation equal to 2, 3, 4 or 6 that specifies the same reference picture to subsequently
be marked as "unused for reference".





**Table 7-9 – Memory management control operation (memory_management_control_operation) values**

|memory_management_control_operation|Memory Management Control Operation|
|---|---|
|0|End memory_management_control_operation<br>syntax element loop|
|1|Mark a short-term reference picture as<br>"unused for reference"|
|2|Mark a long-term reference picture as<br>"unused for reference"|
|3|Mark a short-term reference picture as<br>"used for long-term reference" and assign a<br>long-term frame index to it|
|4|Specify the maximum long-term frame index<br>and mark all long-term reference pictures<br>having long-term frame indices greater than<br>the maximum value as "unused for reference"|
|5|Mark all reference pictures as<br>"unused for reference" and set the<br>MaxLongTermFrameIdx variable to<br>"no long-term frame indices"|
|6|Mark the current picture as<br>"used for long-term reference" and assign a<br>long-term frame index to it|



When decoding a field and a memory_management_control_operation command equal to 3 is present that assigns a longterm frame index to a field that is part of a short-term reference frame or part of a complementary reference field pair,
another memory_management_control_operation command (equal to 3 or 6) to assign the same long-term frame index to
the other field of the same frame or complementary reference field pair shall be present in the same decoded reference
picture marking syntax structure.

NOTE 3 – The above requirement must be fulfilled even when the field referred to by the memory_management_control_operation
equal to 3 is subsequently marked as "unused for reference" (for example when a memory_management_control_operation equal
to 2 is present in the same slice header that causes the field to be marked as "unused for reference").
NOTE 4 – The above requirement has the following implications:

  - When a memory_management_control_operation equal to 3 is present that assigns a long-term frame index to a field that is part
of a reference frame or complementary reference field pair with both fields marked as "used for short-term reference" (when
processing the memory_management_control_operation equal to 3), another memory_management_control_operation equal
to 3 must also be present in the same decoded reference picture marking syntax structure that assigns the same long-term frame
index to the other field of the reference frame or complementary reference field pair.

  - When the current picture is the second field (in decoding order) of a complementary reference field pair and a
memory_management_control_operation equal to 3 is present in the decoded reference picture marking syntax structure of the
current picture that assigns a long-term frame index to the first field (in decoding order) of the complementary reference field
pair, a memory_management_control_operation equal to 6 must be present in the same decoded reference picture marking
syntax structure that assigns the same long-term frame index to the second field of the complementary reference field pair.


When the first field (in decoding order) of a complementary reference field pair included a long_term_reference_flag equal
to 1 or a memory_management_control_operation command equal to 6, the decoded reference picture marking syntax
structure for the second field of the complementary reference field pair shall contain a
memory_management_control_operation command equal to 6 that assigns the same long-term frame index to the second
field.

NOTE 5 – The above requirement must be fulfilled even when the first field of the complementary reference field pair is
subsequently marked as "unused for reference" (for example, when a memory_management_control_operation equal to 2 is present
in the slice header of the second field that causes the first field to be marked as "unused for reference").


When the second field (in decoding order) of a complementary reference field pair includes a
memory_management_control_operation command equal to 6 that assigns a long-term frame index to this field and the
first field of the complementary reference field pair is marked as "used for short-term reference" when the
memory_management_control_operation command equal to 6 is processed by the decoding process, the decoded reference
picture marking syntax structure of that second field shall contain either a memory_management_control_operation
command equal to 1 that marks the first field of the complementary field pair as "unused for reference" or a
memory_management_control_operation command equal to 3 that marks the first field of the complementary field pair as
"used for long-term reference" and assigns the same long-term frame index to the first field.





NOTE 6 – The above constraints specify that when both fields of a frame or a complementary field pair are marked as "used for
reference" after processing all memory_management_control_operation commands of the decoded reference picture marking syntax
structure, either both fields must be marked as "used for short-term reference" or both fields must be marked as "used for long-term
reference". When both fields are marked as "used for long-term reference", the same long-term frame index must be assigned to
both fields.


**difference_of_pic_nums_minus1** is used (with memory_management_control_operation equal to 3 or 1) to assign a longterm frame index to a short-term reference picture or to mark a short-term reference picture as "unused for reference".
When the associated memory_management_control_operation is processed by the decoding process, the resulting picture
number derived from difference_of_pic_nums_minus1 shall be a picture number assigned to one of the reference pictures
marked as "used for reference" and not previously assigned to a long-term frame index.


The resulting picture number is constrained as follows:


- If field_pic_flag is equal to 0, the resulting picture number shall be one of the set of picture numbers assigned to
reference frames or complementary reference field pairs.

NOTE 7 – When field_pic_flag is equal to 0, the resulting picture number must be a picture number assigned to a
complementary reference field pair in which both fields are marked as "used for reference" or a frame in which both
fields are marked as "used for reference". In particular, when field_pic_flag is equal to 0, the marking of a non-paired
field or a frame in which a single field is marked as "used for reference" cannot be affected by a
memory_management_control_operation equal to 1.


- Otherwise (field_pic_flag is equal to 1), the resulting picture number shall be one of the set of picture numbers
assigned to reference fields.


**long_term_pic_num** is used (with memory_management_control_operation equal to 2) to mark a long-term reference
picture as "unused for reference". When the associated memory_management_control_operation is processed by the
decoding process, long_term_pic_num shall be equal to a long-term picture number assigned to one of the reference
pictures that is currently marked as "used for long-term reference".


The resulting long-term picture number is constrained as follows:


- If field_pic_flag is equal to 0, the resulting long-term picture number shall be one of the set of long-term picture
numbers assigned to reference frames or complementary reference field pairs.

NOTE 8 – When field_pic_flag is equal to 0, the resulting long-term picture number must be a long-term picture number
assigned to a complementary reference field pair in which both fields are marked as "used for reference" or a frame in
which both fields are marked as "used for reference". In particular, when field_pic_flag is equal to 0, the marking of a
non-paired field or a frame in which a single field is marked as "used for reference" cannot be affected by a
memory_management_control_operation equal to 2.


- Otherwise (field_pic_flag is equal to 1), the resulting long-term picture number shall be one of the set of long-term
picture numbers assigned to reference fields.


**long_term_frame_idx** is used (with memory_management_control_operation equal to 3 or 6) to assign a long-term frame
index to a picture. When the associated memory_management_control_operation is processed by the decoding process,
the value of long_term_frame_idx shall be in the range of 0 to MaxLongTermFrameIdx, inclusive.


**max_long_term_frame_idx_plus1** minus 1 specifies the maximum value of long-term frame index allowed for long-term
reference pictures (until receipt of another value of max_long_term_frame_idx_plus1). The value of
max_long_term_frame_idx_plus1 shall be in the range of 0 to max_num_ref_frames, inclusive.


**7.4.4** **Slice data semantics**


**cabac_alignment_one_bit** is a bit equal to 1.


**mb_skip_run** specifies the number of consecutive skipped macroblocks for which, when decoding a P or SP slice,
mb_type shall be inferred to be P_Skip and the macroblock type is collectively referred to as a P macroblock type, or for
which, when decoding a B slice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred
to as a B macroblock type. The value of mb_skip_run shall be in the range of 0 to PicSizeInMbs − CurrMbAddr, inclusive.


**mb_skip_flag** equal to 1 specifies that for the current macroblock, when decoding a P or SP slice, mb_type shall be inferred
to be P_Skip and the macroblock type is collectively referred to as P macroblock type, or for which, when decoding a B
slice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred to as B macroblock type.
mb_skip_flag equal to 0 specifies that the current macroblock is not skipped.


**mb_field_decoding_flag** equal to 0 specifies that the current macroblock pair is a frame macroblock pair.
mb_field_decoding_flag equal to 1 specifies that the macroblock pair is a field macroblock pair. Both macroblocks of a
frame macroblock pair are referred to in the text as frame macroblocks, whereas both macroblocks of a field macroblock
pair are referred to in the text as field macroblocks.





When MbaffFrameFlag is equal to 0 (mb_field_decoding_flag is not present), mb_field_decoding_flag is inferred to be
equal to field_pic_flag.


When MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is not present for both the top and the bottom macroblock
of a macroblock pair, the value of mb_field_decoding_flag shall be inferred as follows:

- If there is a neighbouring macroblock pair immediately to the left of the current macroblock pair in the same slice,
the value of mb_field_decoding_flag is inferred to be equal to the value of mb_field_decoding_flag for the
neighbouring macroblock pair immediately to the left of the current macroblock pair,

- Otherwise, if there is no neighbouring macroblock pair immediately to the left of the current macroblock pair in the
same slice and there is a neighbouring macroblock pair immediately above the current macroblock pair in the same
slice, the value of mb_field_decoding_flag is inferred to be equal to the value of mb_field_decoding_flag for the
neighbouring macroblock pair immediately above the current macroblock pair,

- Otherwise (there is no neighbouring macroblock pair either immediately to the left or immediately above the current
macroblock pair in the same slice), the value of mb_field_decoding_flag is inferred to be equal to 0.
NOTE – When MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is not present for the top macroblock of a macroblock
pair (because the top macroblock is skipped), a decoder must wait until mb_field_decoding_flag for the bottom macroblock is read
(when the bottom macroblock is not skipped) or the value of mb_field_decoding_flag is inferred as specified above (when the bottom
macroblock is also skipped) before it starts the decoding process for the top macroblock.


**end_of_slice_flag** equal to 0 specifies that another macroblock is following in the slice. end_of_slice_flag equal to 1
specifies the end of the slice and that no further macroblock follows.


The function NextMbAddress( ) used in the slice data syntax table is specified in clause 8.2.2.


**7.4.5** **Macroblock layer semantics**


**mb_type** specifies the macroblock type. The semantics of mb_type depend on the slice type.


Tables and semantics are specified for the various macroblock types for I, SI, P, SP, and B slices. Each table presents the
value of mb_type, the name of mb_type, the number of macroblock partitions used (given by the NumMbPart( mb_type )
function), the prediction mode of the macroblock (when it is not partitioned) or the first partition (given by the
MbPartPredMode( mb_type, 0 ) function) and the prediction mode of the second partition (given by the
MbPartPredMode( mb_type, 1 ) function). When a value is not applicable it is designated by "na". In the text, the value of
mb_type may be referred to as the macroblock type, the value of MbPartPredMode( ) may be referred to in the text by
"macroblock (partition) prediction mode", and a value X of MbPartPredMode( ) may be referred to in the text by "X
macroblock (partition) prediction mode" or as "X prediction macroblocks".


Table 7-10 shows the allowed collective macroblock types for each slice_type.

NOTE 1 – There are some macroblock types with Pred_L0 macroblock (partition) prediction mode(s) that are classified as B
macroblock types.


**Table 7-10 – Allowed collective macroblock types for slice_type**

|slice_type|allowed collective macroblock types|
|---|---|
|I (slice)|I (see Table 7-11) (macroblock types)|
|P (slice)|P (see Table 7-13) and I (see Table 7-11) (macroblock types)|
|B (slice)|B (see Table 7-14) and I (see Table 7-11) (macroblock types)|
|SI (slice)|SI (see Table 7-12) and I (see Table 7-11) (macroblock types)|
|SP (slice)|P (see Table 7-13) and I (see Table 7-11) (macroblock types)|



**transform_size_8x8_flag** equal to 1 specifies that for the current macroblock the transform coefficient decoding process
and picture construction process prior to deblocking filter process for residual 8x8 blocks shall be invoked for luma
samples, and when ChromaArrayType = = 3 also for Cb and Cr samples. transform_size_8x8_flag equal to 0 specifies
that for the current macroblock the transform coefficient decoding process and picture construction process prior to
deblocking filter process for residual 4x4 blocks shall be invoked for luma samples, and when ChromaArrayType = = 3
also for Cb and Cr samples. When transform_size_8x8_flag is not present in the bitstream, it shall be inferred to be equal
to 0.

NOTE 2 – When the current macroblock prediction mode MbPartPredMode( mb_type, 0 ) is equal to Intra_16x16,
transform_size_8x8_flag is not present in the bitstream and then inferred to be equal to 0.





When sub_mb_type[ mbPartIdx ] (see clause 7.4.5.2) is present in the bitstream for all 8x8 blocks indexed by
mbPartIdx = 0..3, the variable noSubMbPartSizeLessThan8x8Flag indicates whether for each of the four 8x8 blocks the
corresponding SubMbPartWidth( sub_mb_type[ mbPartIdx ] ) and SubMbPartHeight( sub_mb_type[ mbPartIdx ] ) are
both equal to 8.

NOTE 3 – When noSubMbPartSizeLessThan8x8Flag is equal to 0 and the current macroblock type is not equal to I_NxN,
transform_size_8x8_flag is not present in the bitstream and then inferred to be equal to 0.


Macroblock types that may be collectively referred to as I macroblock types are specified in Table 7-11.


The macroblock types for I slices are all I macroblock types.





**Table 7-11 – Macroblock types for I slices**

|mb_type|Name of mb_type|transform_size_8x8_flag|MbPartPredMode ( mb_type, 0 )|Intra16x16PredMode|CodedBlockPatternChroma|CodedBlockPatternLuma|
|---|---|---|---|---|---|---|
|0|I_NxN|0|Intra_4x4|na|Equation7-36|Equation7-36|
|0|I_NxN|1|Intra_8x8|na|Equation7-36|Equation7-36|
|1|I_16x16_0_0_0|na|Intra_16x16|0|0|0|
|2|I_16x16_1_0_0|na|Intra_16x16|1|0|0|
|3|I_16x16_2_0_0|na|Intra_16x16|2|0|0|
|4|I_16x16_3_0_0|na|Intra_16x16|3|0|0|
|5|I_16x16_0_1_0|na|Intra_16x16|0|1|0|
|6|I_16x16_1_1_0|na|Intra_16x16|1|1|0|
|7|I_16x16_2_1_0|na|Intra_16x16|2|1|0|
|8|I_16x16_3_1_0|na|Intra_16x16|3|1|0|
|9|I_16x16_0_2_0|na|Intra_16x16|0|2|0|
|10|I_16x16_1_2_0|na|Intra_16x16|1|2|0|
|11|I_16x16_2_2_0|na|Intra_16x16|2|2|0|
|12|I_16x16_3_2_0|na|Intra_16x16|3|2|0|
|13|I_16x16_0_0_1|na|Intra_16x16|0|0|15|
|14|I_16x16_1_0_1|na|Intra_16x16|1|0|15|
|15|I_16x16_2_0_1|na|Intra_16x16|2|0|15|
|16|I_16x16_3_0_1|na|Intra_16x16|3|0|15|
|17|I_16x16_0_1_1|na|Intra_16x16|0|1|15|
|18|I_16x16_1_1_1|na|Intra_16x16|1|1|15|
|19|I_16x16_2_1_1|na|Intra_16x16|2|1|15|
|20|I_16x16_3_1_1|na|Intra_16x16|3|1|15|
|21|I_16x16_0_2_1|na|Intra_16x16|0|2|15|
|22|I_16x16_1_2_1|na|Intra_16x16|1|2|15|
|23|I_16x16_2_2_1|na|Intra_16x16|2|2|15|
|24|I_16x16_3_2_1|na|Intra_16x16|3|2|15|
|25|I_PCM|na|na<br>|na|na|na|






The following semantics are assigned to the macroblock types in Table 7-11:


- I_NxN: A mnemonic name for mb_type equal to 0 with MbPartPredMode( mb_type, 0 ) equal to Intra_4x4 or
Intra_8x8.


- I_16x16_0_0_0, I_16x16_1_0_0, I_16x16_2_0_0, I_16x16_3_0_0, I_16x16_0_1_0, I_16x16_1_1_0,
I_16x16_2_1_0, I_16x16_3_1_0, I_16x16_0_2_0, I_16x16_1_2_0, I_16x16_2_2_0, I_16x16_3_2_0,
I_16x16_0_0_1, I_16x16_1_0_1, I_16x16_2_0_1, I_16x16_3_0_1, I_16x16_0_1_1, I_16x16_1_1_1,
I_16x16_2_1_1, I_16x16_3_1_1, I_16x16_0_2_1, I_16x16_1_2_1, I_16x16_2_2_1, I_16x16_3_2_1: the
macroblock is coded as an Intra_16x16 prediction macroblock.


To each Intra_16x16 prediction macroblock, an Intra16x16PredMode is assigned, which specifies the Intra_16x16
prediction mode, and values of CodedBlockPatternLuma and CodedBlockPatternChroma are assigned as specified in
Table 7-11.


Intra_4x4 specifies the macroblock prediction mode and specifies that the Intra_4x4 prediction process is invoked as
specified in clause 8.3.1. Intra_4x4 is an Intra macroblock prediction mode.


Intra_8x8 specifies the macroblock prediction mode and specifies that the Intra_8x8 prediction process is invoked as
specified in clause 8.3.2. Intra_8x8 is an Intra macroblock prediction mode.


Intra_16x16 specifies the macroblock prediction mode and specifies that the Intra_16x16 prediction process is invoked as
specified in clause 8.3.3. Intra_16x16 is an Intra macroblock prediction mode.


For a macroblock coded with mb_type equal to I_PCM, the Intra macroblock prediction mode shall be inferred.


A macroblock type that may be referred to as the SI macroblock type is specified in Table 7-12.


The macroblock types for SI slices are specified in Tables 7-12 and 7-11. The mb_type value 0 is specified in Table 7-12
and the mb_type values 1 to 26 are specified in Table 7-11, indexed by subtracting 1 from the value of mb_type.


**Table 7-12 – Macroblock type with value 0 for SI slices**

|mb_type|Name of mb_type|MbPartPredMode ( mb_type, 0 )|Intra16x16PredMode|CodedBlockPatternChroma|CodedBlockPatternLuma|
|---|---|---|---|---|---|
|0|SI|Intra_4x4|na|Equation7-36|Equation7-36|



The following semantics are assigned to the macroblock type in Table 7-12:


- The SI macroblock is coded as Intra_4x4 prediction macroblock.


Macroblock types that may be collectively referred to as P macroblock types are specified in Table 7-13.


The macroblock types for P and SP slices are specified in Tables 7-13 and 7-11. mb_type values 0 to 4 are specified in
Table 7-13 and mb_type values 5 to 30 are specified in Table 7-11, indexed by subtracting 5 from the value of mb_type.





**Table 7-13 – Macroblock type values 0 to 4 for P and SP slices**

|mb_type|Name of mb_type|NumMbPart ( mb_type )|MbPartPredMode ( mb_type, 0 )|MbPartPredMode ( mb_type, 1 )|MbPartWidth ( mb_type )|MbPartHeight ( mb_type )|
|---|---|---|---|---|---|---|
|0|P_L0_16x16|1|Pred_L0|na|16|16|
|1|P_L0_L0_16x8|2|Pred_L0|Pred_L0|16|8|
|2|P_L0_L0_8x16|2|Pred_L0|Pred_L0|8|16|
|3|P_8x8|4|na|na|8|8|
|4|P_8x8ref0|4|na|na|8|8|
|inferred|P_Skip|1|Pred_L0|na|16|16|



The following semantics are assigned to the macroblock types in Table 7-13:


- P_L0_16x16: the samples of the macroblock are predicted with one luma macroblock partition of size 16x16 luma
samples and associated chroma samples.


- P_L0_L0_MxN, with MxN being replaced by 16x8 or 8x16: the samples of the macroblock are predicted using two
luma partitions of size MxN equal to 16x8, or two luma partitions of size MxN equal to 8x16, and associated chroma
samples, respectively.


- P_8x8: for each sub-macroblock an additional syntax element (sub_mb_type[ mbPartIdx ] with mbPartIdx being the
macroblock partition index for the corresponding sub-macroblock) is present in the bitstream that specifies the type
of the corresponding sub-macroblock (see clause 7.4.5.2).


- P_8x8ref0: has the same semantics as P_8x8 but no syntax element for the reference index (ref_idx_l0[ mbPartIdx ]
with mbPartIdx = 0..3) is present in the bitstream and ref_idx_l0[ mbPartIdx ] shall be inferred to be equal to 0 for all
sub-macroblocks of the macroblock (with indices mbPartIdx = 0..3).


- P_Skip: no further data is present for the macroblock in the bitstream.


The following semantics are assigned to the macroblock prediction modes (for macroblocks that are not partitioned) and
macroblock partition prediction modes (for macroblocks that are partitioned) specified by MbPartPredMode( ) in
Table 7-13:


- Pred_L0: specifies that the Inter prediction process is invoked using list 0 prediction. Pred_L0 is an Inter macroblock
prediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction mode (for
macroblocks that are partitioned).


When mb_type is equal to any of the values specified in Table 7-13, the macroblock is coded in an Inter macroblock
prediction mode.


Macroblock types that may be collectively referred to as B macroblock types are specified in Table 7-14.


The macroblock types for B slices are specified in Tables 7-14 and 7-11. The mb_type values 0 to 22 are specified in
Table 7-14 and the mb_type values 23 to 48 are specified in Table 7-11, indexed by subtracting 23 from the value of
mb_type.





**Table 7-14 – Macroblock type values 0 to 22 for B slices**

|mb_type|Name of mb_type|NumMbPart ( mb_type )|MbPartPredMode ( mb_type, 0 )|MbPartPredMode ( mb_type, 1 )|MbPartWidth ( mb_type )|MbPartHeight ( mb_type )|
|---|---|---|---|---|---|---|
|0|B_Direct_16x16|na|Direct|na|8|8|
|1|B_L0_16x16|1|Pred_L0|na|16|16|
|2|B_L1_16x16|1|Pred_L1|na|16|16|
|3|B_Bi_16x16|1|BiPred|na|16|16|
|4|B_L0_L0_16x8|2|Pred_L0|Pred_L0|16|8|
|5|B_L0_L0_8x16|2|Pred_L0|Pred_L0|8|16|
|6|B_L1_L1_16x8|2|Pred_L1|Pred_L1|16|8|
|7|B_L1_L1_8x16|2|Pred_L1|Pred_L1|8|16|
|8|B_L0_L1_16x8|2|Pred_L0|Pred_L1|16|8|
|9|B_L0_L1_8x16|2|Pred_L0|Pred_L1|8|16|
|10|B_L1_L0_16x8|2|Pred_L1|Pred_L0|16|8|
|11|B_L1_L0_8x16|2|Pred_L1|Pred_L0|8|16|
|12|B_L0_Bi_16x8|2|Pred_L0|BiPred|16|8|
|13|B_L0_Bi_8x16|2|Pred_L0|BiPred|8|16|
|14|B_L1_Bi_16x8|2|Pred_L1|BiPred|16|8|
|15|B_L1_Bi_8x16|2|Pred_L1|BiPred|8|16|
|16|B_Bi_L0_16x8|2|BiPred|Pred_L0|16|8|
|17|B_Bi_L0_8x16|2|BiPred|Pred_L0|8|16|
|18|B_Bi_L1_16x8|2|BiPred|Pred_L1|16|8|
|19|B_Bi_L1_8x16|2|BiPred|Pred_L1|8|16|
|20|B_Bi_Bi_16x8|2|BiPred|BiPred|16|8|
|21|B_Bi_Bi_8x16|2|BiPred|BiPred|8|16|
|22|B_8x8|4|na|na|8|8|
|inferred|B_Skip|na|Direct|na|8|8|



The following semantics are assigned to the macroblock types in Table 7-14:


- B_Direct_16x16: no motion vector differences or reference indices are present for the macroblock in the bitstream.
The functions MbPartWidth( B_Direct_16x16 ), and MbPartHeight( B_Direct_16x16 ) are used in the derivation
process for motion vectors and reference frame indices in clause 8.4.1 for direct mode prediction.


- B_X_16x16 with X being replaced by L0, L1, or Bi: the samples of the macroblock are predicted with one luma
macroblock partition of size 16x16 luma samples and associated chroma samples. For a macroblock with type
B_X_16x16 with X being replaced by either L0 or L1, one motion vector difference and one reference index is present





in the bitstream for the macroblock. For a macroblock with type B_X_16x16 with X being replaced by Bi, two motion
vector differences and two reference indices are present in the bitstream for the macroblock.


- B_X0_X1_MxN, with X0, X1 referring to the first and second macroblock partition and being replaced by L0, L1, or
Bi, and MxN being replaced by 16x8 or 8x16: the samples of the macroblock are predicted using two luma partitions
of size MxN equal to 16x8, or two luma partitions of size MxN equal to 8x16, and associated chroma samples,
respectively. For a macroblock partition X0 or X1 with X0 or X1 being replaced by either L0 or L1, one motion vector
difference and one reference index is present in the bitstream. For a macroblock partition X0 or X1 with X0 or X1
being replaced by Bi, two motion vector differences and two reference indices are present in the bitstream for the
macroblock partition.


- B_8x8: for each sub-macroblock an additional syntax element (sub_mb_type[ mbPartIdx ] with mbPartIdx being the
macroblock partition index for the corresponding sub-macroblock) is present in the bitstream that specifies the type
of the corresponding sub-macroblock (see clause 7.4.5.2).


- B_Skip: no further data is present for the macroblock in the bitstream. The functions MbPartWidth( B_Skip ), and
MbPartHeight( B_Skip ) are used in the derivation process for motion vectors and reference frame indices in
clause 8.4.1 for direct mode prediction.


The following semantics are assigned to the macroblock prediction modes (for macroblocks that are not partitioned) and
macroblock partition prediction modes (for macroblocks that are partitioned) specified by MbPartPredMode( ) in
Table 7-14:


- Direct: no motion vector differences or reference indices are present for the macroblock (in case of B_Skip or
B_Direct_16x16) in the bitstream. Direct is an Inter macroblock prediction mode (for macroblocks that are not
partitioned) and an Inter macroblock partition prediction mode (for macroblocks that are partitioned, see Table 7-18).


- Pred_L0: the semantics specified for Table 7-13 apply.


- Pred_L1: specifies that the Inter prediction process is invoked using list 1 prediction. Pred_L1 is an Inter macroblock
prediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction mode (for
macroblocks that are partitioned).


- BiPred: specifies that the Inter prediction process is invoked using list 0 and list 1 prediction. BiPred is an Inter
macroblock prediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction
mode (for macroblocks that are partitioned).


When mb_type is equal to any of the values specified in Table 7-14, the macroblock is coded in an Inter macroblock
prediction mode.


**pcm_alignment_zero_bit** is a bit equal to 0.


**pcm_sample_luma** [ i ] is a sample value. The pcm_sample_luma[ i ] values represent luma sample values in the raster
scan within the macroblock. The number of bits used to represent each of these samples is BitDepthY.


**pcm_sample_chroma** [ i ] is a sample value. The first MbWidthC * MbHeightC pcm_sample_chroma[ i ] values represent
Cb sample values in the raster scan within the macroblock and the remaining MbWidthC * MbHeightC
pcm_sample_chroma[ i ] values represent Cr sample values in the raster scan within the macroblock. The number of bits
used to represent each of these samples is BitDepthC.


**coded_block_pattern** specifies which of the four 8x8 luma blocks and associated chroma blocks of a macroblock may
contain non-zero transform coefficient levels. When coded_block_pattern is present in the bitstream, the variables
CodedBlockPatternLuma and CodedBlockPatternChroma are derived as


CodedBlockPatternLuma = coded_block_pattern % 16
CodedBlockPatternChroma = coded_block_pattern / 16 (7-36)


When the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, the following applies:


- If the macroblock prediction mode is equal Intra_16x16, the following applies:

   - If ChromaArrayType is not equal to 3, the value of CodedBlockPatternLuma specifies the following.

      - If CodedBlockPatternLuma is equal to 0, all AC transform coefficient levels of the luma component of the
macroblock are equal to 0 for all 16 of the 4x4 blocks in the 16x16 luma block.

      - Otherwise (CodedBlockPatternLuma is not equal to 0), CodedBlockPatternLuma is equal to 15, at least one
of the AC transform coefficient levels of the luma component of the macroblock shall be non-zero, and the
AC transform coefficient levels are scanned for all 16 of the 4x4 blocks in the 16x16 block.





   - Otherwise (ChromaArrayType is equal to 3), the value of CodedBlockPatternLuma specifies the following.

      - If CodedBlockPatternLuma is equal to 0, all AC transform coefficient levels of the luma, Cb, and Cr
components of the macroblock are equal to 0 for all 16 of the 4x4 blocks in the luma, Cb, and Cr components
of the macroblock.

      - Otherwise (CodedBlockPatternLuma is not equal to 0), CodedBlockPatternLuma is equal to 15, at least one
of the AC transform coefficient levels of the luma, Cb, or Cr components of the macroblock shall be nonzero, and the AC transform coefficient levels are scanned for all 16 of the 4x4 blocks in the luma Cb, and
Cr components of the macroblock.


- Otherwise (the macroblock prediction mode is not equal to Intra_16x16), coded_block_pattern is present in the
bitstream, and the following applies:

   - If ChromaArrayType is not equal to 3, each of the four LSBs of CodedBlockPatternLuma specifies, for one of
the four 8x8 luma blocks of the macroblock, the following.

      - If the corresponding bit of CodedBlockPatternLuma is equal to 0, all transform coefficient levels of the
luma transform blocks in the 8x8 luma block are equal to zero.

      - Otherwise (the corresponding bit of CodedBlockPatternLuma is equal to 1), one or more transform
coefficient levels of one or more of the luma transform blocks in the 8x8 luma block shall be non-zero
valued and the transform coefficient levels of the corresponding transform blocks are scanned.

   - Otherwise (ChromaArrayType is equal to 3), each of the four LSBs of CodedBlockPatternLuma specifies, for
one of the four 8x8 luma blocks of the macroblock, the following.

      - If the corresponding bit of CodedBlockPatternLuma is equal to 0, all transform coefficient levels of the
luma, Cb, and Cr transform blocks in the 8x8 luma block are equal to zero.

      - Otherwise (the corresponding bit of CodedBlockPatternLuma is equal to 1), one or more transform
coefficient levels of one or more of the luma, Cb, or Cr transform blocks in the 8x8 luma block shall be
non-zero valued and the transform coefficient levels of the corresponding transform blocks are scanned.


When the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, CodedBlockPatternChroma is interpreted as follows:


- If ChromaArrayType is not equal to 0 or 3, CodedBlockPatternChroma is specified in Table 7-15.


- Otherwise (ChromaArrayType is equal to 0 or 3), the bitstream shall not contain data that result in a derived value of
CodedBlockPatternChroma that is not equal to 0.


**Table 7-15 – Specification of CodedBlockPatternChroma values**

|CodedBlockPatternChroma|Description|
|---|---|
|0|All chroma transform coefficient levels are equal to 0.|
|1|One or more chroma DC transform coefficient levels shall be non-zero valued.<br>All chroma AC transform coefficient levels are equal to 0.|
|2|Zero or more chroma DC transform coefficient levels are non-zero valued.<br>One or more chroma AC transform coefficient levels shall be non-zero valued.|



**mb_qp_delta** can change the value of QPY in the macroblock layer. The decoded value of mb_qp_delta shall be in the
range of −( 26 + QpBdOffsetY / 2) to +( 25 + QpBdOffsetY / 2 ), inclusive. mb_qp_delta shall be inferred to be equal to 0
when it is not present for any macroblock (including P_Skip and B_Skip macroblock types).


The value of QPY is derived as


QPY = ( ( QPY,PREV + mb_qp_delta + 52 + 2 * QpBdOffsetY ) % ( 52 + QpBdOffsetY ) ) − QpBdOffsetY (7-37)


where QPY,PREV is the luma quantization parameter, QPY, of the previous macroblock in decoding order in the current slice.
For the first macroblock in the slice QPY,PREV is initially set equal to SliceQPY derived in Equation 7-30 at the start of each
slice.


The value of QP′Y is derived as


QP′Y = QPY + QpBdOffsetY (7-38)


The variable TransformBypassModeFlag is derived as follows:





- If qpprime_y_zero_transform_bypass_flag is equal to 1 and QP′Y is equal to 0, TransformBypassModeFlag is set
equal to 1.


- Otherwise (qpprime_y_zero_transform_bypass_flag is equal to 0 or QP′Y is not equal to 0),
TransformBypassModeFlag is set equal to 0.


**7.4.5.1** **Macroblock prediction semantics**


All samples of the macroblock are predicted. The prediction modes are derived using the following syntax elements.


**prev_intra4x4_pred_mode_flag[** luma4x4BlkIdx **]** and **rem_intra4x4_pred_mode[** luma4x4BlkIdx **]** specify the
Intra_4x4 prediction of the 4x4 luma block with index luma4x4BlkIdx = 0..15. When ChromaArrayType is equal to 3,
prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] and rem_intra4x4_pred_mode[ luma4x4BlkIdx ] also specify the
Intra_4x4 prediction of the 4x4 Cb block with luma4x4BlkIdx equal to cb4x4BlkIdx for cb4x4BlkIdx = 0..15 and the
Intra_4x4 prediction of the 4x4 Cr block with luma4x4BlkIdx equal to cr4x4BlkIdx for cr4x4BlkIdx = 0..15.


**prev_intra8x8_pred_mode_flag** [ luma8x8BlkIdx ] and **rem_intra8x8_pred_mode** [ luma8x8BlkIdx ] specify the
Intra_8x8 prediction of the 8x8 luma block with index luma8x8BlkIdx = 0..3. When ChromaArrayType is equal to 3,
prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] and rem_intra8x8_pred_mode[ luma8x8BlkIdx ] also specify the
Intra_8x8 prediction of the 8x8 Cb block with luma8x8BlkIdx equal to cb8x8BlkIdx for cb8x8BlkIdx = 0..3 and the
Intra_8x8 prediction of the 8x8 Cr block with index luma8x8BlkIdx equal to cr8x8BlkIdx for cr8x8BlkIdx = 0..3.


**intra_chroma_pred_mode** specifies, when ChromaArrayType is equal to 1 or 2, the type of spatial prediction used for
chroma in macroblocks using Intra_4x4, Intra_8x8, or Intra_16x16 prediction, as shown in Table 7-16. The value of
intra_chroma_pred_mode shall be in the range of 0 to 3, inclusive.


**Table 7-16 – Relationship between intra_chroma_pred_mode and spatial prediction modes**

|intra_chroma_pred_mode|Intra Chroma Prediction Mode|
|---|---|
|0|DC|
|1|Horizontal|
|2|Vertical|
|3|Plane|



**ref_idx_l0[** mbPartIdx **]** when present, specifies the index in reference picture list 0 of the reference picture to be used for
prediction.


The range of ref_idx_l0[ mbPartIdx ], the index in list 0 of the reference picture, and, if applicable, the parity of the field
within the reference picture used for prediction are specified as follows:


- If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, the value of ref_idx_l0[ mbPartIdx ] shall
be in the range of 0 to num_ref_idx_l0_active_minus1, inclusive.


- Otherwise (MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1), the value of
ref_idx_l0[ mbPartIdx ] shall be in the range of 0 to 2 * num_ref_idx_l0_active_minus1 + 1, inclusive.


When only one reference picture is used for inter prediction, the values of ref_idx_l0[ mbPartIdx ] shall be inferred to be
equal to 0.


**ref_idx_l1[** mbPartIdx **]** has the same semantics as ref_idx_l0, with l0 and list 0 replaced by l1 and list 1, respectively.


**mvd_l0[** mbPartIdx **][** 0 **][** compIdx **]** specifies the difference between a list 0 motion vector component to be used and its
prediction. The index mbPartIdx specifies to which macroblock partition mvd_l0 is assigned. The partitioning of the
macroblock is specified by mb_type. The horizontal motion vector component difference is decoded first in decoding order
and is assigned compIdx = 0. The vertical motion vector component is decoded second in decoding order and is assigned
compIdx = 1. The value of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] shall be in the range of −8192 to 8191.75, inclusive. The
range of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] is also constrained indirectly by constraints on the motion vector variable
values derived from it as specified in Annex A.


**mvd_l1[** mbPartIdx **][** 0 **][** compIdx **]** has the same semantics as mvd_l0, with l0 and list 0 replaced by l1 and list 1,
respectively.





**7.4.5.2** **Sub-macroblock prediction semantics**


**sub_mb_type[** mbPartIdx **]** specifies the sub-macroblock types.


Tables and semantics are specified for the various sub-macroblock types for P, and B macroblock types. Each table presents
the value of sub_mb_type[ mbPartIdx ], the name of sub_mb_type[ mbPartIdx ], the number of sub-macroblock partitions
used (given by the NumSubMbPart( sub_mb_type[ mbPartIdx ] ) function), and the prediction mode of the submacroblock (given by the SubMbPredMode( sub_mb_type[ mbPartIdx ] ) function). In the text, the value of
sub_mb_type[ mbPartIdx ] may be referred to by "sub-macroblock type". In the text, the value of SubMbPredMode( ) may
be referred to by "sub-macroblock prediction mode" or "macroblock partition prediction mode".


The interpretation of sub_mb_type[ mbPartIdx ] for P macroblock types is specified in Table 7-17, where the row for
"inferred" specifies values inferred when sub_mb_type[ mbPartIdx ] is not present.


**Table 7-17 – Sub-macroblock types in P macroblocks**

|sub_mb_type[ mbPartIdx ]|Name of sub_mb_type[ mbPartIdx ]|NumSubMbPart ( sub_mb_type[ mbPartIdx ] )|SubMbPredMode ( sub_mb_type[ mbPartIdx ] )|SubMbPartWidth ( sub_mb_type[ mbPartIdx ] )|SubMbPartHeight ( sub_mb_type[ mbPartIdx ] )|
|---|---|---|---|---|---|
|inferred|na|na|na|na|na|
|0|P_L0_8x8|1|Pred_L0|8|8|
|1|P_L0_8x4|2|Pred_L0|8|4|
|2|P_L0_4x8|2|Pred_L0|4|8|
|3|P_L0_4x4|4|Pred_L0|4|4|



The following semantics are assigned to the sub-macroblock types in Table 7-17:


- P_L0_MxN, with MxN being replaced by 8x8, 8x4, 4x8, or 4x4: the samples of the sub-macroblock are predicted
using one luma partition of size MxN equal to 8x8, two luma partitions of size MxN equal to 8x4, or two luma
partitions of size MxN equal to 4x8, or four luma partitions of size MxN equal to 4x4, and associated chroma samples,
respectively.


The following semantics are assigned to the sub-macroblock prediction modes (or macroblock partition prediction modes)
specified by SubMbPredMode( ) in Table 7-17:


- Pred_L0: see semantics for Table 7-13.





The interpretation of sub_mb_type[ mbPartIdx ] for B macroblock types is specified in Table 7-18, where the row for
"inferred" specifies values inferred when sub_mb_type[ mbPartIdx ] is not present, and the inferred value "mb_type"
specifies that the name of sub_mb_type[ mbPartIdx ] is the same as the name of mb_type for this case.


**Table 7-18 – Sub-macroblock types in B macroblocks**

|sub_mb_type[ mbPartIdx ]|Name of sub_mb_type[ mbPartIdx ]|NumSubMbPart ( sub_mb_type[ mbPartIdx ] )|SubMbPredMode ( sub_mb_type[ mbPartIdx ] )|SubMbPartWidth ( sub_mb_type[ mbPartIdx ] )|SubMbPartHeight ( sub_mb_type[ mbPartIdx ] )|
|---|---|---|---|---|---|
|inferred|mb_type|4|Direct|4|4|
|0|B_Direct_8x8|4|Direct|4|4|
|1|B_L0_8x8|1|Pred_L0|8|8|
|2|B_L1_8x8|1|Pred_L1|8|8|
|3|B_Bi_8x8|1|BiPred|8|8|
|4|B_L0_8x4|2|Pred_L0|8|4|
|5|B_L0_4x8|2|Pred_L0|4|8|
|6|B_L1_8x4|2|Pred_L1|8|4|
|7|B_L1_4x8|2|Pred_L1|4|8|
|8|B_Bi_8x4|2|BiPred|8|4|
|9|B_Bi_4x8|2|BiPred|4|8|
|10|B_L0_4x4|4|Pred_L0|4|4|
|11|B_L1_4x4|4|Pred_L1|4|4|
|12|B_Bi_4x4|4|BiPred|4|4|



The following semantics are assigned to the sub-macroblock types in Table 7-18:


- B_Skip and B_Direct_16x16: no motion vector differences or reference indices are present for the sub-macroblock
in the bitstream. The functions SubMbPartWidth( ) and SubMbPartHeight( ) are used in the derivation process for
motion vectors and reference frame indices in clause 8.4.1 for direct mode prediction.


- B_Direct_8x8: no motion vector differences or reference indices are present for the sub-macroblock in the bitstream.
The functions SubMbPartWidth( B_Direct_8x8 ) and SubMbPartHeight( B_Direct_8x8 ) are used in the derivation
process for motion vectors and reference frame indices in clause 8.4.1 for direct mode prediction.


- B_X_MxN, with X being replaced by L0, L1, or Bi, and MxN being replaced by 8x8, 8x4, 4x8 or 4x4: the samples
of the sub-macroblock are predicted using one luma partition of size MxN equal to 8x8, or the samples of the submacroblock are predicted using two luma partitions of size MxN equal to 8x4, or the samples of the sub-macroblock
are predicted using two luma partitions of size MxN equal to 4x8, or the samples of the sub-macroblock are predicted
using four luma partitions of size MxN equal to 4x4, and associated chroma samples, respectively. All submacroblock partitions share the same reference index. For an MxN sub-macroblock partition in a sub-macroblock
with sub_mb_type[ mbPartIdx ] being B_X_MxN with X being replaced by either L0 or L1, one motion vector
difference is present in the bitstream. For an MxN sub-macroblock partition in a sub-macroblock with
sub_mb_type[ mbPartIdx ] being B_Bi_MxN, two motion vector difference are present in the bitstream.





The following semantics are assigned to the sub-macroblock prediction modes (or macroblock partition prediction modes)
specified by SubMbPredMode( ) in Table 7-18:


- Direct: see semantics for Table 7-14.


- Pred_L0: see semantics for Table 7-13.


- Pred_L1: see semantics for Table 7-14.


- BiPred: see semantics for Table 7-14.


**ref_idx_l0[** mbPartIdx **]** has the same semantics as ref_idx_l0 in clause 7.4.5.1.


**ref_idx_l1[** mbPartIdx **]** has the same semantics as ref_idx_l1 in clause 7.4.5.1.


**mvd_l0[** mbPartIdx **][** subMbPartIdx **][** compIdx **]** has the same semantics as mvd_l0 in clause 7.4.5.1, except that it is
applied to the sub-macroblock partition index with subMbPartIdx. The indices mbPartIdx and subMbPartIdx specify to
which macroblock partition and sub-macroblock partition mvd_l0 is assigned.


**mvd_l1[** mbPartIdx **][** subMbPartIdx **][** compIdx **]** has the same semantics as mvd_l1 in clause 7.4.5.1, except that it is
applied to the sub-macroblock partition index with subMbPartIdx. The indices mbPartIdx and subMbPartIdx specify to
which macroblock partition and sub-macroblock partition mvd_l1 is assigned.


**7.4.5.3** **Residual data semantics**


The syntax structure residual_block( ), which is used for parsing the transform coefficient levels, is assigned as follows:


- If entropy_coding_mode_flag is equal to 0, residual_block is set equal to residual_block_cavlc, which is used for
parsing the syntax elements for transform coefficient levels.


- Otherwise (entropy_coding_mode_flag is equal to 1), residual_block is set equal to residual_block_cabac, which is
used for parsing the syntax elements for transform coefficient levels.


The syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used with
the first four variables in brackets being its output and being assigned as follows.


Intra16x16DCLevel is set equal to i16x16DClevel, Intra16x16ACLevel is set equal to i16x16AClevel, LumaLevel4x4 is
set equal to level4x4, and LumaLevel8x8 is set equal to level8x8.


When ChromaArrayType is equal to 1 or 2, the following applies:


- For each chroma component, indexed by iCbCr = 0..1, the DC transform coefficient levels of the 4 * NumC8x8 4x4
chroma blocks are parsed into the iCbCr-th list ChromaDCLevel[ iCbCr ].


- For each of the 4x4 chroma blocks, indexed by i4x4 = 0..3 and i8x8 = 0..NumC8x8 - 1, of each chroma component,
indexed by iCbCr = 0..1, the 15 AC transform coefficient levels are parsed into the (i8x8*4 + i4x4)-th list of the
iCbCr-th chroma component ChromaACLevel[ iCbCr ][ i8x8*4 + i4x4 ].


When ChromaArrayType is equal to 3, the following applies:


- The syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used
for the Cb component with the first four variables in brackets being its output and being assigned as follows.
CbIntra16x16DCLevel is set equal to i16x16DClevel, CbIntra16x16ACLevel is set equal to i16x16AClevel,
CbLevel4x4 is set equal to level4x4, and CbLevel8x8 is set equal to level8x8.


- The syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used
for the Cr component with the first four variables in brackets being its output and being assigned as follows.
CrIntra16x16DCLevel is set equal to i16x16DClevel, CrIntra16x16ACLevel is set equal to i16x16AClevel,
CrLevel4x4 is set equal to level4x4, and CrLevel8x8 is set equal to level8x8.


**7.4.5.3.1** **Residual luma data semantics**


Output of this syntax structure are the variables i16x16DClevel, i16x16AClevel, level4x4, and level8x8.


Depending on mb_type, the syntax structure residual_block( coeffLevel, startIdx, endIdx, maxNumCoeff ) is used with
the arguments coeffLevel, which is a list containing the maxNumCoeff transform coefficient levels that are parsed in
residual_block( ), startIdx, endIdx, and maxNumCoeff as follows.


Depending on MbPartPredMode( mb_type, 0 ), the following applies:


- If MbPartPredMode( mb_type, 0 ) is equal to Intra_16x16, the transform coefficient levels are parsed into the list
i16x16DClevel and into the 16 lists i16x16AClevel[ i ]. i16x16DClevel contains the 16 transform coefficient levels





of the DC transform coefficient levels for each 4x4 luma block. For each of the 16 4x4 luma blocks indexed by
i = 0..15, the 15 AC transform coefficients levels of the i-th block are parsed into the i-th list i16x16AClevel[ i ].


- Otherwise (MbPartPredMode( mb_type, 0 ) is not equal to Intra_16x16), the following applies:

   - If transform_size_8x8_flag is equal to 0, for each of the 16 4x4 luma blocks indexed by i = 0..15, the 16
transform coefficient levels of the i-th block are parsed into the i-th list level4x4[ i ].

   - Otherwise (transform_size_8x8_flag is equal to 1), for each of the 4 8x8 luma blocks indexed by i8x8 = 0..3, the
following applies:

      - If entropy_coding_mode_flag is equal to 0, first for each of the 4 4x4 luma blocks indexed by i4x4 = 0..3,
the 16 transform coefficient levels of the i4x4-th block are parsed into the (i8x8 * 4 + i4x4)-th list
level4x4[ i8x8 * 4 + i4x4 ]. Then, the 64 transform coefficient levels of the i8x8-th 8x8 luma block which
are indexed by 4 * i + i4x4, where i = 0..15 and i4x4 = 0..3, are derived as level8x8[ i8x8 ][ 4 * i + i4x4 ] =
level4x4[ i8x8 * 4 + i4x4 ][ i ].

NOTE – The 4x4 luma blocks with luma4x4BlkIdx = i8x8 * 4 + i4x4 containing every fourth transform coefficient
level of the corresponding i8x8-th 8x8 luma block with offset i4x4 are assumed to represent spatial locations given by
the inverse 4x4 luma block scanning process in clause 6.4.3.

      - Otherwise (entropy_coding_mode_flag is equal to 1), the 64 transform coefficient levels of the i8x8-th
block are parsed into the i8x8-th list level8x8[ i8x8 ].


**7.4.5.3.2** **Residual block CAVLC semantics**


The function TotalCoeff( coeff_token ) that is used in clause 7.3.5.3.2 returns the number of non-zero transform coefficient
levels derived from coeff_token.


The function TrailingOnes( coeff_token ) that is used in clause 7.3.5.3.2 returns the trailing ones derived from coeff_token.


**coeff_token** specifies the total number of non-zero transform coefficient levels and the number of trailing one transform
coefficient levels in a transform coefficient level scan. A trailing one transform coefficient level is one of up to three
consecutive non-zero transform coefficient levels having an absolute value equal to 1 at the end of a scan of non-zero
transform coefficient levels. The range of coeff_token is specified in clause 9.2.1.


**trailing_ones_sign_flag** specifies the sign of a trailing one transform coefficient level as follows:


- If trailing_ones_sign_flag is equal to 0, the corresponding transform coefficient level is decoded as +1.


- Otherwise (trailing_ones_sign_flag equal to 1), the corresponding transform coefficient level is decoded as −1.


**level_prefix** and **level_suffix** specify the value of a non-zero transform coefficient level. The range of level_prefix and
level_suffix is specified in clause 9.2.2.


**total_zeros** specifies the total number of zero-valued transform coefficient levels that are located before the position of
the last non-zero transform coefficient level in a scan of transform coefficient levels. The range of total_zeros is specified
in clause 9.2.3.


**run_before** specifies the number of consecutive transform coefficient levels in the scan with zero value before a non-zero
valued transform coefficient level. The range of run_before is specified in clause 9.2.3.


coeffLevel contains maxNumCoeff transform coefficient levels for the current list of transform coefficient levels.


**7.4.5.3.3** **Residual block CABAC semantics**


**coded_block_flag** specifies whether the transform block contains non-zero transform coefficient levels as follows:


- If coded_block_flag is equal to 0, the transform block contains no non-zero transform coefficient levels.


- Otherwise (coded_block_flag is equal to 1), the transform block contains at least one non-zero transform coefficient
level.


When coded_block_flag is not present, it shall be inferred to be equal to 1.


**significant_coeff_flag[** i **]** specifies whether the transform coefficient level at scanning position i is non-zero as follows:


- If significant_coeff_flag[ i ] is equal to 0, the transform coefficient level at scanning position i is set equal to 0;


- Otherwise (significant_coeff_flag[ i ] is equal to 1), the transform coefficient level at scanning position i has a
non-zero value.





**last_significant_coeff_flag[** i **]** specifies for the scanning position i whether there are non-zero transform coefficient levels
for subsequent scanning positions i + 1 to maxNumCoeff − 1 as follows:


- If last_significant_coeff_flag[ i ] is equal to 1, all following transform coefficient levels (in scanning order) of the
block have value equal to 0.


- Otherwise (last_significant_coeff_flag[ i ] is equal to 0), there are further non-zero transform coefficient levels along
the scanning path.


**coeff_abs_level_minus1[** i **]** is the absolute value of a transform coefficient level minus 1. The value of
coeff_abs_level_minus1 is constrained by the limits in clause 8.5.


**coeff_sign_flag[** i **]** specifies the sign of a transform coefficient level as follows:


- If coeff_sign_flag is equal to 0, the corresponding transform coefficient level has a positive value.


- Otherwise (coeff_sign_flag is equal to 1), the corresponding transform coefficient level has a negative value.


coeffLevel contains maxNumCoeff transform coefficient levels for the current list of transform coefficient levels.
