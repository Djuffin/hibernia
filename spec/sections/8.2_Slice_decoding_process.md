**8.2** **Slice decoding process**


**8.2.1** **Decoding process for picture order count**


Outputs of this process are TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if applicable).


Picture order counts are used to determine initial picture orderings for reference pictures in the decoding of B slices (see
clauses 8.2.4.2.3 and 8.2.4.2.4), to determine co-located pictures (see clause 8.4.1.2.1) for deriving motion parameters in
temporal or spatial direct mode, to represent picture order differences between frames or fields for motion vector derivation
in temporal direct mode (see clause 8.4.1.2.3), for implicit mode weighted prediction in B slices (see clause 8.4.2.3.2), and
for decoder conformance checking (see clause C.4).


Picture order count information is derived for every frame, field (whether decoded from a coded field or as a part of a
decoded frame), or complementary field pair as follows:


- Each coded frame is associated with two picture order counts, called TopFieldOrderCnt and BottomFieldOrderCnt
for its top field and bottom field, respectively.


- Each coded field is associated with a picture order count, called TopFieldOrderCnt for a coded top field and
BottomFieldOrderCnt for a bottom field.


- Each complementary field pair is associated with two picture order counts, which are the TopFieldOrderCnt for its
coded top field and the BottomFieldOrderCnt for its coded bottom field, respectively.


TopFieldOrderCnt and BottomFieldOrderCnt indicate the picture order of the corresponding top field or bottom field
relative to the first output field of the previous IDR picture or the previous reference picture including a
memory_management_control_operation equal to 5 in decoding order.


TopFieldOrderCnt and BottomFieldOrderCnt are derived by invoking one of the decoding processes for picture order
count type 0, 1, and 2 in clauses 8.2.1.1, 8.2.1.2, and 8.2.1.3, respectively. When the current picture includes a
memory_management_control_operation equal to 5, after the decoding of the current picture, tempPicOrderCnt is set equal
to PicOrderCnt( CurrPic ), TopFieldOrderCnt of the current picture (if any) is set equal to
TopFieldOrderCnt − tempPicOrderCnt, and BottomFieldOrderCnt of the current picture (if any) is set equal to
BottomFieldOrderCnt − tempPicOrderCnt.

NOTE 1 – When the decoding process for a picture currPic that includes a memory_management_control_operation equal to 5 refers
to the values of TopFieldOrderCnt (if applicable) or BottomFieldOrderCnt (if applicable) for the picture currPic (including
references to the function PicOrderCnt( ) with the picture currPic as the argument and references to the function DiffPicOrderCnt( )
with one of the arguments being currPic), the values of TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if applicable)
that are derived as specified in clauses 8.2.1.1, 8.2.1.2, and 8.2.1.3 for the picture currPic are used. When the decoding process for
a picture refers to the values TopFieldOrderCnt (if applicable) or BottomFieldOrderCnt (if applicable) of the previous picture
prevMmco5Pic in decoding order that includes a memory_management_control_operation equal to 5 (including references via the
functions PicOrderCnt( ) or DiffPicOrderCnt( )), the values of TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if
applicable) that are used for the picture prevMmco5Pic are the values after the modification specified in the paragraph above
(resulting in TopFieldOrderCnt and/or BottomFieldOrderCnt equal to 0).


The bitstream shall not contain data that result in Min( TopFieldOrderCnt, BottomFieldOrderCnt ) not equal to 0 for a
coded IDR frame, TopFieldOrderCnt not equal to 0 for a coded IDR top field, or BottomFieldOrderCnt not equal to 0 for
a coded IDR bottom field. Thus, at least one of TopFieldOrderCnt and BottomFieldOrderCnt shall be equal to 0 for the
fields of a coded IDR frame.


When the current picture is not an IDR picture, the following applies:


1) Consider the list variable listD containing as elements the TopFieldOrderCnt and BottomFieldOrderCnt values

associated with the list of pictures including all of the following:

a. The first picture in the list is the previous picture of any of the following types:

        - an IDR picture,

        - a picture containing a memory_management_control_operation equal to 5.

b. The following additional pictures:

        - If pic_order_cnt_type is equal to 0, all other pictures that follow in decoding order after the first picture

in the list and are not "non-existing" frames inferred by the decoding process for gaps in frame_num
specified in clause 8.2.5.2 and either precede the current picture in decoding order or are the current
picture. When pic_order_cnt_type is equal to 0 and the current picture is not a "non-existing" frame
inferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2, the current picture
is included in listD prior to the invoking of the decoded reference picture marking process.

        - Otherwise (pic_order_cnt_type is not equal to 0), all other pictures that follow in decoding order after

the first picture in the list and either precede the current picture in decoding order or are the current





picture. When pic_order_cnt_type is not equal to 0, the current picture is included in listD prior to the
invoking of the decoded reference picture marking process.


2) Consider the list variable listO which contains the elements of listD sorted in ascending order. listO shall not

contain any of the following:

      - a pair of TopFieldOrderCnt and BottomFieldOrderCnt for a frame or complementary field pair that are not
at consecutive positions in listO,

      - a TopFieldOrderCnt that has a value equal to another TopFieldOrderCnt,

      - a BottomFieldOrderCnt that has a value equal to another BottomFieldOrderCnt,

      - a BottomFieldOrderCnt that has a value equal to a TopFieldOrderCnt unless the BottomFieldOrderCnt and
TopFieldOrderCnt belong to the same coded frame or complementary field pair.


The bitstream shall not contain data that result in values of TopFieldOrderCnt, BottomFieldOrderCnt, PicOrderCntMsb,
or FrameNumOffset used in the decoding process as specified in clauses 8.2.1.1 to 8.2.1.3 that exceed the range of values
from −2 [31] to 2 [31] - 1, inclusive.


The function PicOrderCnt( picX ) is specified as follows:


if( picX is a frame or a complementary field pair )
PicOrderCnt( picX ) = Min( TopFieldOrderCnt, BottomFieldOrderCnt ) of the frame or complementary field
pair picX
else if( picX is a top field )
PicOrderCnt( picX ) = TopFieldOrderCnt of field picX (8-1)
else if( picX is a bottom field )
PicOrderCnt( picX ) = BottomFieldOrderCnt of field picX


Then DiffPicOrderCnt( picA, picB ) is specified as follows:


DiffPicOrderCnt( picA, picB ) = PicOrderCnt( picA ) − PicOrderCnt( picB ) (8-2)


The bitstream shall not contain data that result in values of DiffPicOrderCnt( picA, picB ) used in the decoding process
that exceed the range of −2 [15] to 2 [15] - 1, inclusive.

NOTE 2 – Let X be the current picture and Y and Z be two other pictures in the same sequence, Y and Z are considered to be in the
same output order direction from X when both DiffPicOrderCnt( X, Y ) and DiffPicOrderCnt( X, Z ) are positive or both are negative.
NOTE 3 – Many encoders assign TopFieldOrderCnt and BottomFieldOrderCnt proportional to the sampling time of the
corresponding field (which is either a coded field or a field of a coded frame) relative to the sampling time of the first output field
of the previous IDR picture or the previous reference picture (in decoding order) that includes a
memory_management_control_operation equal to 5.


When the current picture includes a memory_management_control_operation equal to 5, PicOrderCnt( CurrPic ) shall be
greater than PicOrderCnt( any other picture in listD ).


**8.2.1.1** **Decoding process for picture order count type 0**


This process is invoked when pic_order_cnt_type is equal to 0.


Input to this process is PicOrderCntMsb of the previous reference picture in decoding order as specified in this clause.


Outputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt.


The variables prevPicOrderCntMsb and prevPicOrderCntLsb are derived as follows:


- If the current picture is an IDR picture, prevPicOrderCntMsb is set equal to 0 and prevPicOrderCntLsb is set equal
to 0.


- Otherwise (the current picture is not an IDR picture), the following applies:


   - If the previous reference picture in decoding order included a memory_management_control_operation equal
to 5, the following applies:


      - If the previous reference picture in decoding order is not a bottom field, prevPicOrderCntMsb is set equal
to 0 and prevPicOrderCntLsb is set equal to the value of TopFieldOrderCnt for the previous reference
picture in decoding order.


      - Otherwise (the previous reference picture in decoding order is a bottom field), prevPicOrderCntMsb is set
equal to 0 and prevPicOrderCntLsb is set equal to 0.





   - Otherwise (the previous reference picture in decoding order did not include a
memory_management_control_operation equal to 5), prevPicOrderCntMsb is set equal to PicOrderCntMsb of
the previous reference picture in decoding order and prevPicOrderCntLsb is set equal to the value of
pic_order_cnt_lsb of the previous reference picture in decoding order.


PicOrderCntMsb of the current picture is derived as specified by the following pseudo-code:


if( ( pic_order_cnt_lsb < prevPicOrderCntLsb ) &&
( ( prevPicOrderCntLsb − pic_order_cnt_lsb ) >= ( MaxPicOrderCntLsb / 2 ) ) )
PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb (8-3)
else if( ( pic_order_cnt_lsb > prevPicOrderCntLsb ) &&
( ( pic_order_cnt_lsb − prevPicOrderCntLsb ) > ( MaxPicOrderCntLsb / 2 ) ) )
PicOrderCntMsb = prevPicOrderCntMsb − MaxPicOrderCntLsb
else
PicOrderCntMsb = prevPicOrderCntMsb


When the current picture is not a bottom field, TopFieldOrderCnt is derived as


TopFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb (8-4)


When the current picture is not a top field, BottomFieldOrderCnt is derived as specified by the following pseudo-code:


if( !field_pic_flag )
BottomFieldOrderCnt = TopFieldOrderCnt + delta_pic_order_cnt_bottom
else (8-5)
BottomFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb


**8.2.1.2** **Decoding process for picture order count type 1**


This process is invoked when pic_order_cnt_type is equal to 1.


Input to this process is FrameNumOffset of the previous picture in decoding order as specified in this clause.


Outputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt.


The values of TopFieldOrderCnt and BottomFieldOrderCnt are derived as specified in this clause. Let prevFrameNum be
equal to the frame_num of the previous picture in decoding order.


When the current picture is not an IDR picture, the variable prevFrameNumOffset is derived as follows:


- If the previous picture in decoding order included a memory_management_control_operation equal to 5,
prevFrameNumOffset is set equal to 0.


- Otherwise (the previous picture in decoding order did not include a memory_management_control_operation equal
to 5), prevFrameNumOffset is set equal to the value of FrameNumOffset of the previous picture in decoding order.
NOTE – When gaps_in_frame_num_value_allowed_flag is equal to 1, the previous picture in decoding order may be a
"non-existing" frame inferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2.


The variable FrameNumOffset is derived as specified by the following pseudo-code:


if( IdrPicFlag = = 1 )
FrameNumOffset = 0
else if( prevFrameNum > frame_num ) (8-6)
FrameNumOffset = prevFrameNumOffset + MaxFrameNum
else
FrameNumOffset = prevFrameNumOffset


The variable absFrameNum is derived as specified by the following pseudo-code:


if( num_ref_frames_in_pic_order_cnt_cycle != 0 )
absFrameNum = FrameNumOffset + frame_num
else (8-7)
absFrameNum = 0
if( nal_ref_idc = = 0 && absFrameNum > 0 )
absFrameNum = absFrameNum −  115


When absFrameNum > 0, picOrderCntCycleCnt and frameNumInPicOrderCntCycle are derived as


picOrderCntCycleCnt = ( absFrameNum − 1 ) / num_ref_frames_in_pic_order_cnt_cycle
frameNumInPicOrderCntCycle = ( absFrameNum − 1 ) % num_ref_frames_in_pic_order_cnt_cycle (8-8)


The variable expectedPicOrderCnt is derived as specified by the following pseudo-code:


if( absFrameNum > 0 ) {
expectedPicOrderCnt = picOrderCntCycleCnt * ExpectedDeltaPerPicOrderCntCycle
for( i = 0; i <= frameNumInPicOrderCntCycle; i++ )
expectedPicOrderCnt = expectedPicOrderCnt + offset_for_ref_frame[ i ]
} else
expectedPicOrderCnt = 0
if( nal_ref_idc = = 0 ) (8-9)
expectedPicOrderCnt = expectedPicOrderCnt + offset_for_non_ref_pic


The variables TopFieldOrderCnt or BottomFieldOrderCnt are derived as specified by the following pseudo-code:


if( !field_pic_flag ) {
TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ]
BottomFieldOrderCnt = TopFieldOrderCnt +
offset_for_top_to_bottom_field + delta_pic_order_cnt[ 1 ] (8-10)
} else if( !bottom_field_flag )
TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ]
else
BottomFieldOrderCnt = expectedPicOrderCnt + offset_for_top_to_bottom_field + delta_pic_order_cnt[ 0 ]


**8.2.1.3** **Decoding process for picture order count type 2**


This process is invoked when pic_order_cnt_type is equal to 2.


Outputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt.


Let prevFrameNum be equal to the frame_num of the previous picture in decoding order.


When the current picture is not an IDR picture, the variable prevFrameNumOffset is derived as follows:


- If the previous picture in decoding order included a memory_management_control_operation equal to 5,
prevFrameNumOffset is set equal to 0.


- Otherwise (the previous picture in decoding order did not include a memory_management_control_operation equal
to 5), prevFrameNumOffset is set equal to the value of FrameNumOffset of the previous picture in decoding order.
NOTE 1 – When gaps_in_frame_num_value_allowed_flag is equal to 1, the previous picture in decoding order may be a
"non-existing" frame inferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2.


The variable FrameNumOffset is derived as specified by the following pseudo-code:


if( IdrPicFlag = = 1 )
FrameNumOffset = 0
else if( prevFrameNum > frame_num ) (8-11)
FrameNumOffset = prevFrameNumOffset + MaxFrameNum
else
FrameNumOffset = prevFrameNumOffset


The variable tempPicOrderCnt is derived as specified by the following pseudo-code:


if( IdrPicFlag = = 1 )
tempPicOrderCnt = 0
else if( nal_ref_idc = = 0 ) (8-12)
tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num ) − 1
else
tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num )





The variables TopFieldOrderCnt or BottomFieldOrderCnt are derived as specified by the following pseudo-code:


if( !field_pic_flag ) {
TopFieldOrderCnt = tempPicOrderCnt
BottomFieldOrderCnt = tempPicOrderCnt (8-13)
} else if( bottom_field_flag )
BottomFieldOrderCnt = tempPicOrderCnt
else
TopFieldOrderCnt = tempPicOrderCnt


NOTE 2 – Picture order count type 2 cannot be used in a coded video sequence that contains consecutive non-reference pictures that
would result in more than one of these pictures having the same value of TopFieldOrderCnt or more than one of these pictures
having the same value of BottomFieldOrderCnt.
NOTE 3 – Picture order count type 2 results in an output order that is the same as the decoding order.


**8.2.2** **Decoding process for macroblock to slice group map**


Inputs to this process are the active picture parameter set and the slice header of the slice to be decoded.


Output of this process is a macroblock to slice group map MbToSliceGroupMap.


This process is invoked at the start of every slice.

NOTE – The output of this process is equal for all slices of a picture.


When num_slice_groups_minus1 is equal to 1 and slice_group_map_type is equal to 3, 4, or 5, slice groups 0 and 1 have
a size and shape determined by slice_group_change_direction_flag as shown in Table 8-1 and specified in clauses 8.2.2.4
to 8.2.2.6.


**Table 8-1 – Refined slice group map type**

|slice_group_map_type|slice_group_change_direction_flag|refined slice group map type|
|---|---|---|
|3|0|Box-out clockwise|
|3|1|Box-out counter-clockwise|
|4|0|Raster scan|
|4|1|Reverse raster scan|
|5|0|Wipe right|
|5|1|Wipe left|



In such a case, MapUnitsInSliceGroup0 slice group map units in the specified growth order are allocated for slice group 0
and the remaining PicSizeInMapUnits − MapUnitsInSliceGroup0 slice group map units of the picture are allocated for
slice group 1.


When num_slice_groups_minus1 is equal to 1 and slice_group_map_type is equal to 4 or 5, the variable
sizeOfUpperLeftGroup is defined as follows:


sizeOfUpperLeftGroup = ( slice_group_change_direction_flag ?
( PicSizeInMapUnits − MapUnitsInSliceGroup0 ) : MapUnitsInSliceGroup0 ) (8-14)


The mapUnitToSliceGroupMap array is derived as follows:


- If num_slice_groups_minus1 is equal to 0, the map unit to slice group map is generated for all i ranging from 0 to
PicSizeInMapUnits − 1, inclusive, as specified by


mapUnitToSliceGroupMap[ i ] = 0 (8-15)


- Otherwise (num_slice_groups_minus1 is not equal to 0), mapUnitToSliceGroupMap is derived as follows:

    - If slice_group_map_type is equal to 0, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.1 applies.

    - Otherwise, if slice_group_map_type is equal to 1, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.2 applies.

    - Otherwise, if slice_group_map_type is equal to 2, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.3 applies.





    - Otherwise, if slice_group_map_type is equal to 3, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.4 applies.

    - Otherwise, if slice_group_map_type is equal to 4, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.5 applies.

    - Otherwise, if slice_group_map_type is equal to 5, the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.6 applies.

    - Otherwise (slice_group_map_type is equal to 6), the derivation of mapUnitToSliceGroupMap as specified in
clause 8.2.2.7 applies.


After derivation of the mapUnitToSliceGroupMap, the process specified in clause 8.2.2.8 is invoked to convert the map
unit to slice group map mapUnitToSliceGroupMap to the macroblock to slice group map MbToSliceGroupMap. After
derivation of the macroblock to slice group map as specified in clause 8.2.2.8, the function NextMbAddress( n ) is defined
as the value of the variable nextMbAddress derived as specified by the following pseudo-code:


i = n + 1
while( i < PicSizeInMbs && MbToSliceGroupMap[ i ] != MbToSliceGroupMap[ n ] )
i++;
nextMbAddress = i (8-16)


**8.2.2.1** **Specification for interleaved slice group map type**


The specifications in this clause apply when slice_group_map_type is equal to 0.


The map unit to slice group map is generated as specified by the following pseudo-code:


i = 0
do
for( iGroup = 0; iGroup <= num_slice_groups_minus1 && i < PicSizeInMapUnits;
i += run_length_minus1[ iGroup++ ] + 1 )
for( j = 0; j <= run_length_minus1[ iGroup ] && i + j < PicSizeInMapUnits; j++ )
mapUnitToSliceGroupMap[ i + j ] = iGroup (8-17)
while( i < PicSizeInMapUnits )


**8.2.2.2** **Specification for dispersed slice group map type**


The specifications in this clause apply when slice_group_map_type is equal to 1.


The map unit to slice group map is generated as specified by the following pseudo-code:


for( i = 0; i < PicSizeInMapUnits; i++ )
mapUnitToSliceGroupMap[ i ] = ( ( i % PicWidthInMbs ) +
( ( ( i / PicWidthInMbs ) * ( num_slice_groups_minus1 + 1 ) ) / 2 ) )
% ( num_slice_groups_minus1 + 1 ) (8-18)


**8.2.2.3** **Specification for foreground with left-over slice group map type**


The specifications in this clause apply when slice_group_map_type is equal to 2.


The map unit to slice group map is generated as specified by the following pseudo-code:


for( i = 0; i < PicSizeInMapUnits; i++ )
mapUnitToSliceGroupMap[ i ] = num_slice_groups_minus1
for( iGroup = num_slice_groups_minus1 − 1; iGroup >= 0; iGroup− − ) {
yTopLeft = top_left[ iGroup ] / PicWidthInMbs
xTopLeft = top_left[ iGroup ] % PicWidthInMbs
yBottomRight = bottom_right[ iGroup ] / PicWidthInMbs
xBottomRight = bottom_right[ iGroup ] % PicWidthInMbs
for( y = yTopLeft; y <= yBottomRight; y++ )
for( x = xTopLeft; x <= xBottomRight; x++ )
mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ] = iGroup (8-19)
}


NOTE – The rectangles may overlap. Slice group 0 contains the macroblocks that are within the rectangle specified by top_left[ 0 ]
and bottom_right[ 0 ]. A slice group having slice group ID greater than 0 and less than num_slice_groups_minus1 contains the
macroblocks that are within the specified rectangle for that slice group that are not within the rectangle specified for any slice group





having a smaller slice group ID. The slice group with slice group ID equal to num_slice_groups_minus1 contains the macroblocks
that are not in the other slice groups.


**8.2.2.4** **Specification for box-out slice group map types**


The specifications in this clause apply when slice_group_map_type is equal to 3.


The map unit to slice group map is generated as specified by


for( i = 0; i < PicSizeInMapUnits; i++ )
mapUnitToSliceGroupMap[ i ] = 1
x = ( PicWidthInMbs − slice_group_change_direction_flag ) / 2
y = ( PicHeightInMapUnits − slice_group_change_direction_flag ) / 2
( leftBound, topBound ) = ( x, y )
( rightBound, bottomBound ) = ( x, y )
( xDir, yDir ) = ( slice_group_change_direction_flag − 1, slice_group_change_direction_flag )
for( k = 0; k < MapUnitsInSliceGroup0; k += mapUnitVacant ) {
mapUnitVacant = ( mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ] = = 1 )
if( mapUnitVacant )
mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ] = 0 (8-20)
if( xDir = = −1 && x = = leftBound ) {
leftBound = Max( leftBound − 1, 0 )
x = leftBound
( xDir, yDir ) = ( 0, 2 * slice_group_change_direction_flag − 1 )
} else if( xDir = = 1 && x = = rightBound ) {
rightBound = Min( rightBound + 1, PicWidthInMbs − 1 )
x = rightBound
( xDir, yDir ) = ( 0, 1 − 2 * slice_group_change_direction_flag )
} else if( yDir = = −1 && y = = topBound ) {
topBound = Max( topBound − 1, 0 )
y = topBound
( xDir, yDir ) = ( 1 − 2 * slice_group_change_direction_flag, 0 )
} else if( yDir = = 1 && y = = bottomBound ) {
bottomBound = Min( bottomBound + 1, PicHeightInMapUnits − 1 )
y = bottomBound
( xDir, yDir ) = ( 2 * slice_group_change_direction_flag − 1, 0 )
} else
( x, y ) = ( x + xDir, y + yDir )
}


**8.2.2.5** **Specification for raster scan slice group map types**


The specifications in this clause apply when slice_group_map_type is equal to 4.


The map unit to slice group map is generated as specified by


for( i = 0; i < PicSizeInMapUnits; i++ )
if( i < sizeOfUpperLeftGroup )
mapUnitToSliceGroupMap[ i ] = slice_group_change_direction_flag
else (8-21)
mapUnitToSliceGroupMap[ i ] = 1 − slice_group_change_direction_flag


**8.2.2.6** **Specification for wipe slice group map types**


The specifications in this clause apply when slice_group_map_type is equal to 5.


The map unit to slice group map is generated as specified by


k = 0;
for( j = 0; j < PicWidthInMbs; j++ )
for( i = 0; i < PicHeightInMapUnits; i++ )
if( k++ < sizeOfUpperLeftGroup )
mapUnitToSliceGroupMap[ i * PicWidthInMbs + j ] = slice_group_change_direction_flag
else (8-22)
mapUnitToSliceGroupMap[ i * PicWidthInMbs + j ] = 1 − slice_group_change_direction_flag





**8.2.2.7** **Specification for explicit slice group map type**


The specifications in this clause apply when slice_group_map_type is equal to 6.


The map unit to slice group map is generated as specified by


mapUnitToSliceGroupMap[ i ] = slice_group_id[ i ] (8-23)


for all i ranging from 0 to PicSizeInMapUnits − 1, inclusive.


**8.2.2.8** **Specification for conversion of map unit to slice group map to macroblock to slice group map**


For each value of i ranging from 0 to PicSizeInMbs − 1, inclusive, the macroblock to slice group map is specified as
follows:

- If frame_mbs_only_flag is equal to 1 or field_pic_flag is equal to 1, the macroblock to slice group map is specified
by


MbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ i ] (8-24)


- Otherwise, if MbaffFrameFlag is equal to 1, the macroblock to slice group map is specified by


MbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ i / 2 ] (8-25)


- Otherwise (frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 0 and field_pic_flag is
equal to 0), the macroblock to slice group map is specified by


MbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ ( i / ( 2 * PicWidthInMbs ) ) * PicWidthInMbs
+ ( i % PicWidthInMbs ) ] (8-26)


**8.2.3** **Decoding process for slice data partitions**


Inputs to this process are:

- a slice data partition A layer RBSP,

- when syntax elements of category 3 are present in the slice data, a slice data partition B layer RBSP having the same
slice_id as in the slice data partition A layer RBSP,

- when syntax elements of category 4 are present in the slice data, a slice data partition C layer RBSP having the same
slice_id as in the slice data partition A layer RBSP.
NOTE 1 – The slice data partition B layer RBSP and slice data partition C layer RBSP need not be present.


Output of this process is a coded slice.


When slice data partitioning is not used, coded slices are represented by a slice layer without partitioning RBSP that
contains a slice header followed by a slice data syntax structure that contains all the syntax elements of categories 2, 3, and
4 (see category column in clause 7.3) of the macroblock data for the macroblocks of the slice.


When slice data partitioning is used, the macroblock data of a slice is partitioned into one to three partitions contained in
separate NAL units. Partition A contains a slice data partition A header, and all syntax elements of category 2. Partition B,
when present, contains a slice data partition B header and all syntax elements of category 3. Partition C, when present,
contains a slice data partition C header and all syntax elements of category 4.


When slice data partitioning is used, the syntax elements of each category are parsed from a separate NAL unit, which
need not be present when no symbols of the respective category exist. The decoding process shall process the slice data
partitions of a coded slice in a manner equivalent to processing a corresponding slice layer without partitioning RBSP by
extracting each syntax element from the slice data partition in which the syntax element appears depending on the slice
data partition assignment in the syntax tables in clause 7.3.

NOTE 2 – Syntax elements of category 3 are relevant to the decoding of residual data of I and SI macroblock types. Syntax elements
of category 4 are relevant to the decoding of residual data of P and B macroblock types. Category 2 encompasses all other syntax
elements related to the decoding of macroblocks, and their information is often denoted as header information. The slice data
partition A header contains all the syntax elements of the slice header, and additionally a slice_id that are used to associate the slice
data partitions B and C with the slice data partition A. The slice data partition B and C headers contain the slice_id syntax element
that establishes their association with the slice data partition A of the slice.





**8.2.4** **Decoding process for reference picture lists construction**


This process is invoked at the beginning of the decoding process for each P, SP, or B slice.


Decoded reference pictures are marked as "used for short-term reference" or "used for long-term reference" as specified
by the bitstream and specified in clause 8.2.5. Short-term reference pictures are identified by the value of frame_num.
Long-term reference pictures are assigned a long-term frame index as specified by the bitstream and specified in
clause 8.2.5.


Clause 8.2.4.1 is invoked to specify


- the assignment of variables FrameNum, FrameNumWrap, and PicNum to each of the short-term reference pictures,

and


- the assignment of variable LongTermPicNum to each of the long-term reference pictures.


Reference pictures are addressed through reference indices as specified in clause 8.4.2.1. A reference index is an index
into a reference picture list. When decoding a P or SP slice, there is a single reference picture list RefPicList0. When
decoding a B slice, there is a second independent reference picture list RefPicList1 in addition to RefPicList0.


At the beginning of the decoding process for each slice, reference picture list RefPicList0, and for B slices RefPicList1,
are derived as specified by the following ordered steps:


1. An initial reference picture list RefPicList0 and for B slices RefPicList1 are derived as specified in clause 8.2.4.2.


2. When ref_pic_list_modification_flag_l0 is equal to 1 or, when decoding a B slice,
ref_pic_list_modification_flag_l1 is equal to 1, the initial reference picture list RefPicList0 and, for B slices,
RefPicList1 are modified as specified in clause 8.2.4.3.

NOTE – The modification process for reference picture lists specified in clause 8.2.4.3 allows the contents of
RefPicList0 and for B slices RefPicList1 to be modified in a flexible fashion. In particular, it is possible for a picture
that is currently marked "used for reference" to be inserted into RefPicList0 and for B slices RefPicList1 even when the
picture is not in the initial reference picture list derived as specified in clause 8.2.4.2.


The number of entries in the modified reference picture list RefPicList0 is num_ref_idx_l0_active_minus1 + 1, and for B
slices the number of entries in the modified reference picture list RefPicList1 is num_ref_idx_l1_active_minus1 + 1. A
reference picture may appear at more than one index in the modified reference picture lists RefPicList0 or RefPicList1.


**8.2.4.1** **Decoding process for picture numbers**


This process is invoked when the decoding process for reference picture lists construction specified in clause 8.2.4, the
decoded reference picture marking process specified in clause 8.2.5, or the decoding process for gaps in frame_num
specified in clause 8.2.5.2 is invoked.


The variables FrameNum, FrameNumWrap, PicNum, LongTermFrameIdx, and LongTermPicNum are used for the
initialization process for reference picture lists in clause 8.2.4.2, the modification process for reference picture lists in
clause 8.2.4.3, the decoded reference picture marking process in clause 8.2.5, and the decoding process for gaps in
frame_num in clause 8.2.5.2.


To each short-term reference picture the variables FrameNum and FrameNumWrap are assigned as follows. First,
FrameNum is set equal to the syntax element frame_num that has been decoded in the slice header(s) of the corresponding
short-term reference picture. Then the variable FrameNumWrap is derived as


if( FrameNum > frame_num )
FrameNumWrap = FrameNum − MaxFrameNum (8-27)
else
FrameNumWrap = FrameNum


where the value of frame_num used in Equation 8-27 is the frame_num in the slice header(s) for the current picture.


Each long-term reference picture has an associated value of LongTermFrameIdx (that was assigned to it as specified in
clause 8.2.5).


To each short-term reference picture a variable PicNum is assigned, and to each long-term reference picture a variable
LongTermPicNum is assigned. The values of these variables depend on the value of field_pic_flag and bottom_field_flag
for the current picture and they are set as follows:





- If field_pic_flag is equal to 0, the following ordered steps are specified:


1. For each short-term reference frame or complementary reference field pair:


PicNum = FrameNumWrap (8-28)


2. For each long-term reference frame or long-term complementary reference field pair:


LongTermPicNum = LongTermFrameIdx (8-29)


NOTE – When decoding a frame the value of MbaffFrameFlag has no influence on the derivations in
clauses 8.2.4.2, 8.2.4.3, and 8.2.5.


- Otherwise (field_pic_flag is equal to 1), the following ordered steps are specified:


1. For each short-term reference field the following applies:


        - If the reference field has the same parity as the current field


PicNum = 2 * FrameNumWrap + 1 (8-30)


        - Otherwise (the reference field has the opposite parity of the current field),


PicNum = 2 * FrameNumWrap (8-31)


2. For each long-term reference field the following applies:


        - If the reference field has the same parity as the current field


LongTermPicNum = 2 * LongTermFrameIdx + 1 (8-32)


        - Otherwise (the reference field has the opposite parity of the current field),


LongTermPicNum = 2 * LongTermFrameIdx (8-33)


**8.2.4.2** **Initialization process for reference picture lists**


This initialization process is invoked when decoding a P, SP, or B slice header.


RefPicList0 and RefPicList1 have initial entries as specified in clauses 8.2.4.2.1 through 8.2.4.2.5.


When the number of entries in the initial RefPicList0 or RefPicList1 produced as specified in clauses 8.2.4.2.1 through
8.2.4.2.5 is greater than num_ref_idx_l0_active_minus1 + 1 or num_ref_idx_l1_active_minus1 + 1, respectively, the extra
entries past position num_ref_idx_l0_active_minus1 or num_ref_idx_l1_active_minus1 are discarded from the initial
reference picture list.


When the number of entries in the initial RefPicList0 or RefPicList1 produced as specified in clauses 8.2.4.2.1 through
8.2.4.2.5 is less than num_ref_idx_l0_active_minus1 + 1 or num_ref_idx_l1_active_minus1 + 1, respectively, the
remaining entries in the initial reference picture list are set equal to "no reference picture".


**8.2.4.2.1** **Initialization process for the reference picture list for P and SP slices in frames**


This initialization process is invoked when decoding a P or SP slice in a coded frame.


When this process is invoked, there shall be at least one reference frame or complementary reference field pair that is
currently marked as "used for reference" (i.e., as "used for short-term reference" or "used for long-term reference") and is
not marked as "non-existing".


The reference picture list RefPicList0 is ordered so that short-term reference frames and short-term complementary
reference field pairs have lower indices than long-term reference frames and long-term complementary reference field
pairs.


The short-term reference frames and complementary reference field pairs are ordered starting with the frame or
complementary field pair with the highest PicNum value and proceeding through in descending order to the frame or
complementary field pair with the lowest PicNum value.


The long-term reference frames and complementary reference field pairs are ordered starting with the frame or
complementary field pair with the lowest LongTermPicNum value and proceeding through in ascending order to the frame
or complementary field pair with the highest LongTermPicNum value.





NOTE – A non-paired reference field is not used for inter prediction for decoding a frame, regardless of the value of
MbaffFrameFlag.


For example, when three reference frames are marked as "used for short-term reference" with PicNum equal to 300, 302,
and 303 and two reference frames are marked as "used for long-term reference" with LongTermPicNum equal to 0 and 3,
the initial index order is:


- RefPicList0[ 0 ] is set equal to the short-term reference picture with PicNum = 303,


- RefPicList0[ 1 ] is set equal to the short-term reference picture with PicNum = 302,


- RefPicList0[ 2 ] is set equal to the short-term reference picture with PicNum = 300,


- RefPicList0[ 3 ] is set equal to the long-term reference picture with LongTermPicNum = 0,


- RefPicList0[ 4 ] is set equal to the long-term reference picture with LongTermPicNum = 3.


**8.2.4.2.2** **Initialization process for the reference picture list for P and SP slices in fields**


This initialization process is invoked when decoding a P or SP slice in a coded field.


When this process is invoked, there shall be at least one reference field (which can be a field of a reference frame) that is
currently marked as "used for reference" (i.e., as "used for short-term reference" or "used for long-term reference") and is
not marked as "non-existing".


Each field included in the reference picture list RefPicList0 has a separate index in the reference picture list RefPicList0.

NOTE – When decoding a field, there are effectively at least twice as many pictures available for referencing as there would be
when decoding a frame at the same position in decoding order.


Two ordered lists of reference frames, refFrameList0ShortTerm and refFrameList0LongTerm, are derived as follows. For
purposes of the formation of this list of frames, decoded reference frames, complementary reference field pairs, non-paired
reference fields and reference frames in which a single field is marked "used for short-term reference" or "used for longterm reference" are all considered reference frames.


1. All frames having one or more fields marked "used for short-term reference" are included in the list of short-term

reference frames refFrameList0ShortTerm. When the current field is the second field (in decoding order) of a
complementary reference field pair and the first field is marked as "used for short-term reference", the first field is
included in the list of short-term reference frames refFrameList0ShortTerm. refFrameList0ShortTerm is ordered
starting with the reference frame with the highest FrameNumWrap value and proceeding through in descending
order to the reference frame with the lowest FrameNumWrap value.


2. All frames having one or more fields marked "used for long-term reference" are included in the list of long-term

reference frames refFrameList0LongTerm. When the current field is the second field (in decoding order) of a
complementary reference field pair and the first field is marked as "used for long-term reference, the first field is
included in the list of long-term reference frames refFrameList0LongTerm. refFrameList0LongTerm is ordered
starting with the reference frame with the lowest LongTermFrameIdx value and proceeding through in ascending
order to the reference frame with the highest LongTermFrameIdx value.


The process specified in clause 8.2.4.2.5 is invoked with refFrameList0ShortTerm and refFrameList0LongTerm given as
input and the output is assigned to RefPicList0.


**8.2.4.2.3** **Initialization process for reference picture lists for B slices in frames**


This initialization process is invoked when decoding a B slice in a coded frame.


For purposes of the formation of the reference picture lists RefPicList0 and RefPicList1 the term reference entry refers in
the following to decoded reference frames or complementary reference field pairs.


When this process is invoked, there shall be at least one reference entry that is currently marked as "used for reference"
(i.e., as "used for short-term reference" or "used for long-term reference") and is not marked as "non-existing".


For B slices, the order of short-term reference entries in the reference picture lists RefPicList0 and RefPicList1 depends
on output order, as given by PicOrderCnt( ). When pic_order_cnt_type is equal to 0, reference pictures that are marked as
"non-existing" as specified in clause 8.2.5.2 are not included in either RefPicList0 or RefPicList1.

NOTE 1 – When gaps_in_frame_num_value_allowed_flag is equal to 1, encoders should use reference picture list modification to
ensure proper operation of the decoding process (particularly when pic_order_cnt_type is equal to 0, in which case PicOrderCnt( )
is not inferred for "non-existing" frames).





The reference picture list RefPicList0 is ordered such that short-term reference entries have lower indices than long-term
reference entries. It is ordered as follows:


1. Let entryShortTerm be a variable ranging over all reference entries that are currently marked as "used for

short-term reference". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm )
less than PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of refPicList0 in
descending order of PicOrderCnt( entryShortTerm ). All of the remaining values of entryShortTerm (when
present) are then appended to refPicList0 in ascending order of PicOrderCnt( entryShortTerm ).


2. The long-term reference entries are ordered starting with the long-term reference entry that has the lowest

LongTermPicNum value and proceeding through in ascending order to the long-term reference entry that has the
highest LongTermPicNum value.


The reference picture list RefPicList1 is ordered so that short-term reference entries have lower indices than long-term
reference entries. It is ordered as follows:


1. Let entryShortTerm be a variable ranging over all reference entries that are currently marked as "used for

short-term reference". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm )
greater than PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of refPicList1 in
ascending order of PicOrderCnt( entryShortTerm ). All of the remaining values of entryShortTerm (when present)
are then appended to refPicList1 in descending order of PicOrderCnt( entryShortTerm ).


2. Long-term reference entries are ordered starting with the long-term reference frame or complementary reference

field pair that has the lowest LongTermPicNum value and proceeding through in ascending order to the long-term
reference entry that has the highest LongTermPicNum value.


3. When the reference picture list RefPicList1 has more than one entry and RefPicList1 is identical to the reference

picture list RefPicList0, the first two entries RefPicList1[ 0 ] and RefPicList1[ 1 ] are switched.
NOTE 2 – A non-paired reference field is not used for inter prediction of frames (independent of the value of MbaffFrameFlag).


**8.2.4.2.4** **Initialization process for reference picture lists for B slices in fields**


This initialization process is invoked when decoding a B slice in a coded field.


When this process is invoked, there shall be at least one reference field (which can be a field of a reference frame) that is
currently marked as "used for reference" (i.e., as "used for short-term reference" or "used for long-term reference") and is
not marked as "non-existing".


When decoding a field, each field of a stored reference frame is identified as a separate reference picture with a unique
index. The order of short-term reference pictures in the reference picture lists RefPicList0 and RefPicList1 depend on
output order, as given by PicOrderCnt( ). When pic_order_cnt_type is equal to 0, reference pictures that are marked as
"non-existing" as specified in clause 8.2.5.2 are not included in either RefPicList0 or RefPicList1.

NOTE 1 – When gaps_in_frame_num_value_allowed_flag is equal to 1, encoders should use reference picture list modification to
ensure proper operation of the decoding process (particularly when pic_order_cnt_type is equal to 0, in which case PicOrderCnt( )
is not inferred for "non-existing" frames).
NOTE 2 – When decoding a field, there are effectively at least twice as many pictures available for referencing as there would be
when decoding a frame at the same position in decoding order.


Three ordered lists of reference frames, refFrameList0ShortTerm, refFrameList1ShortTerm and refFrameListLongTerm,
are derived as follows. For purposes of the formation of these lists of frames the term reference entry refers in the following
to decoded reference frames, complementary reference field pairs, or non-paired reference fields. When
pic_order_cnt_type is equal to 0, the term reference entry does not refer to frames that are marked as "non-existing" as
specified in clause 8.2.5.2.


1. Let entryShortTerm be a variable ranging over all reference entries that are currently marked as "used for

short-term reference". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm )
less than or equal to PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of
refFrameList0ShortTerm in descending order of PicOrderCnt( entryShortTerm ). All of the remaining values of
entryShortTerm (when present) are then appended to refFrameList0ShortTerm in ascending order of
PicOrderCnt( entryShortTerm ).

NOTE 3 – When the current field follows in decoding order a coded field fldPrev with which together it forms a
complementary reference field pair, fldPrev is included into the list refFrameList0ShortTerm using
PicOrderCnt( fldPrev ) and the ordering method described in the previous sentence is applied.


2. Let entryShortTerm be a variable ranging over all reference entries that are currently marked as "used for

short-term reference". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm )
greater than PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of
refFrameList1ShortTerm in ascending order of PicOrderCnt( entryShortTerm ). All of the remaining values of





entryShortTerm (when present) are then appended to refFrameList1ShortTerm in descending order of
PicOrderCnt( entryShortTerm ).

NOTE 4 – When the current field follows in decoding order a coded field fldPrev with which together it forms a
complementary reference field pair, fldPrev is included into the list refFrameList1ShortTerm using
PicOrderCnt( fldPrev ) and the ordering method described in the previous sentence is applied.


3. refFrameListLongTerm is ordered starting with the reference entry having the lowest LongTermFrameIdx value

and proceeding through in ascending order to the reference entry having highest LongTermFrameIdx value.

NOTE 5 – When the current picture is the second field of a complementary field pair and the first field of the
complementary field pair is marked as "used for long-term reference", the first field is included into the list
refFrameListLongTerm. A reference entry in which only one field is marked as "used for long-term reference" is
included into the list refFrameListLongTerm.


The process specified in clause 8.2.4.2.5 is invoked with refFrameList0ShortTerm and refFrameListLongTerm given as
input and the output is assigned to RefPicList0.


The process specified in clause 8.2.4.2.5 is invoked with refFrameList1ShortTerm and refFrameListLongTerm given as
input and the output is assigned to RefPicList1.


When the reference picture list RefPicList1 has more than one entry and RefPicList1 is identical to the reference picture
list RefPicList0, the first two entries RefPicList1[ 0 ] and RefPicList1[ 1 ] are switched.


**8.2.4.2.5** **Initialization process for reference picture lists in fields**


Inputs of this process are the reference frame lists refFrameListXShortTerm (with X may be 0 or 1) and
refFrameListLongTerm.


The reference picture list RefPicListX is a list ordered such that short-term reference fields have lower indices than
long-term reference fields. Given the reference frame lists refFrameListXShortTerm and refFrameListLongTerm, it is
derived as specified by the following ordered steps:


1. Short-term reference fields are ordered by selecting reference fields from the ordered list of frames

refFrameListXShortTerm by alternating between fields of differing parity, starting with a field that has the same
parity as the current field (when present). When one field of a reference frame was not decoded or is not marked
as "used for short-term reference", the missing field is ignored and instead the next available stored reference field
of the chosen parity from the ordered list of frames refFrameListXShortTerm is inserted into RefPicListX. When
there are no more short-term reference fields of the alternate parity in the ordered list of frames
refFrameListXShortTerm, the next not yet indexed fields of the available parity are inserted into RefPicListX in
the order in which they occur in the ordered list of frames refFrameListXShortTerm.


2. Long-term reference fields are ordered by selecting reference fields from the ordered list of frames

refFrameListLongTerm by alternating between fields of differing parity, starting with a field that has the same
parity as the current field (when present). When one field of a reference frame was not decoded or is not marked
as "used for long-term reference", the missing field is ignored and instead the next available stored reference field
of the chosen parity from the ordered list of frames refFrameListLongTerm is inserted into RefPicListX. When
there are no more long-term reference fields of the alternate parity in the ordered list of frames
refFrameListLongTerm, the next not yet indexed fields of the available parity are inserted into RefPicListX in the
order in which they occur in the ordered list of frames refFrameListLongTerm.


**8.2.4.3** **Modification process for reference picture lists**


When ref_pic_list_modification_flag_l0 is equal to 1, the following applies:


1. Let refIdxL0 be an index into the reference picture list RefPicList0. It is initially set equal to 0.


2. The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the

bitstream. For each of these syntax elements, the following applies:


      - If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause 8.2.4.3.1 is
invoked with refIdxL0 as input, and the output is assigned to refIdxL0.


      - Otherwise, if modification_of_pic_nums_idc is equal to 2, the process specified in clause 8.2.4.3.2 is
invoked with refIdxL0 as input, and the output is assigned to refIdxL0.


      - Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list
RefPicList0 is finished.


When the current slice is a B slice and ref_pic_list_modification_flag_l1 is equal to 1, the following applies:


1. Let refIdxL1 be an index into the reference picture list RefPicList1. It is initially set equal to 0.





2. The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the

bitstream. For each of these syntax elements, the following applies:


      - If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause 8.2.4.3.1 is
invoked with refIdxL1 as input, and the output is assigned to refIdxL1.


      - Otherwise, if modification_of_pic_nums_idc is equal to 2, the process specified in clause 8.2.4.3.2 is
invoked with refIdxL1 as input, and the output is assigned to refIdxL1.


      - Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list
RefPicList1 is finished.


**8.2.4.3.1** **Modification process of reference picture lists for short-term reference pictures**


Input to this process is an index refIdxLX (with X being 0 or 1).


Output of this process is an incremented index refIdxLX.


The variable picNumLXNoWrap is derived as follows:


- If modification_of_pic_nums_idc is equal to 0,


if( picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) < 0 )
picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) + MaxPicNum (8-34)
else
picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 )


- Otherwise (modification_of_pic_nums_idc is equal to 1),


if( picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) >= MaxPicNum )
picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) − MaxPicNum (8-35)
else
picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 )


picNumLXPred is the prediction value for the variable picNumLXNoWrap. When the process specified in this clause is
invoked the first time for a slice (that is, for the first occurrence of modification_of_pic_nums_idc equal to 0 or 1 in the
ref_pic_list_modification( ) syntax), picNumL0Pred and picNumL1Pred are initially set equal to CurrPicNum. After each
assignment of picNumLXNoWrap, the value of picNumLXNoWrap is assigned to picNumLXPred.


The variable picNumLX is derived as specified by the following pseudo-code:


if( picNumLXNoWrap > CurrPicNum )
picNumLX = picNumLXNoWrap − MaxPicNum (8-36)
else
picNumLX = picNumLXNoWrap


picNumLX shall be equal to the PicNum of a reference picture that is marked as "used for short-term reference" and shall
not be equal to the PicNum of a short-term reference picture that is marked as "non-existing" _._


The following procedure is conducted to place the picture with short-term picture number picNumLX into the index
position refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of refIdxLX.


for( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx− − )
RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1]
RefPicListX[ refIdxLX++ ] = short-term reference picture with PicNum equal to picNumLX
nIdx = refIdxLX
for( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ ) (8-37)
if( PicNumF( RefPicListX[ cIdx ] ) != picNumLX )
RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ]


where the function PicNumF( RefPicListX[ cIdx ] ) is derived as follows:

- If the picture RefPicListX[ cIdx ] is marked as "used for short-term reference", PicNumF( RefPicListX[ cIdx ] ) is the
PicNum of the picture RefPicListX[ cIdx ].

- Otherwise (the picture RefPicListX[ cIdx ] is not marked as "used for short-term reference"),
PicNumF( RefPicListX[ cIdx ] ) is equal to MaxPicNum.

NOTE 1 – A value of MaxPicNum can never be equal to picNumLX.





NOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the
length needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of
the list need to be retained.


**8.2.4.3.2** **Modification process of reference picture lists for long-term reference pictures**


Input to this process is an index refIdxLX (with X being 0 or 1).


Output of this process is an incremented index refIdxLX.


The following procedure is conducted to place the picture with long-term picture number long_term_pic_num into the
index position refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of
refIdxLX.


for( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx− − )
RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1]
RefPicListX[ refIdxLX++ ] = long-term reference picture with LongTermPicNum equal to long_term_pic_num
nIdx = refIdxLX
for( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ ) (8-38)
if( LongTermPicNumF( RefPicListX[ cIdx ] ) != long_term_pic_num )
RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ]


where the function LongTermPicNumF( RefPicListX[ cIdx ] ) is derived as follows:

- If the picture RefPicListX[ cIdx ] is marked as "used for long-term reference",
LongTermPicNumF( RefPicListX[ cIdx ] ) is the LongTermPicNum of the picture RefPicListX[ cIdx ].

- Otherwise (the picture RefPicListX[ cIdx ] is not marked as "used for long-term reference"),
LongTermPicNumF( RefPicListX[ cIdx ] ) is equal to 2 * ( MaxLongTermFrameIdx + 1 ).

NOTE 1 – A value of 2 * ( MaxLongTermFrameIdx + 1 ) can never be equal to long_term_pic_num.
NOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the
length needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of
the list need to be retained.


**8.2.5** **Decoded reference picture marking process**


This process is invoked for decoded pictures when nal_ref_idc is not equal to 0.

NOTE 1 – The decoding process for gaps in frame_num that is specified in clause 8.2.5.2 may also be invoked when nal_ref_idc is
equal to 0, as specified in clause 8.


A decoded picture with nal_ref_idc not equal to 0, referred to as a reference picture, is marked as "used for short-term
reference" or "used for long-term reference". For a decoded reference frame, both of its fields are marked the same as the
frame. For a complementary reference field pair, the pair is marked the same as both of its fields. A picture that is marked
as "used for short-term reference" is identified by its FrameNum and, when it is a field, by its parity. A picture that is
marked as "used for long-term reference" is identified by its LongTermFrameIdx and, when it is a field, by its parity.


Frames or complementary field pairs marked as "used for short-term reference" or as "used for long-term reference" can
be used as a reference for inter prediction when decoding a frame until the frame, the complementary field pair, or one of
its constituent fields is marked as "unused for reference". A field marked as "used for short-term reference" or as "used for
long-term reference" can be used as a reference for inter prediction when decoding a field until marked as "unused for
reference".

NOTE 2 – The marking status of a frame or complementary field pair can always be deduced from the marking status of its two
fields. If both fields of a frame or complementary field pair are marked as "used for reference", the frame or complementary field
pair is also marked as "used for reference"; otherwise (one field or both fields of a frame or complementary field pair are marked as
"unused for reference"), the frame or complementary field pair is marked as "unused for reference".


A picture can be marked as "unused for reference" by the sliding window reference picture marking process, a first-in,
first-out mechanism specified in clause 8.2.5.3 or by the adaptive memory control reference picture marking process, a
customised adaptive marking operation specified in clause 8.2.5.4.


A short-term reference picture is identified for use in the decoding process by its variables FrameNum and FrameNumWrap
and its picture number PicNum, and a long-term reference picture is identified for use in the decoding process by its longterm picture number LongTermPicNum. When the current picture is not an IDR picture, clause 8.2.4.1 is invoked to specify
the assignment of the variables FrameNum, FrameNumWrap, PicNum and LongTermPicNum.





**8.2.5.1** **Sequence of operations for decoded reference picture marking process**


Decoded reference picture marking proceeds in the following ordered steps:


1. All slices of the current picture are decoded.


2. Depending on whether the current picture is an IDR picture, the following applies:


    - If the current picture is an IDR picture, the following ordered steps are specified:


a. All reference pictures are marked as "unused for reference"


b. Depending on long_term_reference_flag, the following applies:


          - If long_term_reference_flag is equal to 0, the IDR picture is marked as "used for short-term
reference" and MaxLongTermFrameIdx is set equal to "no long-term frame indices".


          - Otherwise (long_term_reference_flag is equal to 1), the IDR picture is marked as "used for
long-term reference", the LongTermFrameIdx for the IDR picture is set equal to 0, and
MaxLongTermFrameIdx is set equal to 0.


    - Otherwise (the current picture is not an IDR picture), the following applies:


       - If adaptive_ref_pic_marking_mode_flag is equal to 0, the process specified in clause 8.2.5.3 is invoked.


       - Otherwise (adaptive_ref_pic_marking_mode_flag is equal to 1), the process specified in clause 8.2.5.4
is invoked.


3. When the current picture is not an IDR picture and it was not marked as "used for long-term reference" by

memory_management_control_operation equal to 6, it is marked as "used for short-term reference".


It is a requirement of bitstream conformance that, after marking the current decoded reference picture, the total number of
frames with at least one field marked as "used for reference", plus the number of complementary field pairs with at least
one field marked as "used for reference", plus the number of non-paired fields marked as "used for reference" shall not be
greater than Max( max_num_ref_frames, 1 ).


**8.2.5.2** **Decoding process for gaps in frame_num**


This process is invoked when frame_num is not equal to PrevRefFrameNum and is not equal to ( PrevRefFrameNum + 1 )
% MaxFrameNum.

NOTE 1 – Although this process is specified as a subclause within clause 8.2.5 (which defines a process that is invoked only when
nal_ref_idc is not equal to 0), this process may also be invoked when nal_ref_idc is equal to 0 (as specified in clause 8). The reasons
for the location of this clause within the structure of this Recommendation | International Standard are historical.
NOTE 2 – This process can only be invoked for a conforming bitstream when gaps_in_frame_num_value_allowed_flag is equal
to 1. When gaps_in_frame_num_value_allowed_flag is equal to 0 and frame_num is not equal to PrevRefFrameNum and is not
equal to ( PrevRefFrameNum + 1 ) % MaxFrameNum, the decoding process should infer an unintentional loss of pictures.


When this process is invoked, a set of values of frame_num pertaining to "non-existing" pictures is derived as all values
taken on by UnusedShortTermFrameNum in Equation 7-24 except the value of frame_num for the current picture.


For each of the values of frame_num pertaining to "non-existing" pictures, in the order in which the values of
UnusedShortTermFrameNum are generated by Equation 7-24, the following ordered steps are specified:


1. The decoding process for picture numbers as specified in clause 8.2.4.1 is invoked.


2. The sliding window decoded reference picture marking process as specified in clause 8.2.5.3 is invoked.


3. The decoding process generates a frame and the generated frame is marked as "non-existing" and "used for short
term reference". The sample values of the generated frame may be set to any value.


The following constraints shall be obeyed:


a) The bitstream shall not contain data that result in the derivation of a co-located picture colPic that is marked as

"non-existing" in any invocation of the derivation process for the co-located 4x4 sub-macroblock partitions
specified in clause 8.4.1.2.1.


b) The bitstream shall not contain data that result in the derivation of a reference picture that is marked as

"non-existing" in any invocation of the reference picture selection process specified in clause 8.4.2.1.


c) The bitstream shall not contain data that result in a variable picNumLX that is equal to the PicNum of a picture

marked as "non-existing" in any invocation of the modification process for reference picture lists for short-term
reference pictures specified in clause 8.2.4.3.1.





d) The bitstream shall not contain data that result in a variable picNumLX that is equal to the PicNum of a picture

marked as "non-existing" in any invocation of the assignment process of a LongTermFrameIdx to a short-term
reference picture specified in clause 8.2.5.4.3.
NOTE 3 – The above constraints specify that frames that are marked as "non-existing" by the process specified in this clause must
not be referenced in the inter prediction process (clause 8.4, including the derivation process for co-located 4x4 sub-macroblock
partitions in clause 8.4.1.2.1), the modification commands for reference picture lists for short-term reference pictures
(clause 8.2.4.3.1), or the assignment process of a LongTermFrameIdx to a short-term reference picture (clause 8.2.5.4.3).


When pic_order_cnt_type is not equal to 0, TopFieldOrderCnt and BottomFieldOrderCnt are derived for each of the "nonexisting" frames by invoking the decoding process for picture order count in clause 8.2.1. When invoking the process in
clause 8.2.1 for a particular "non-existing" frame, the current picture is considered to be a picture considered having
frame_num inferred to be equal to UnusedShortTermFrameNum, nal_ref_idc inferred to be not equal to 0, nal_unit_type
inferred to be not equal to 5, IdrPicFlag inferred to be equal to 0, field_pic_flag inferred to be equal to 0,
adaptive_ref_pic_marking_mode_flag inferred to be equal to 0, delta_pic_order_cnt[ 0 ] (if needed) inferred to be equal
to 0, and delta_pic_order_cnt[ 1 ] (if needed) inferred to be equal to 0.

NOTE 4 – The decoding process should infer an unintentional picture loss when any of these values of frame_num pertaining to
"non-existing" pictures is referred to in the inter prediction process (clause 8.4, including the derivation process for the co-located
4x4 sub-macroblock partitions in clause 8.4.1.2.1), is referred to in the modification commands for reference picture lists for shortterm reference pictures (clause 8.2.4.3.1), or is referred to in the assignment process of a LongTermFrameIdx to a short-term
reference picture (clause 8.2.5.4.3). The decoding process should not infer an unintentional picture loss when a memory management
control operation not equal to 3 is applied to a frame marked as "non-existing".


**8.2.5.3** **Sliding window decoded reference picture marking process**


This process is invoked when adaptive_ref_pic_marking_mode_flag is equal to 0.


Depending on the properties of the current picture as specified below, the following applies:


- If the current picture is a coded field that is the second field in decoding order of a complementary reference field
pair, and the first field has been marked as "used for short-term reference", the current picture and the complementary
reference field pair are also marked as "used for short-term reference".


- Otherwise, the following applies:


1. Let numShortTerm be the total number of reference frames, complementary reference field pairs and non-paired

reference fields for which at least one field is marked as "used for short-term reference". Let numLongTerm be
the total number of reference frames, complementary reference field pairs and non-paired reference fields for
which at least one field is marked as "used for long-term reference".


2. When numShortTerm + numLongTerm is equal to Max( max_num_ref_frames, 1 ), the condition that

numShortTerm is greater than 0 shall be fulfilled, and the short-term reference frame, complementary reference
field pair or non-paired reference field that has the smallest value of FrameNumWrap is marked as "unused for
reference". When it is a frame or a complementary field pair, both of its fields are also marked as "unused for
reference".


**8.2.5.4** **Adaptive memory control decoded reference picture marking process**


This process is invoked when adaptive_ref_pic_marking_mode_flag is equal to 1.


The memory_management_control_operation commands with values of 1 to 6 are processed in the order they occur in the
bitstream after the current picture has been decoded. For each of these memory_management_control_operation
commands, one of the processes specified in clauses 8.2.5.4.1 to 8.2.5.4.6 is invoked depending on the value of
memory_management_control_operation. The memory_management_control_operation command with value of 0
specifies the end of memory_management_control_operation commands.


Memory management control operations are applied to pictures as follows:


- If field_pic_flag is equal to 0, memory_management_control_operation commands are applied to the frames or
complementary reference field pairs specified.


- Otherwise (field_pic_flag is equal to 1), memory_management_control_operation commands are applied to the
individual reference fields specified.


**8.2.5.4.1** **Marking process of a short-term reference picture as "unused for reference"**


This process is invoked when memory_management_control_operation is equal to 1.


Let picNumX be specified by


picNumX = CurrPicNum − ( difference_of_pic_nums_minus1 + 1 ). (8-39)





Depending on field_pic_flag the value of picNumX is used to mark a short-term reference picture as "unused for reference"
as follows:


- If field_pic_flag is equal to 0, the short-term reference frame or short-term complementary reference field pair
specified by picNumX and both of its fields are marked as "unused for reference".


- Otherwise (field_pic_flag is equal to 1), the short-term reference field specified by picNumX is marked as "unused
for reference". When that reference field is part of a reference frame or a complementary reference field pair, the
frame or complementary field pair is also marked as "unused for reference", but the marking of the other field in the
same reference frame or complementary reference field pair is not changed.


**8.2.5.4.2** **Marking process of a long-term reference picture as "unused for reference"**


This process is invoked when memory_management_control_operation is equal to 2.


Depending on field_pic_flag the value of LongTermPicNum is used to mark a long-term reference picture as "unused for
reference" as follows:


- If field_pic_flag is equal to 0, the long-term reference frame or long-term complementary reference field pair having
LongTermPicNum equal to long_term_pic_num and both of its fields are marked as "unused for reference".


- Otherwise (field_pic_flag is equal to 1), the long-term reference field specified by LongTermPicNum equal to
long_term_pic_num is marked as "unused for reference". When that reference field is part of a reference frame or a
complementary reference field pair, the frame or complementary field pair is also marked as "unused for reference",
but the marking of the other field in the same reference frame or complementary reference field pair is not changed.


**8.2.5.4.3** **Assignment process of a LongTermFrameIdx to a short-term reference picture**


This process is invoked when memory_management_control_operation is equal to 3.


Given the syntax element difference_of_pic_nums_minus1, the variable picNumX is obtained as specified in
clause 8.2.5.4.1. picNumX shall refer to a frame or complementary reference field pair or non-paired reference field marked
as "used for short-term reference" and not marked as "non-existing".


When LongTermFrameIdx equal to long_term_frame_idx is already assigned to a long-term reference frame or a long-term
complementary reference field pair, that frame or complementary field pair and both of its fields are marked as "unused
for reference". When LongTermFrameIdx is already assigned to a reference field, and that reference field is not part of a
complementary field pair that includes the picture specified by picNumX, that field is marked as "unused for reference".


Depending on field_pic_flag the value of LongTermFrameIdx is used to mark a picture from "used for short-term
reference" to "used for long-term reference" as follows:


- If field_pic_flag is equal to 0, the marking of the short-term reference frame or short-term complementary reference
field pair specified by picNumX and both of its fields are changed from "used for short-term reference" to "used for
long-term reference" and assigned LongTermFrameIdx equal to long_term_frame_idx.


- Otherwise (field_pic_flag is equal to 1), the marking of the short-term reference field specified by picNumX is
changed from "used for short-term reference" to "used for long-term reference" and assigned LongTermFrameIdx
equal to long_term_frame_idx. When the field is part of a reference frame or a complementary reference field pair,
and the other field of the same reference frame or complementary reference field pair is also marked as "used for
long-term reference", the reference frame or complementary reference field pair is also marked as "used for long-term
reference" and assigned LongTermFrameIdx equal to long_term_frame_idx.


**8.2.5.4.4** **Decoding process for MaxLongTermFrameIdx**


This process is invoked when memory_management_control_operation is equal to 4.


All pictures for which LongTermFrameIdx is greater than max_long_term_frame_idx_plus1 − 1 and that are marked as
"used for long-term reference" are marked as "unused for reference".


The variable MaxLongTermFrameIdx is derived as follows:


- If max_long_term_frame_idx_plus1 is equal to 0, MaxLongTermFrameIdx is set equal to "no long-term frame
indices".


- Otherwise (max_long_term_frame_idx_plus1 is greater than 0), MaxLongTermFrameIdx is set equal to
max_long_term_frame_idx_plus1 − 1.
NOTE – The memory_management_control_operation command equal to 4 can be used to mark long-term reference pictures as
"unused for reference". The frequency of transmitting max_long_term_frame_idx_plus1 is not specified by this
Recommendation | International Standard. However, the encoder should send a memory_management_control_operation command
equal to 4 upon receiving an error message, such as an intra refresh request message.





**8.2.5.4.5** **Marking process of all reference pictures as "unused for reference" and setting MaxLongTermFrameIdx**

**to "no long-term frame indices"**


This process is invoked when memory_management_control_operation is equal to 5.


All reference pictures are marked as "unused for reference" and the variable MaxLongTermFrameIdx is set equal to "no
long-term frame indices".


**8.2.5.4.6** **Process for assigning a long-term frame index to the current picture**


This process is invoked when memory_management_control_operation is equal to 6.


When a variable LongTermFrameIdx equal to long_term_frame_idx is already assigned to a long-term reference frame or
a long-term complementary reference field pair, that frame or complementary field pair and both of its fields are marked
as "unused for reference". When LongTermFrameIdx is already assigned to a reference field, and that reference field is
not part of a complementary field pair that includes the current picture, that field is marked as "unused for reference".


The current picture is marked as "used for long-term reference" and assigned LongTermFrameIdx equal to
long_term_frame_idx.


When field_pic_flag is equal to 0, both its fields are also marked as "used for long-term reference" and assigned
LongTermFrameIdx equal to long_term_frame_idx.


When field_pic_flag is equal to 1 and the current picture is the second field (in decoding order) of a complementary
reference field pair, and the first field of the complementary reference field pair is also currently marked as "used for longterm reference", the complementary reference field pair is also marked as "used for long-term reference" and assigned
LongTermFrameIdx equal to long_term_frame_idx.


After marking the current decoded reference picture, the total number of frames with at least one field marked as "used for
reference", plus the number of complementary field pairs with at least one field marked as "used for reference", plus the
number of non-paired fields marked as "used for reference" shall not be greater than Max( max_num_ref_frames, 1 ).

NOTE – Under some circumstances, the above statement may impose a constraint on the order in which a
memory_management_control_operation syntax element equal to 6 can appear in the decoded reference picture marking syntax
relative to a memory_management_control_operation syntax element equal to 1, 2, 3, or 4.
