**8.4** **Inter prediction process**


This process is invoked when decoding P and B macroblock types.


Outputs of this process are Inter prediction samples for the current macroblock that are a 16x16 array predL of luma samples
and when ChromaArrayType is not equal to 0 two (MbWidthC)x(MbHeightC) arrays predCb and predCr of chroma samples,
one for each of the chroma components Cb and Cr.


The partitioning of a macroblock is specified by mb_type. Each macroblock partition is referred to by mbPartIdx. When
the macroblock partitioning consists of partitions that are equal to sub-macroblocks, each sub-macroblock can be further
partitioned into sub-macroblock partitions as specified by sub_mb_type[ mbPartIdx ]. Each sub-macroblock partition is
referred to by subMbPartIdx. When the macroblock partitioning does not consist of sub-macroblocks, subMbPartIdx is set
equal to 0.


The following steps are specified for each macroblock partition or for each sub-macroblock partition.


The functions MbPartWidth( ), MbPartHeight( ), SubMbPartWidth( ), and SubMbPartHeight( ) describing the width and
height of macroblock partitions and sub-macroblock partitions are specified in Tables 7-13, 7-14, 7-17, and 7-18.


The range of the macroblock partition index mbPartIdx is derived as follows:


- If mb_type is equal to B_Skip or B_Direct_16x16, mbPartIdx proceeds over values 0..3.


- Otherwise (mb_type is not equal to B_Skip or B_Direct_16x16), mbPartIdx proceeds over values
0..NumMbPart( mb_type ) − 1.


For each value of mbPartIdx, the variables partWidth and partHeight for each macroblock partition or sub-macroblock
partition in the macroblock are derived as follows:


- If mb_type is not equal to P_8x8, P_8x8ref0, B_Skip, B_Direct_16x16, or B_8x8, subMbPartIdx is set equal to 0,
and partWidth and partHeight are derived as:


partWidth = MbPartWidth( mb_type ) (8-152)


partHeight = MbPartHeight( mb_type ) (8-153)


- Otherwise, if mb_type is equal to P_8x8 or P_8x8ref0, or mb_type is equal to B_8x8 and sub_mb_type[ mbPartIdx ]
is not equal to B_Direct_8x8, subMbPartIdx proceeds over values
0..NumSubMbPart( sub_mb_type[ mbPartIdx ] ) − 1, and partWidth and partHeight are derived as:


partWidth = SubMbPartWidth( sub_mb_type[ mbPartIdx ] ) (8-154)


partHeight = SubMbPartHeight( sub_mb_type[ mbPartIdx ] ). (8-155)


- Otherwise (mb_type is equal to B_Skip or B_Direct_16x16, or mb_type is equal to B_8x8 and
sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8), subMbPartIdx proceeds over values 0..3, and partWidth and
partHeight are derived as:


partWidth = 4 (8-156)


partHeight = 4 (8-157)





When ChromaArrayType is not equal to 0, the variables partWidthC and partHeightC are derived as:


partWidthC = partWidth / SubWidthC (8-158)
partHeightC = partHeight / SubHeightC (8-159)


Let the variable MvCnt be initially set equal to 0 before any invocation of clause 8.4.1 for the macroblock.


The Inter prediction process for a macroblock partition mbPartIdx and a sub-macroblock partition subMbPartIdx consists
of the following ordered steps:


1. The derivation process for motion vector components and reference indices as specified in clause 8.4.1 is invoked.


Inputs to this process are:


   - a macroblock partition mbPartIdx,


   - a sub-macroblock partition subMbPartIdx.


Outputs of this process are:


   - luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion
vectors mvCL0 and mvCL1


   - reference indices refIdxL0 and refIdxL1


   - prediction list utilization flags predFlagL0 and predFlagL1


   - the sub-macroblock partition motion vector count subMvCnt.


2. The variable MvCnt is incremented by subMvCnt.


3. When (weighted_pred_flag is equal to 1 and (slice_type % 5) is equal to 0 or 3) or (weighted_bipred_idc is greater

than 0 and (slice_type % 5) is equal to 1), the derivation process for prediction weights as specified in clause 8.4.3 is
invoked.


Inputs to this process are:


   - reference indices refIdxL0 and refIdxL1


   - prediction list utilization flags predFlagL0 and predFlagL1


Outputs of this process are variables for weighted prediction logWDC, w0C, w1C, o0C, o1C with C being replaced by L
and, when ChromaArrayType is not equal to 0, Cb and Cr.


4. The decoding process for Inter prediction samples as specified in clause 8.4.2 is invoked.


Inputs to this process are:


   - a macroblock partition mbPartIdx,


   - a sub-macroblock partition subMbPartIdx,


   - variables specifying partition width and height for luma and chroma (if available), partWidth, partHeight,
partWidthC (if available), and partHeightC (if available),


   - luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors
mvCL0 and mvCL1,


   - reference indices refIdxL0 and refIdxL1,


   - prediction list utilization flags predFlagL0 and predFlagL1,


   - variables for weighted prediction logWDC, w0C, w1C, o0C, o1C with C being replaced by L and, when

ChromaArrayType is not equal to 0, Cb and Cr.


Outputs of this process are inter prediction samples (pred); which are a (partWidth)x(partHeight) array predPartL of
prediction luma samples and when ChromaArrayType is not equal to 0 two (partWidthC)x(partHeightC) arrays
predPartCr, and predPartCb of prediction chroma samples, one for each of the chroma components Cb and Cr.


For use in derivation processes of variables invoked later in the decoding process, the following assignments are made:


MvL0[ mbPartIdx ][ subMbPartIdx ] = mvL0 (8-160)


MvL1[ mbPartIdx ][ subMbPartIdx ] = mvL1 (8-161)





RefIdxL0[ mbPartIdx ] = refIdxL0 (8-162)


RefIdxL1[ mbPartIdx ] = refIdxL1 (8-163)


PredFlagL0[ mbPartIdx ] = predFlagL0 (8-164)


PredFlagL1[ mbPartIdx ] = predFlagL1 (8-165)


The location of the upper-left sample of the macroblock partition relative to the upper-left sample of the macroblock is
derived by invoking the inverse macroblock partition scanning process as described in clause 6.4.2.1 with mbPartIdx as
the input and ( xP, yP ) as the output.


The location of the upper-left sample of the sub-macroblock partition relative to the upper-left sample of the macroblock
partition is derived by invoking the inverse sub-macroblock partition scanning process as described in clause 6.4.2.2 with
subMbPartIdx as the input and ( xS, yS ) as the output.


The macroblock prediction is formed by placing the macroblock or sub-macroblock partition prediction samples in their
correct relative positions in the macroblock, as follows.


The variable predL[ xP + xS + x, yP + yS + y ] with x = 0..partWidth − 1, y = 0..partHeight − 1 is derived by:


predL[ xP + xS + x, yP + yS + y ] = predPartL[ x, y ] (8-166)


When ChromaArrayType is not equal to 0, the variable predC with x = 0..partWidthC − 1, y = 0..partHeightC − 1, and C
in predC and predPartC being replaced by Cb or Cr is derived by:


predC[ xP / SubWidthC + xS / SubWidthC + x, yP / SubHeightC + yS / SubHeightC + y ] = predPartC[ x, y ]
(8-167)


**8.4.1** **Derivation process for motion vector components and reference indices**


Inputs to this process are:


- a macroblock partition mbPartIdx,


- a sub-macroblock partition subMbPartIdx.


Outputs of this process are:


- luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors
mvCL0 and mvCL1,


- reference indices refIdxL0 and refIdxL1,


- prediction list utilization flags predFlagL0 and predFlagL1,


- a motion vector count variable subMvCnt.


For the derivation of the variables mvL0 and mvL1 as well as refIdxL0 and refIdxL1, the following applies:


- If mb_type is equal to P_Skip, the derivation process for luma motion vectors for skipped macroblocks in P and SP
slices in clause 8.4.1.1 is invoked with the output being the luma motion vectors mvL0 and reference indices refIdxL0,
and predFlagL0 is set equal to 1. mvL1 and refIdxL1 are marked as not available and predFlagL1 is set equal to 0.
The motion vector count variable subMvCnt is set equal to 1.


- Otherwise, if mb_type is equal to B_Skip or B_Direct_16x16 or sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8,
the derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 in B slices in
clause 8.4.1.2 is invoked with mbPartIdx and subMbPartIdx as the input and the output being the luma motion vectors
mvL0, mvL1, the reference indices refIdxL0, refIdxL1, the motion vector count variable subMvCnt, and the
prediction utilization flags predFlagL0 and predFlagL1.


- Otherwise, for X being replaced by either 0 or 1 in the variables predFlagLX, mvLX, refIdxLX, and in Pred_LX and
in the syntax elements ref_idx_lX and mvd_lX, the following applies:


1. The variables refIdxLX and predFlagLX are derived as follows:

       - If MbPartPredMode( mb_type, mbPartIdx ) or SubMbPredMode( sub_mb_type[ mbPartIdx ] ) is equal
to Pred_LX or to BiPred,


refIdxLX = ref_idx_lX[ mbPartIdx ] (8-168)





predFlagLX = 1 (8-169)


       - Otherwise, the variables refIdxLX and predFlagLX are specified by


refIdxLX = −1 (8-170)


predFlagLX = 0 (8-171)


2. The motion vector count variable subMvCnt is set equal to predFlagL0 + predFlagL1.


3. The variable currSubMbType is derived as follows:

       - If the macroblock type is equal to B_8x8, currSubMbType is set equal to sub_mb_type[ mbPartIdx ].

       - Otherwise (the macroblock type is not equal to B_8x8), currSubMbType is set equal to "na".


4. When predFlagLX is equal to 1, the derivation process for luma motion vector prediction in clause 8.4.1.3 is

invoked with mbPartIdx subMbPartIdx, refIdxLX, and currSubMbType as the inputs and the output being
mvpLX. The luma motion vectors are derived by


mvLX[ 0 ] = mvpLX[ 0 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 0 ] (8-172)


mvLX[ 1 ] = mvpLX[ 1 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 1 ] (8-173)


When ChromaArrayType is not equal to 0 and predFlagLX (with X being either 0 or 1) is equal to 1, the derivation process
for chroma motion vectors in clause 8.4.1.4 is invoked with mvLX and refIdxLX as input and the output being mvCLX.


**8.4.1.1** **Derivation process for luma motion vectors for skipped macroblocks in P and SP slices**


This process is invoked when mb_type is equal to P_Skip.


Outputs of this process are the motion vector mvL0 and the reference index refIdxL0.


The reference index refIdxL0 for a skipped macroblock is derived as:


refIdxL0 = 0. (8-174)


For the derivation of the motion vector mvL0 of a P_Skip macroblock type, the following ordered steps are specified:


1. The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx set equal to 0, subMbPartIdx set equal to 0,

currSubMbType set equal to "na", and listSuffixFlag set equal to 0 as input and the output is assigned to mbAddrA,
mbAddrB, mvL0A, mvL0B, refIdxL0A, and refIdxL0B.


2. The variable mvL0 is specified as follows:


      - If any of the following conditions are true, both components of the motion vector mvL0 are set equal to 0:


        - mbAddrA is not available,


        - mbAddrB is not available,


        - refIdxL0A is equal to 0 and both components of mvL0A are equal to 0,


        - refIdxL0B is equal to 0 and both components of mvL0B are equal to 0.


      - Otherwise, the derivation process for luma motion vector prediction as specified in clause 8.4.1.3 is invoked
with mbPartIdx = 0, subMbPartIdx = 0, refIdxL0, and currSubMbType = "na" as inputs and the output is
assigned to mvL0.
NOTE – The output is directly assigned to mvL0, since the predictor is equal to the actual motion vector.


**8.4.1.2** **Derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8**


This process is invoked when mb_type is equal to B_Skip or B_Direct_16x16, or sub_mb_type[ mbPartIdx ] is equal to
B_Direct_8x8.


Inputs to this process are mbPartIdx and subMbPartIdx.


Outputs of this process are the reference indices refIdxL0, refIdxL1, the motion vectors mvL0 and mvL1, the motion vector
count variable subMvCnt, and the prediction list utilization flags, predFlagL0 and predFlagL1.
The derivation process depends on the value of direct_spatial_mv_pred_flag, which is present in the bitstream in the slice
header syntax as specified in clause 7.3.3, and is specified as follows:





- If direct_spatial_mv_pred_flag is equal to 1, the mode in which the outputs of this process are derived is referred to
as spatial direct prediction mode.

- Otherwise (direct_spatial_mv_pred_flag is equal to 0), mode in which the outputs of this process are derived is
referred to as temporal direct prediction mode.
Both spatial and temporal direct prediction mode use the co-located motion vectors and reference indices as specified in
clause 8.4.1.2.1.
The motion vectors and reference indices are derived as follows:

- If spatial direct prediction mode is used, the direct motion vector and reference index prediction mode specified in
clause 8.4.1.2.2 is used, with subMvCnt being an output.

- Otherwise (temporal direct prediction mode is used), the direct motion vector and reference index prediction mode
specified in clause 8.4.1.2.3 is used and the variable subMvCnt is derived as follows:


   - If subMbPartIdx is equal to 0, subMvCnt is set equal to 2.


   - Otherwise (subMbPartIdx is not equal to 0), subMvCnt is set equal to 0.


**8.4.1.2.1** **Derivation process for the co-located 4x4 sub-macroblock partitions**


Inputs to this process are mbPartIdx and subMbPartIdx.


Outputs of this process are the picture colPic, the co-located macroblock mbAddrCol, the motion vector mvCol, the
reference index refIdxCol, and the variable vertMvScale (which can be One_To_One, Frm_To_Fld or Fld_To_Frm).


When RefPicList1[ 0 ] is a frame or a complementary field pair, let firstRefPicL1Top and firstRefPicL1Bottom be the top
and bottom fields of RefPicList1[ 0 ], respectively, and let the following variables be specified as


topAbsDiffPOC = Abs( DiffPicOrderCnt( firstRefPicL1Top, CurrPic ) ) (8-175)


bottomAbsDiffPOC = Abs( DiffPicOrderCnt( firstRefPicL1Bottom, CurrPic ) ) (8-176)


The variable colPic specifies the picture that contains the co-located macroblock as specified in Table 8-6.


**Table 8-6 – Specification of the variable colPic**
















|field_pic_flag|RefPicList1[ 0 ]<br>is …|mb_field_decoding_flag|additional condition|colPic|
|---|---|---|---|---|
|1|a field of a<br>decoded frame|||the frame containing<br>RefPicList1[ 0 ]|
|1|a decoded field|||RefPicList1[ 0 ]|
|0|a decoded<br>frame|||RefPicList1[ 0 ]|
|0|a <br>complementary<br>field pair|0|topAbsDiffPOC <<br>bottomAbsDiffPOC|firstRefPicL1Top|
|0|a <br>complementary<br>field pair|0|topAbsDiffPOC >=<br>bottomAbsDiffPOC|firstRefPicL1Bottom|
|0|a <br>complementary<br>field pair|1|( CurrMbAddr & 1 )  = =  0|firstRefPicL1Top|
|0|a <br>complementary<br>field pair|1|( CurrMbAddr & 1 ) != 0|firstRefPicL1Bottom|



NOTE – The picture order count values of a complementary field pair marked as "used for long-term reference" have an impact on
the decoding process when the current picture is a coded frame, the current macroblock is a frame macroblock, and the
complementary field pair marked as "used for long-term reference" is the first picture in reference list 1.


Let PicCodingStruct( X ) be a function with the argument X being either CurrPic or colPic. It is specified in Table 8-7.


**Table 8-7 – Specification of PicCodingStruct( X )**

|X is coded with field_pic_flag equal to …|mb_adaptive_frame_field_flag|PicCodingStruct( X )|
|---|---|---|
|1||FLD|
|0|0|FRM|
|0|1|AFRM|






The variable luma4x4BlkIdx is derived as follows:

- If direct_8x8_inference_flag is equal to 0, luma4x4BlkIdx is set equal to (4 * mbPartIdx + subMbPartIdx).

- Otherwise (direct_8x8_inference_flag is equal to 1), luma4x4BlkIdx is set equal to (5 * mbPartIdx).


The inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with luma4x4BlkIdx as the input and
( x, y ) assigned to ( xCol, yCol ) as the output.


Table 8-8 specifies the co-located macroblock address mbAddrCol, yM, and the variable vertMvScale in two steps:


1. Specification of a macroblock address mbAddrX depending on PicCodingStruct( CurrPic ), and
PicCodingStruct( colPic ).

NOTE – It is not possible for CurrPic and colPic picture coding types to be either (FRM, AFRM) or (AFRM, FRM)
because these picture coding types must be separated by an IDR picture.


2. Specification of mbAddrCol, yM, and vertMvScale depending on mb_field_decoding_flag and the variable

fieldDecodingFlagX, which is derived as follows:


    - If the macroblock mbAddrX in the picture colPic is a field macroblock, fieldDecodingFlagX is set equal to 1.


    - Otherwise (the macroblock mbAddrX in the picture colPic is a frame macroblock), fieldDecodingFlagX is set
equal to 0.


Unspecified values in Table 8-8 indicate that the value of the corresponding variable is not relevant for the current table
row.


mbAddrCol is set equal to CurrMbAddr or to one of the following values.


mbAddrCol1 = 2 * PicWidthInMbs * ( CurrMbAddr / PicWidthInMbs ) +
( CurrMbAddr % PicWidthInMbs ) + PicWidthInMbs * ( yCol / 8 ) (8-177)


mbAddrCol2 = 2 * CurrMbAddr + ( yCol / 8 ) (8-178)


mbAddrCol3 = 2 * CurrMbAddr + bottom_field_flag (8-179)


mbAddrCol4 = PicWidthInMbs * ( CurrMbAddr / ( 2 * PicWidthInMbs ) ) +
( CurrMbAddr % PicWidthInMbs ) (8-180)


mbAddrCol5 = CurrMbAddr / 2 (8-181)


mbAddrCol6 = 2 * ( CurrMbAddr / 2 ) + ( ( topAbsDiffPOC < bottomAbsDiffPOC ) ? 0 : 1 ) (8-182)


mbAddrCol7 = 2 * ( CurrMbAddr / 2 ) + ( yCol / 8 ) (8-183)





**Table 8-8 – Specification of mbAddrCol, yM, and vertMvScale**














|PicCodingStruct( CurrPic )|PicCodingStruct( colPic )|mbAddrX|mb_field_decoding_flag|fieldDecodingFlagX|mbAddrCol|yM|vertMvScale|
|---|---|---|---|---|---|---|---|
|FLD|FLD||||CurrMbAddr|yCol|One_To_One|
|FLD|FRM||||mbAddrCol1|( 2 * yCol ) % 16|Frm_To_Fld|
|FLD|AFRM|2*CurrMbAddr||0|mbAddrCol2|( 2 * yCol ) % 16|Frm_To_Fld|
|FLD|AFRM|2*CurrMbAddr||1|mbAddrCol3|yCol|One_To_One|
|FRM|FLD||||mbAddrCol4|8 * ( (CurrMbAddr / PicWidthInMbs ) % 2)<br>+ 4 * ( yCol / 8 )|Fld_To_Frm|
|FRM|FRM||||CurrMbAddr|yCol|One_To_One|
|AFRM|FLD||0||mbAddrCol5|8 * ( CurrMbAddr % 2 ) +4 * ( yCol / 8 )|Fld_To_Frm|
|AFRM|FLD||1||mbAddrCol5|yCol|One_To_One|
|AFRM|AFRM|CurrMbAddr|0|0|CurrMbAddr|yCol|One_To_One|
|AFRM|AFRM|CurrMbAddr|0|1|mbAddrCol6|8 * ( CurrMbAddr % 2 ) + 4 * ( yCol / 8 )|Fld_To_Frm|
|AFRM|AFRM|CurrMbAddr|1|0|mbAddrCol7|( 2 * yCol ) % 16|Frm_To_Fld|
|AFRM|AFRM|CurrMbAddr|1|1|CurrMbAddr|yCol|One_To_One|



Let mbTypeCol be the syntax element mb_type of the macroblock with address mbAddrCol inside the picture colPic and,
when mbTypeCol is equal to P_8x8, P_8x8ref0, or B_8x8, let subMbTypeCol be the syntax element list sub_mb_type of
the macroblock with address mbAddrCol inside the picture colPic.


Let mbPartIdxCol be the macroblock partition index of the co-located partition and subMbPartIdxCol the sub-macroblock
partition index of the co-located sub-macroblock partition. The derivation process for macroblock and sub-macroblock
partition indices as specified in clause 6.4.13.4 is invoked with the luma location ( xCol, yM ), the macroblock type
mbTypeCol, and, when mbTypeCol is equal to P_8x8, P_8x8ref0, or B_8x8, the list of sub-macroblock types
subMbTypeCol as the inputs and the outputs are the macroblock partition index mbPartIdxCol and the sub-macroblock
partition index subMbPartIdxCol.


The motion vector mvCol and the reference index refIdxCol are derived as follows:

- If the macroblock mbAddrCol is coded in an Intra macroblock prediction mode, both components of mvCol are set
equal to 0 and refIdxCol is set equal to −1.

- Otherwise (the macroblock mbAddrCol is not coded in an Intra macroblock prediction mode), the prediction
utilization flags predFlagL0Col and predFlagL1Col are set equal to PredFlagL0[ mbPartIdxCol ] and
PredFlagL1[ mbPartIdxCol ], respectively, which are the prediction utilization flags that have been assigned to the
macroblock partition mbAddrCol\mbPartIdxCol inside the picture colPic, and the following applies:


   - If predFlagL0Col is equal to 1, the motion vector mvCol and the reference index refIdxCol are set equal to
MvL0[ mbPartIdxCol ][ subMbPartIdxCol ] and RefIdxL0[ mbPartIdxCol ], respectively, which are the motion
vector mvL0 and the reference index refIdxL0 that have been assigned to the (sub-)macroblock partition
mbAddrCol\mbPartIdxCol\subMbPartIdxCol inside the picture colPic.





   - Otherwise (predFlagL0Col is equal to 0 and predFlagL1Col is equal to 1), the motion vector mvCol and the
reference index refIdxCol are set equal to MvL1[ mbPartIdxCol ][ subMbPartIdxCol ] and
RefIdxL1[ mbPartIdxCol ], respectively, which are the motion vector mvL1 and the reference index refIdxL1
that have been assigned to the (sub-)macroblock partition mbAddrCol\mbPartIdxCol\subMbPartIdxCol inside
the picture colPic.


**8.4.1.2.2** **Derivation process for spatial direct luma motion vector and reference index prediction mode**


This process is invoked when direct_spatial_mv_pred_flag is equal to 1 and any of the following conditions are true:

- mb_type is equal to B_Skip,

- mb_type is equal to B_Direct_16x16,

- sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8.


Inputs to this process are mbPartIdx, subMbPartIdx.


Outputs of this process are the reference indices refIdxL0, refIdxL1, the motion vectors mvL0 and mvL1, the motion vector
count variable subMvCnt, and the prediction list utilization flags, predFlagL0 and predFlagL1.


The reference indices refIdxL0 and refIdxL1 and the variable directZeroPredictionFlag are derived by applying the
following ordered steps.


1. Let the variable currSubMbType be set equal to sub_mb_type[ mbPartIdx ].


2. The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx = 0, subMbPartIdx = 0, currSubMbType, and

listSuffixFlag = 0 as inputs and the output is assigned to the motion vectors mvL0N and the reference indices
refIdxL0N with N being replaced by A, B, or C.


3. The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx = 0, subMbPartIdx = 0, currSubMbType, and

listSuffixFlag = 1 as inputs and the output is assigned to the motion vectors mvL1N and the reference indices
refIdxL1N with N being replaced by A, B, or C.

NOTE 1 – The motion vectors mvL0N, mvL1N and the reference indices refIdxL0N, refIdxL1N are identical for all 4x4 submacroblock partitions of a macroblock.


4. The reference indices refIdxL0, refIdxL1, and directZeroPredictionFlag are derived by:


refIdxL0 = MinPositive( refIdxL0A, MinPositive( refIdxL0B, refIdxL0C ) ) (8-184)
refIdxL1 = MinPositive( refIdxL1A, MinPositive( refIdxL1B, refIdxL1C ) ) (8-185)
directZeroPredictionFlag = 0 (8-186)


where


 Min( x, y ) if x = 0 and y = 0

MinPositive( x, y ) =  (8-187)

 Max( x, y) otherwise


5. When both reference indices refIdxL0 and refIdxL1 are less than 0,


refIdxL0 = 0 (8-188)
refIdxL1 = 0 (8-189)
directZeroPredictionFlag = 1 (8-190)


The process specified in clause 8.4.1.2.1 is invoked with mbPartIdx, subMbPartIdx given as input and the output is
assigned to refIdxCol and mvCol.


The variable colZeroFlag is derived as follows:


- If all of the following conditions are true, colZeroFlag is set equal to 1:


   - RefPicList1[ 0 ] is currently marked as "used for short-term reference",


   - refIdxCol is equal to 0,


   - both motion vector components mvCol[ 0 ] and mvCol[ 1 ] lie in the range of −1 to 1 in units specified as follows:


      - If the co-located macroblock is a frame macroblock, the units of mvCol[ 0 ] and mvCol[ 1 ] are units of
quarter luma frame samples.


      - Otherwise (the co-located macroblock is a field macroblock), the units of mvCol[ 0 ] and mvCol[ 1 ] are
units of quarter luma field samples.





NOTE 2 – For purposes of determining the condition above, the value mvCol[ 1 ] is not scaled to use the units of a motion vector
for the current macroblock in cases when the current macroblock is a frame macroblock and the co-located macroblock is a field
macroblock or when the current macroblock is a field macroblock and the co-located macroblock is a frame macroblock. This aspect
differs from the use of mvCol[ 1 ] in the temporal direct mode as specified in clause 8.4.1.2.3, which applies scaling to the motion
vector of the co-located macroblock to use the same units as the units of a motion vector for the current macroblock, using
Equation 8-193 or Equation 8-194 in these cases.


- Otherwise, colZeroFlag is set equal to 0.


The motion vectors mvLX (with X being 0 or 1) are derived as follows:


- If any of the following conditions are true, both components of the motion vector mvLX are set equal to 0:


   - directZeroPredictionFlag is equal to 1,


   - refIdxLX is less than 0,


   - refIdxLX is equal to 0 and colZeroFlag is equal to 1.


- Otherwise, the process specified in clause 8.4.1.3 is invoked with mbPartIdx = 0, subMbPartIdx = 0, refIdxLX, and
currSubMbType as inputs and the output is assigned to mvLX.

NOTE 3 – The motion vector mvLX returned from clause 8.4.1.3 is identical for all 4x4 sub-macroblock partitions of a
macroblock for which the process is invoked.


The prediction utilization flags predFlagL0 and predFlagL1 are derived as specified using Table 8-9.


**Table 8-9 – Assignment of prediction utilization flags**

|refIdxL0|refIdxL1|predFlagL0|predFlagL1|
|---|---|---|---|
|>= 0|>= 0|1|1|
|>= 0|< 0|1|0|
|< 0|>= 0|0|1|



The variable subMvCnt is derived as follows:


- If subMbPartIdx is not equal to 0, subMvCnt is set equal to 0.


- Otherwise (subMbPartIdx is equal to 0), subMvCnt is set equal to predFlagL0 + predFLagL1.


**8.4.1.2.3** **Derivation process for temporal direct luma motion vector and reference index prediction mode**


This process is invoked when direct_spatial_mv_pred_flag is equal to 0 and any of the following conditions are true:


- mb_type is equal to B_Skip,


- mb_type is equal to B_Direct_16x16,


- sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8.


Inputs to this process are mbPartIdx and subMbPartIdx.


Outputs of this process are the motion vectors mvL0 and mvL1, the reference indices refIdxL0 and refIdxL1, and the
prediction list utilization flags, predFlagL0 and predFlagL1.
The process specified in clause 8.4.1.2.1 is invoked with mbPartIdx, subMbPartIdx given as input and the output is
assigned to colPic, mbAddrCol, mvCol, refIdxCol, and vertMvScale.


The reference indices refIdxL0 and refIdxL1 are derived as


refIdxL0 = ( ( refIdxCol < 0 ) ? 0 : MapColToList0( refIdxCol ) ) (8-191)


refIdxL1 = 0 (8-192)


NOTE 1 – If the current macroblock is a field macroblock, refIdxL0 and refIdxL1 index a list of fields; otherwise (the current
macroblock is a frame macroblock), refIdxL0 and refIdxL1 index a list of frames or complementary reference field pairs.


Let refPicCol be a frame, a field, or a complementary field pair that was referred by the reference index refIdxCol when
decoding the co-located macroblock mbAddrCol inside the picture colPic. The function MapColToList0( refIdxCol ) is
specified as follows:





- If vertMvScale is equal to One_To_One, the following applies:


   - If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies:


      - Let refIdxL0Frm be the lowest valued reference index in the current reference picture list RefPicList0 that
references the frame or complementary field pair that contains the field refPicCol. RefPicList0 shall contain
a frame or complementary field pair that contains the field refPicCol. The return value of MapColToList0( )
is specified as follows:

        - If the field referred to by refIdxCol has the same parity as the current macroblock,
MapColToList0( refIdxCol ) returns the reference index ( refIdxL0Frm << 1 ).

        - Otherwise (the field referred by refIdxCol has the opposite parity of the current macroblock),
MapColToList0( refIdxCol ) returns the reference index ( ( refIdxL0Frm << 1 ) + 1 ).


   - Otherwise (field_pic_flag is equal to 1 or the current macroblock is a frame macroblock),
MapColToList0( refIdxCol ) returns the lowest valued reference index refIdxL0 in the current reference picture
list RefPicList0 that references refPicCol. RefPicList0 shall contain refPicCol.


- Otherwise, if vertMvScale is equal to Frm_To_Fld, the following applies:


   - If field_pic_flag is equal to 0, let refIdxL0Frm be the lowest valued reference index in the current reference
picture list RefPicList0 that references refPicCol. MapColToList0( refIdxCol ) returns the reference index
( refIdxL0Frm << 1 ). RefPicList0 shall contain refPicCol.


   - Otherwise (field_pic_flag is equal to 1), MapColToList0( refIdxCol ) returns the lowest valued reference index
refIdxL0 in the current reference picture list RefPicList0 that references the field of refPicCol with the same
parity as the current picture CurrPic. RefPicList0 shall contain the field of refPicCol with the same parity as the
current picture CurrPic.


- Otherwise (vertMvScale is equal to Fld_To_Frm), MapColToList0( refIdxCol ) returns the lowest valued reference
index refIdxL0 in the current reference picture list RefPicList0 that references the frame or complementary field pair
that contains refPicCol. RefPicList0 shall contain a frame or complementary field pair that contains the field
refPicCol.

NOTE 2 – A decoded reference picture that was marked as "used for short-term reference" when it was referenced in the
decoding process of the picture containing the co-located macroblock may have been modified to be marked as "used for
long-term reference" before being used for reference for inter prediction using the direct prediction mode for the current
macroblock.


Depending on the value of vertMvScale the vertical component of mvCol is modified as follows:


- If vertMvScale is equal to Frm_To_Fld


mvCol[ 1 ] = mvCol[ 1 ] / 2 (8-193)


- Otherwise, if vertMvScale is equal to Fld_To_Frm


mvCol[ 1 ] = mvCol[ 1 ] * 2 (8-194)


- Otherwise (vertMvScale is equal to One_To_One), mvCol[ 1 ] remains unchanged.


The variables currPicOrField, pic0, and pic1, are derived as follows:


- If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies:

1. currPicOrField is the field of the current picture CurrPic that has the same parity as the current macroblock.

2. pic1 is the field of RefPicList1[ 0 ] that has the same parity as the current macroblock.

3. The variable pic0 is derived as follows:


       - If refIdxL0 % 2 is equal to 0, pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the same parity as
the current macroblock.


       - Otherwise (refIdxL0 % 2 is not equal to 0), pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the
opposite parity of the current macroblock.


- Otherwise (field_pic_flag is equal to 1 or the current macroblock is a frame macroblock), currPicOrField is the current
picture CurrPic, pic1 is the decoded reference picture RefPicList1[ 0 ], and pic0 is the decoded reference picture
RefPicList0[ refIdxL0 ].


The two motion vectors mvL0 and mvL1 for each 4x4 sub-macroblock partition of the current macroblock are derived as
follows:





NOTE 3 – It is often the case that many of the 4x4 sub-macroblock partitions share the same motion vectors and reference
pictures. In these cases, temporal direct mode motion compensation can calculate the inter prediction sample values in
larger units than 4x4 luma sample blocks. For example, when direct_8x8_inference_flag is equal to 1, at least each 8x8
luma sample quadrant of the macroblock shares the same motion vectors and reference pictures.


- If the reference index refIdxL0 refers to a long-term reference picture, or DiffPicOrderCnt( pic1, pic0 ) is equal to 0,
the motion vectors mvL0, mvL1 for the direct mode partition are derived by:


mvL0 = mvCol (8-195)


mvL1 = 0 (8-196)


- Otherwise, the motion vectors mvL0, mvL1 are derived as scaled versions of the motion vector mvCol of the
co-located sub-macroblock partition as specified below (see Figure 8-2).


tx = ( 16 384 + Abs( td / 2 ) ) / td (8-197)


DistScaleFactor = Clip3( -1024, 1023, ( tb * tx + 32 ) >> 6 ) (8-198)


mvL0 = ( DistScaleFactor * mvCol + 128 ) >> 8 (8-199)


mvL1 = mvL0 − mvCol (8-200)


where tb and td are derived as:


tb = Clip3( -128, 127, DiffPicOrderCnt( currPicOrField, pic0 ) ) (8-201)


td = Clip3( -128, 127, DiffPicOrderCnt( pic1, pic0 ) ) (8-202)


NOTE 4 – mvL0 and mvL1 cannot exceed the ranges specified in Annex A.


The prediction utilization flags predFlagL0 and predFlagL1 are both set equal to 1.


Figure 8-2 illustrates the temporal direct-mode motion vector inference when the current picture is temporally between the
reference picture from reference picture list 0 and the reference picture from reference picture list 1.


List 0 reference Current B List 1 reference





**Figure 8-2 – Example for temporal direct-mode motion vector inference (informative)**


**8.4.1.3** **Derivation process for luma motion vector prediction**


Inputs to this process are:


- the macroblock partition index mbPartIdx,


- the sub-macroblock partition index subMbPartIdx,


- the reference index of the current partition refIdxLX (with X being 0 or 1),


- the variable currSubMbType.





Output of this process is the prediction mvpLX of the motion vector mvLX (with X being 0 or 1).


The derivation process for the neighbouring blocks for motion data in clause 8.4.1.3.2 is invoked with mbPartIdx,
subMbPartIdx, currSubMbType, and listSuffixFlag = X (with X being 0 or 1 for refIdxLX being refIdxL0 or refIdxL1,
respectively) as the input and with mbAddrN\mbPartIdxN\subMbPartIdxN, reference indices refIdxLXN and the motion
vectors mvLXN with N being replaced by A, B, or C as the output.


The motion vector predictor mvpLX is derived as follows:


- If MbPartWidth( mb_type ) is equal to 16, MbPartHeight( mb_type ) is equal to 8, mbPartIdx is equal to 0, and
refIdxLXB is equal to refIdxLX, the motion vector predictor mvpLX is derived by:


mvpLX = mvLXB (8-203)


- Otherwise, if MbPartWidth( mb_type ) is equal to 16, MbPartHeight( mb_type ) is equal to 8, mbPartIdx is equal to 1,
and refIdxLXA is equal to refIdxLX, the motion vector predictor mvpLX is derived by:


mvpLX = mvLXA (8-204)


- Otherwise, if MbPartWidth( mb_type ) is equal to 8, MbPartHeight( mb_type ) is equal to 16, mbPartIdx is equal to 0,
and refIdxLXA is equal to refIdxLX, the motion vector predictor mvpLX is derived by:


mvpLX = mvLXA (8-205)


- Otherwise, if MbPartWidth( mb_type ) is equal to 8, MbPartHeight( mb_type ) is equal to 16, mbPartIdx is equal to 1,
and refIdxLXC is equal to refIdxLX, the motion vector predictor mvpLX is derived by:


mvpLX = mvLXC (8-206)


- Otherwise, the derivation process for median luma motion vector prediction in clause 8.4.1.3.1 is invoked with
mbAddrN\mbPartIdxN\subMbPartIdxN, mvLXN, refIdxLXN with N being replaced by A, B, or C, and refIdxLX as
the inputs and the output is assigned to the motion vector predictor mvpLX.


Figure 8-3 illustrates the non-median prediction as specified in Equations 8-203 to 8-206.


**Figure 8-3 – Directional segmentation prediction (informative)**


**8.4.1.3.1** **Derivation process for median luma motion vector prediction**


Inputs to this process are:


- the neighbouring partitions mbAddrN\mbPartIdxN\subMbPartIdxN (with N being replaced by A, B, or C),


- the motion vectors mvLXN (with N being replaced by A, B, or C) of the neighbouring partitions,


- the reference indices refIdxLXN (with N being replaced by A, B, or C) of the neighbouring partitions,


- the reference index refIdxLX of the current partition.


Output of this process is the motion vector prediction mvpLX.





The variable mvpLX is derived as specified by the following ordered steps:


1. When both partitions mbAddrB\mbPartIdxB\subMbPartIdxB and mbAddrC\mbPartIdxC\subMbPartIdxC are not

available and mbAddrA\mbPartIdxA\subMbPartIdxA is available,


mvLXB = mvLXA (8-207)


mvLXC = mvLXA (8-208)


refIdxLXB = refIdxLXA (8-209)


refIdxLXC = refIdxLXA (8-210)


2. Depending on reference indices refIdxLXA, refIdxLXB, or refIdxLXC, the following applies:


    - If one and only one of the reference indices refIdxLXA, refIdxLXB, or refIdxLXC is equal to the reference
index refIdxLX of the current partition, the following applies. Let refIdxLXN be the reference index that is
equal to refIdxLX, the motion vector mvLXN is assigned to the motion vector prediction mvpLX:


mvpLX = mvLXN (8-211)


    - Otherwise, each component of the motion vector prediction mvpLX is given by the median of the
corresponding vector components of the motion vector mvLXA, mvLXB, and mvLXC:


mvpLX[ 0 ] = Median( mvLXA[ 0 ], mvLXB[ 0 ], mvLXC[ 0 ] ) (8-212)


mvpLX[ 1 ] = Median( mvLXA[ 1 ], mvLXB[ 1 ], mvLXC[ 1 ] ) (8-213)


**8.4.1.3.2** **Derivation process for motion data of neighbouring partitions**


Inputs to this process are:


- the macroblock partition index mbPartIdx,


- the sub-macroblock partition index subMbPartIdx,


- the current sub-macroblock type currSubMbType,


- the list suffix flag listSuffixFlag.


Outputs of this process are (with N being replaced by A, B, or C)


- mbAddrN\mbPartIdxN\subMbPartIdxN specifying neighbouring partitions,


- the motion vectors mvLXN of the neighbouring partitions,


- the reference indices refIdxLXN of the neighbouring partitions.


Variable names that include the string "LX" are interpreted with the X being equal to listSuffixFlag.


The partitions mbAddrN\mbPartIdxN\subMbPartIdxN with N being either A, B, or C are derived in the following
ordered steps:


1. Let mbAddrD\mbPartIdxD\subMbPartIdxD be variables specifying an additional neighbouring partition.


2. The process in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType, and subMbPartIdx as input and the

output is assigned to mbAddrN\mbPartIdxN\subMbPartIdxN with N being replaced by A, B, C, or D.


3. When the partition mbAddrC\mbPartIdxC\subMbPartIdxC is not available, the following applies:


mbAddrC = mbAddrD (8-214)


mbPartIdxC = mbPartIdxD (8-215)


subMbPartIdxC = subMbPartIdxD (8-216)





The motion vectors mvLXN and reference indices refIdxLXN (with N being A, B, or C) are derived as follows:


- If the macroblock partition or sub-macroblock partition mbAddrN\mbPartIdxN\subMbPartIdxN is not available or
mbAddrN is coded in an Intra macroblock prediction mode or predFlagLX of mbAddrN\mbPartIdxN\subMbPartIdxN
is equal to 0, both components of mvLXN are set equal to 0 and refIdxLXN is set equal to −1.


- Otherwise, the following ordered steps are specified:


1. The motion vector mvLXN and reference index refIdxLXN are set equal to
MvLX[ mbPartIdxN ][ subMbPartIdxN ] and RefIdxLX[ mbPartIdxN ], respectively, which are the motion
vector mvLX and reference index refIdxLX that have been assigned to the (sub-)macroblock partition
mbAddrN\mbPartIdxN\subMbPartIdxN.


2. The variables mvLXN[ 1 ] and refIdxLXN are further processed as follows:


        - If the current macroblock is a field macroblock and the macroblock mbAddrN is a frame macroblock


mvLXN[ 1 ] = mvLXN[ 1 ] / 2 (8-217)


refIdxLXN = refIdxLXN * 2 (8-218)


        - Otherwise, if the current macroblock is a frame macroblock and the macroblock mbAddrN is a field
macroblock


mvLXN[ 1 ] = mvLXN[ 1 ] * 2 (8-219)


refIdxLXN = refIdxLXN / 2 (8-220)


        - Otherwise, the vertical motion vector component mvLXN[ 1 ] and the reference index refIdxLXN
remain unchanged.


**8.4.1.4** **Derivation process for chroma motion vectors**


This process is only invoked when ChromaArrayType is not equal to 0.


Inputs to this process are a luma motion vector mvLX and a reference index refIdxLX.


Output of this process is a chroma motion vector mvCLX.


A chroma motion vector is derived from the corresponding luma motion vector.


The precision of the chroma motion vector components is 1 ÷ ( 4 * SubWidthC ) horizontally and 1 ÷ ( 4 * SubHeightC )
vertically.

NOTE – For example, when using the 4:2:0 chroma format, since the units of luma motion vectors are one-quarter luma sample
units and chroma has half horizontal and vertical resolution compared to luma, the units of chroma motion vectors are one-eighth
chroma sample units, i.e., a value of 1 for the chroma motion vector refers to a one-eighth chroma sample displacement. For example,
when the luma vector applies to 8x16 luma samples, the corresponding chroma vector in 4:2:0 chroma format applies to 4x8 chroma
samples and when the luma vector applies to 4x4 luma samples, the corresponding chroma vector in 4:2:0 chroma format applies
to 2x2 chroma samples.


For the derivation of the motion vector mvCLX, the following applies:


- If ChromaArrayType is not equal to 1 or the current macroblock is a frame macroblock, the horizontal and vertical
components of the chroma motion vector mvCLX are derived as:


mvCLX[ 0 ] = mvLX[ 0 ] (8-221)
mvCLX[ 1 ] = mvLX[ 1 ] (8-222)


- Otherwise (ChromaArrayType is equal to 1 and the current macroblock is a field macroblock), only the horizontal
component of the chroma motion vector mvCLX[ 0 ] is derived using Equation 8-221. The vertical component of the
chroma motion vector mvCLX[ 1 ] is dependent on the parity of the current field or the current macroblock and the
reference picture, which is referred by the reference index refIdxLX. mvCLX[ 1 ] is derived from mvLX[ 1 ]
according to Table 8-10.





**Table 8-10 – Derivation of the vertical component of the chroma vector in field coding mode**

|Parity conditions|Col2|mvCLX[ 1 ]|
|---|---|---|
|Reference picture (refIdxLX)|Current field (picture/macroblock)|Current field (picture/macroblock)|
|Top field|Bottom field|mvLX[ 1 ] + 2|
|Bottom field|Top field|mvLX[ 1 ] − 2|
|Otherwise|Otherwise|mvLX[ 1 ]|



**8.4.2** **Decoding process for Inter prediction samples**


Inputs to this process are:


- a macroblock partition mbPartIdx,


- a sub-macroblock partition subMbPartIdx,


- variables specifying partition width and height for luma and chroma (if available), partWidth, partHeight, partWidthC
(if available) and partHeightC (if available),


- luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0 chroma motion vectors mvCL0
and mvCL1,


- reference indices refIdxL0 and refIdxL1,


- prediction list utilization flags, predFlagL0 and predFlagL1,


- variables for weighted prediction logWDC, w0C, w1C, o0C, o1C with C being replaced by L and, when
ChromaArrayType is not equal to 0, Cb and Cr.


Outputs of this process are the Inter prediction samples predPart, which are a (partWidth)x(partHeight) array predPartL of
prediction luma samples, and when ChromaArrayType is not equal to 0 two (partWidthC)x(partHeightC) arrays
predPartCb, predPartCr of prediction chroma samples, one for each of the chroma components Cb and Cr.


Let predPartL0L and predPartL1L be (partWidth)x(partHeight) arrays of predicted luma sample values and when
ChromaArrayType is not equal to 0 predPartL0Cb, predPartL1Cb, predPartL0Cr, and predPartL1Cr be
(partWidthC)x(partHeightC) arrays of predicted chroma sample values.


For LX being replaced by either L0 or L1 in the variables predFlagLX, RefPicListX, refIdxLX, refPicLX, predPartLX, the
following is specified.


When predFlagLX is equal to 1, the following applies:


- The reference picture consisting of an ordered two-dimensional array refPicLXL of luma samples and when
ChromaArrayType is not equal to 0 two ordered two-dimensional arrays refPicLXCb and refPicLXCr of chroma
samples is derived by invoking the process specified in clause 8.4.2.1 with refIdxLX and RefPicListX given as input.


- The array predPartLXL and when ChromaArrayType is not equal to 0 the arrays predPartLXCb and predPartLXCr are
derived by invoking the process specified in clause 8.4.2.2 with the current partition specified by
mbPartIdx\subMbPartIdx, the motion vectors mvLX, mvCLX (if available), and the reference arrays with refPicLXL,
refPicLXCb (if available), and refPicLXCr (if available) given as input.


For C being replaced by L, Cb (if available), or Cr (if available), the array predPartC of the prediction samples of component
C is derived by invoking the process specified in clause 8.4.2.3 with the current partition specified by mbPartIdx and
subMbPartIdx, the prediction utilization flags predFlagL0 and predFlagL1, the arrays predPartL0C and predPartL1C, and
the variables for weighted prediction logWDC, w0C, w1C, o0C, o1C given as input.


**8.4.2.1** **Reference picture selection process**


Input to this process is a reference index refIdxLX.


Output of this process is a reference picture consisting of a two-dimensional array of luma samples refPicLXL and, when
ChromaArrayType is not equal to 0, two two-dimensional arrays of chroma samples refPicLXCb and refPicLXCr.





Depending on field_pic_flag, the reference picture list RefPicListX (which has been derived as specified in clause 8.2.4)
consists of the following.


- If field_pic_flag is equal to 1, each entry of RefPicListX is a reference field or a field of a reference frame.


- Otherwise (field_pic_flag is equal to 0), each entry of RefPicListX is a reference frame or a complementary reference
field pair.


For the derivation of the reference picture, the following applies:


- If field_pic_flag is equal to 1, the reference field or field of a reference frame RefPicListX[ refIdxLX ] is the output.
The output reference field or field of a reference frame consists of a (PicWidthInSamplesL)x(PicHeightInSamplesL)
array of luma samples refPicLXL and, when ChromaArrayType is not equal to 0, two
(PicWidthInSamplesC)x(PicHeightInSamplesC) arrays of chroma samples refPicLXCb and refPicLXCr.


- Otherwise (field_pic_flag is equal to 0), the following applies:


   - If the current macroblock is a frame macroblock, the reference frame or complementary reference field pair
RefPicListX[ refIdxLX ] is the output. The output reference frame or complementary reference field pair consists
of a (PicWidthInSamplesL)x(PicHeightInSamplesL) array of luma samples refPicLXL and, when
ChromaArrayType is not equal to 0, two (PicWidthInSamplesC)x(PicHeightInSamplesC) arrays of chroma
samples refPicLXCb and refPicLXCr.


   - Otherwise (the current macroblock is a field macroblock), the following ordered steps are specified:


1. Let refFrame be the reference frame or complementary reference field pair RefPicListX[ refIdxLX / 2 ].


2. The field of refFrame is selected as follows:


          - If refIdxLX % 2 is equal to 0, the field of refFrame that has the same parity as the current macroblock
is the output.


          - Otherwise (refIdxLX % 2 is equal to 1), the field of refFrame that has the opposite parity as the
current macroblock is the output.


3. The output reference field or field of a reference frame consists of a
(PicWidthInSamplesL)x(PicHeightInSamplesL / 2) array of luma samples refPicLXL and, when
ChromaArrayType is not equal to 0, two (PicWidthInSamplesC)x(PicHeightInSamplesC / 2) arrays of
chroma samples refPicLXCb and refPicLXCr.


Depending on separate_colour_plane_flag, the following applies:


- If separate_colour_plane_flag is equal to 0, the reference picture sample arrays refPicLXL, refPicLXCb (if available),
and refPicLXCr (if available) correspond to decoded sample arrays SL, SCb (if available), SCr (if available) derived in
clause 8.7 for a previously-decoded reference field or reference frame or complementary reference field pair or field
of a reference frame.


- Otherwise (separate_colour_plane_flag is equal to 1), the following applies:


   - If colour_plane_id is equal to 0, the reference picture sample array refPicLXL corresponds to the decoded sample
array SL derived in clause 8.7 for a previously-decoded reference field or reference frame or complementary
reference field pair or field of a reference frame.


   - Otherwise, if colour_plane_id is equal to 1, the reference picture sample array refPicLXL corresponds to the
decoded sample array SCb derived in clause 8.7 for a previously-decoded reference field or reference frame or
complementary reference field pair or field of a reference frame.


   - Otherwise (colour_plane_id is equal to 2), the reference picture sample array refPicLXL corresponds to the
decoded sample array SCr derived in clause 8.7 for a previously-decoded reference field or reference frame or
complementary reference field pair or field of a reference frame.


**8.4.2.2** **Fractional sample interpolation process**


Inputs to this process are:


- the current partition given by its partition index mbPartIdx and its sub-macroblock partition index subMbPartIdx,


- the width and height partWidth, partHeight of this partition in luma-sample units,


- a luma motion vector mvLX given in quarter-luma-sample units,


- when ChromaArrayType is not equal to 0, a chroma motion vector mvCLX with a precision of one-(4*SubWidthC)th chroma-sample units horizontally and one-(4*SubHeightC)-th chroma-sample units vertically,





- the selected reference picture sample arrays refPicLXL, and when ChromaArrayType is not equal to 0, refPicLXCb,
and refPicLXCr.


Outputs of this process are:


- a (partWidth)x(partHeight) array predPartLXL of prediction luma sample values,


- when ChromaArrayType is not equal to 0, two (partWidthC)x(partHeightC) arrays predPartLXCb, and predPartLXCr
of prediction chroma sample values.


Let ( xAL, yAL ) be the location given in full-sample units of the upper-left luma sample of the current partition given by
mbPartIdx\subMbPartIdx relative to the upper-left luma sample location of the given two-dimensional array of luma
samples.


Let ( xIntL, yIntL ) be a luma location given in full-sample units and ( xFracL, yFracL ) be an offset given in quarter-sample
units. These variables are used only inside this clause for specifying general fractional-sample locations inside the reference
sample arrays refPicLXL, refPicLXCb (if available), and refPicLXCr (if available).


For each luma sample location (0 <= xL < partWidth, 0 <= yL < partHeight) inside the prediction luma sample array
predPartLXL, the corresponding prediction luma sample value predPartLXL[ xL, yL ] is derived as specified by the
following ordered steps:


1. The variables xIntL, yIntL, xFracL, and yFracL are derived by:


xIntL = xAL + ( mvLX[ 0 ] >> 2 ) + xL (8-223)
yIntL = yAL + ( mvLX[ 1 ] >> 2 ) + yL (8-224)


xFracL = mvLX[ 0 ] & 3 (8-225)
yFracL = mvLX[ 1 ] & 3 (8-226)


2. The prediction luma sample value predPartLXL[ xL, yL ] is derived by invoking the process specified in

clause 8.4.2.2.1 with ( xIntL, yIntL ), ( xFracL, yFracL ) and refPicLXL given as input.


When ChromaArrayType is not equal to 0, the following applies.


Let ( xIntC, yIntC ) be a chroma location given in full-sample units and ( xFracC, yFracC ) be an offset given in
one-(4*SubWidthC)-th chroma-sample units horizontally and one-(4*SubHeightC)-th chroma-sample units vertically.
These variables are used only inside this clause for specifying general fractional-sample locations inside the reference
sample arrays refPicLXCb, and refPicLXCr.


For each chroma sample location (0 <= xC < partWidthC, 0 <= yC < partHeightC) inside the prediction chroma sample
arrays predPartLXCb and predPartLXCr, the corresponding prediction chroma sample values predPartLXCb[ xC, yC ] and
predPartLXCr[ xC, yC ] are derived as specified by the following ordered steps:


1. Depending on ChromaArrayType, the variables xIntC, yIntC, xFracC, and yFracC are derived as follows:


    - If ChromaArrayType is equal to 1,


xIntC = ( xAL / SubWidthC ) + ( mvCLX[ 0 ] >> 3 ) + xC (8-227)
yIntC = ( yAL / SubHeightC ) + ( mvCLX[ 1 ] >> 3 ) + yC (8-228)


xFracC = mvCLX[ 0 ] & 7 (8-229)
yFracC = mvCLX[ 1 ] & 7 (8-230)


    - Otherwise, if ChromaArrayType is equal to 2,


xIntC = ( xAL / SubWidthC ) + ( mvCLX[ 0 ] >> 3 ) + xC (8-231)
yIntC = ( yAL / SubHeightC ) + ( mvCLX[ 1 ] >> 2 ) + yC (8-232)


xFracC = mvCLX[ 0 ] & 7 (8-233)
yFracC = ( mvCLX[ 1 ] & 3 ) << 1 (8-234)





    - Otherwise (ChromaArrayType is equal to 3),


xIntC = xAL + ( mvLX[ 0 ] >> 2 ) + xC (8-235)
yIntC = yAL + ( mvLX[ 1 ] >> 2 ) + yC (8-236)


xFracC = ( mvCX[ 0 ] & 3 ) (8-237)
yFracC = ( mvCX[ 1 ] & 3 ) (8-238)


2. Depending on ChromaArrayType, the following applies:


    - If ChromaArrayType is not equal to 3, the following applies:


       - The prediction sample value predPartLXCb[ xC, yC ] is derived by invoking the process specified in
clause 8.4.2.2.2 with ( xIntC, yIntC ), ( xFracC, yFracC ) and refPicLXCb given as input.


       - The prediction sample value predPartLXCr[ xC, yC ] is derived by invoking the process specified in
clause 8.4.2.2.2 with ( xIntC, yIntC ), ( xFracC, yFracC ) and refPicLXCr given as input.


    - Otherwise (ChromaArrayType is equal to 3), the following applies:


       - The prediction sample value predPartLXCb[ xC, yC ] is derived by invoking the process specified in
clause 8.4.2.2.1 with ( xIntC, yIntC ), ( xFracC, yFracC ) and refPicLXCb given as input.


       - The prediction sample value predPartLXCr[ xC, yC ] is derived by invoking the process specified in
clause 8.4.2.2.1 with ( xIntC, yIntC ), ( xFracC, yFracC ) and refPicLXCr given as input.


**8.4.2.2.1** **Luma sample interpolation process**


Inputs to this process are:


- a luma location in full-sample units ( xIntL, yIntL ),


- a luma location offset in fractional-sample units ( xFracL, yFracL ),


- the luma sample array of the selected reference picture refPicLXL.


Output of this process is a predicted luma sample value predPartLXL[ xL, yL ].





A


C



aa


bb



B


D


















|G|a|b|c|H|
|---|---|---|---|---|
|d|e|f|g||
|h|i|j|k|m|
|n|p|q|r||
|M||s||N|



R


T



gg


hh



S


U



**Figure 8-4 – Integer samples (shaded blocks with upper-case letters) and fractional sample positions (un-shaded**

**blocks with lower-case letters) for quarter sample luma interpolation**


The variable refPicHeightEffectiveL, which is the height of the effective reference picture luma array, is derived as follows:

- If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, refPicHeightEffectiveL is set equal to
PicHeightInSamplesL.

- Otherwise (MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1), refPicHeightEffectiveL is set
equal to PicHeightInSamplesL / 2.


In Figure 8-4, the positions labelled with upper-case letters within shaded blocks represent luma samples at full-sample
locations inside the given two-dimensional array refPicLXL of luma samples. These samples may be used for generating
the predicted luma sample value predPartLXL[ xL, yL ]. The locations ( xZL, yZL ) for each of the corresponding luma
samples Z, where Z may be A, B, C, D, E, F, G, H, I, J, K, L, M, N, P, Q, R, S, T, or U, inside the given array refPicLXL
of luma samples are derived as:


xZL = Clip3( 0, PicWidthInSamplesL − 1, xIntL + xDZL ) (8-239)
yZL = Clip3( 0, refPicHeightEffectiveL − 1, yIntL + yDZL ) (8-240)


Table 8-11 specifies ( xDZL, yDZL ) for different replacements of Z.


**Table 8-11 – Differential full-sample luma locations**

|Z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|P|Q|R|S|T|U|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|xDZL|0|1|0|1|−2|−1|0|1|2|3|−2|−1|0|1|2|3|0|1|0|1|
|yDZL|−2|−2|−1|−1|0|0|0|0|0|0|1|1|1|1|1|1|2|2|3|3|



Given the luma samples 'A' to 'U' at full-sample locations ( xAL, yAL ) to ( xUL, yUL ), the luma samples 'a' to 's' at
fractional sample positions are derived by the following rules. The luma prediction values at half sample positions are
derived by applying a 6-tap filter with tap values ( 1, −5, 20, 20, −5, 1 ). The luma prediction values at quarter sample





positions are derived by averaging samples at full and half sample positions. The process for each fractional position is
described below.

- The samples at half sample positions labelled b are derived by first calculating intermediate values denoted as b1 by
applying the 6-tap filter to the nearest integer position samples in the horizontal direction. The samples at half sample
positions labelled h are derived by first calculating intermediate values denoted as h1 by applying the 6-tap filter to
the nearest integer position samples in the vertical direction:


b1 = ( E − 5 * F + 20 * G + 20 * H − 5 * I + J ) (8-241)
h1 = ( A − 5 * C + 20 * G + 20 * M − 5 * R + T ) (8-242)


The final prediction values b and h are derived using


b = Clip1Y( ( b1 + 16 ) >> 5 ) (8-243)
h = Clip1Y( ( h1 + 16 ) >> 5 ) (8-244)


- The samples at half sample position labelled as j are derived by first calculating intermediate value denoted as j1 by
applying the 6-tap filter to the intermediate values of the closest half sample positions in either the horizontal or
vertical direction because these yield an equal result:


j1 = cc − 5 * dd + 20 * h1 + 20 * m1 − 5 * ee + ff, or (8-245)
j1 = aa − 5 * bb + 20 * b1 + 20 * s1 − 5 * gg + hh (8-246)


where intermediate values denoted as aa, bb, gg, s1 and hh are derived by applying the 6-tap filter horizontally in the
same manner as the derivation of b1 and intermediate values denoted as cc, dd, ee, m1 and ff are derived by applying
the 6-tap filter vertically in the same manner as the derivation of h1. The final prediction value j are derived using


j = Clip1Y( ( j1 + 512 ) >> 10 ) (8-247)


- The final prediction values s and m are derived from s1 and m1 in the same manner as the derivation of b and h, as
given by


s = Clip1Y( ( s1 + 16 ) >> 5 ) (8-248)
m = Clip1Y( ( m1 + 16 ) >> 5 ) (8-249)


- The samples at quarter sample positions labelled as a, c, d, n, f, i, k, and q are derived by averaging with upward
rounding of the two nearest samples at integer and half sample positions using


a = ( G + b + 1 ) >> 1 (8-250)
c = ( H + b + 1 ) >> 1 (8-251)
d = ( G + h + 1 ) >> 1 (8-252)
n = ( M + h + 1 ) >> 1 (8-253)
f = ( b + j + 1 ) >> 1 (8-254)
i = ( h + j + 1 ) >> 1 (8-255)
k = ( j + m + 1 ) >> 1 (8-256)
q = ( j + s + 1 ) >> 1 (8-257)


- The samples at quarter sample positions labelled as e, g, p, and r are derived by averaging with upward rounding of
the two nearest samples at half sample positions in the diagonal direction using


e = ( b + h + 1 ) >> 1 (8-258)
g = ( b + m + 1 ) >> 1 (8-259)
p = ( h + s + 1 ) >> 1 (8-260)
r = ( m + s + 1 ) >> 1. (8-261)


The luma location offset in fractional-sample units ( xFracL, yFracL ) specifies which of the generated luma samples at
full-sample and fractional-sample locations is assigned to the predicted luma sample value predPartLXL[ xL, yL ]. This
assignment is done according to Table 8-12. The value of predPartLXL[ xL, yL ] is the output.





**Table 8-12 – Assignment of the luma prediction sample predPartLXL[ xL, yL ]**

|xFrac<br>L|0|0|0|0|1|1|1|1|2|2|2|2|3|3|3|3|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|yFracL|0|1|2|3|0|1|2|3|0|1|2|3|0|1|2|3|
|predPartLXL[ xL, yL ]|G|d|h|n|a|e|i|p|b|f|j|q|c|g|k|r|



**8.4.2.2.2** **Chroma sample interpolation process**


This process is only invoked when ChromaArrayType is equal to 1 or 2.


Inputs to this process are:


- a chroma location in full-sample units ( xIntC, yIntC ),


- a chroma location offset in fractional-sample units ( xFracC, yFracC ),


- chroma component samples from the selected reference picture refPicLXC.


Output of this process is a predicted chroma sample value predPartLXC[ xC, yC ].


In Figure 8-5, the positions labelled with A, B, C, and D represent chroma samples at full-sample locations inside the given
two-dimensional array refPicLXC of chroma samples.


**Figure 8-5 – Fractional sample position dependent variables in chroma interpolation and surrounding integer**

**position samples A, B, C, and D**


The variable refPicHeightEffectiveC, which is the height of the effective reference picture chroma array, is derived as
follows:

- If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, refPicHeightEffectiveC is set equal to
PicHeightInSamplesC.

- Otherwise (MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1), refPicHeightEffectiveC is set
equal to PicHeightInSamplesC / 2.


The sample coordinates specified in Equations 8-262 through 8-269 are used for generating the predicted chroma sample
value predPartLXC[ xC, yC ].


xAC = Clip3( 0, PicWidthInSamplesC − 1, xIntC ) (8-262)
xBC = Clip3( 0, PicWidthInSamplesC − 1, xIntC + 1 ) (8-263)
xCC = Clip3( 0, PicWidthInSamplesC − 1, xIntC ) (8-264)
xDC = Clip3( 0, PicWidthInSamplesC − 1, xIntC + 1 ) (8-265)


yAC = Clip3( 0, refPicHeightEffectiveC − 1, yIntC ) (8-266)
yBC = Clip3( 0, refPicHeightEffectiveC − 1, yIntC ) (8-267)
yCC = Clip3( 0, refPicHeightEffectiveC − 1, yIntC + 1 ) (8-268)
yDC = Clip3( 0, refPicHeightEffectiveC − 1, yIntC + 1 ) (8-269)





Given the chroma samples A, B, C, and D at full-sample locations specified in Equations 8-262 through 8-269, the
predicted chroma sample value predPartLXC[ xC, yC ] is derived as:


predPartLXC[ xC, yC ] = ( ( 8 − xFracC ) * ( 8 − yFracC ) * A + xFracC * ( 8 − yFracC ) * B +
( 8 − xFracC ) * yFracC * C      + xFracC * yFracC * D      + 32 ) >> 6 (8-270)


**8.4.2.3** **Weighted sample prediction process**


Inputs to this process are:


- mbPartIdx: the current partition given by the partition index,


- subMbPartIdx: the sub-macroblock partition index,


- predFlagL0 and predFlagL1: prediction list utilization flags,


- predPartLXL: a (partWidth)x(partHeight) array of prediction luma samples (with LX being replaced by L0 or L1
depending on predFlagL0 and predFlagL1),


- when ChromaArrayType is not equal to 0, predPartLXCb and predPartLXCr: (partWidthC)x(partHeightC) arrays of
prediction chroma samples, one for each of the chroma components Cb and Cr (with LX being replaced by L0 or L1
depending on predFlagL0 and predFlagL1),


- variables for weighted prediction logWDC, w0C, w1C, o0C, o1C with C being replaced by L and, when
ChromaArrayType is not equal to 0, Cb and Cr.


Outputs of this process are:


- predPartL: a (partWidth)x(partHeight) array of prediction luma samples,


- when ChromaArrayType is not equal to 0, predPartCb, and predPartCr: (partWidthC)x(partHeightC) arrays of
prediction chroma samples, one for each of the chroma components Cb and Cr.


For macroblocks or partitions with predFlagL0 equal to 1 in P and SP slices, the following applies:


- If weighted_pred_flag is equal to 0, the default weighted sample prediction process as described in clause 8.4.2.3.1 is
invoked with the same inputs and outputs as the process described in this clause.


- Otherwise (weighted_pred_flag is equal to 1), the explicit weighted sample prediction process as described in
clause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause.


For macroblocks or partitions with predFlagL0 or predFlagL1 equal to 1 in B slices, the following applies:


- If weighted_bipred_idc is equal to 0, the default weighted sample prediction process as described in clause 8.4.2.3.1
is invoked with the same inputs and outputs as the process described in this clause.


- Otherwise, if weighted_bipred_idc is equal to 1, the explicit weighted sample prediction process as described in
clause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause.


- Otherwise (weighted_bipred_idc is equal to 2), the following applies:


   - If predFlagL0 is equal to 1 and predFlagL1 is equal to 1, the implicit weighted sample prediction process as
described in clause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause.


   - Otherwise (predFlagL0 or predFlagL1 are equal to 1 but not both), the default weighted sample prediction
process as described in clause 8.4.2.3.1 is invoked with the same inputs and outputs as the process described in
this clause.


**8.4.2.3.1** **Default weighted sample prediction process**


Input to this process are the same as specified in clause 8.4.2.3.


Output of this process are the same as specified in clause 8.4.2.3.


Depending on the available component for which the prediction block is derived, the following applies:


- If the luma sample prediction values predPartL[ x, y ] are derived, the following applies with C set equal to L, x set
equal to 0..partWidth − 1, and y set equal to 0..partHeight − 1.


- Otherwise, if the chroma Cb component sample prediction values predPartCb[ x, y ] are derived, the following applies
with C set equal to Cb, x set equal to 0..partWidthC − 1, and y set equal to 0..partHeightC − 1.


- Otherwise (the chroma Cr component sample prediction values predPartCr[ x, y ] are derived), the following applies
with C set equal to Cr, x set equal to 0..partWidthC − 1, and y set equal to 0..partHeightC − 1.





The prediction sample values are derived as follows:


- If predFlagL0 is equal to 1 and predFlagL1 is equal to 0,


predPartC[ x, y ] = predPartL0C[ x, y ] (8-271)


- Otherwise, if predFlagL0 is equal to 0 and predFlagL1 is equal to 1,


predPartC[ x, y ]= predPartL1C[ x, y ] (8-272)


- Otherwise (predFlagL0 and predFlagL1 are equal to 1),


predPartC[ x, y ] = ( predPartL0C[ x, y ] + predPartL1C[ x, y ] + 1 ) >> 1. (8-273)


**8.4.2.3.2** **Weighted sample prediction process**


Inputs to this process are the same as specified in clause 8.4.2.3.


Outputs of this process are the same as specified in clause 8.4.2.3.


Depending on the available component for which the prediction block is derived, the following applies:


- If the luma sample prediction values predPartL[ x, y ] are derived, the following applies with C set equal to L, x set
equal to 0..partWidth − 1, y set equal to 0..partHeight − 1, and Clip1( ) being substituted with Clip1Y( ).


- Otherwise, if the chroma Cb component sample prediction values predPartCb[ x, y ] are derived, the following applies
with C set equal to Cb, x set equal to 0..partWidthC − 1, y set equal to 0..partHeightC − 1, and Clip1( ) being
substituted with Clip1C( ).


- Otherwise (the chroma Cr component sample prediction values predPartCr[ x, y ] are derived), the following applies
with C set equal to Cr, x set equal to 0..partWidthC − 1, y set equal to 0..partHeightC − 1, and Clip1( ) being
substituted with Clip1C( ).


The prediction sample values are derived as follows:


- If the predFlagL0 is equal to 1 and predFlagL1 is equal to 0, the final predicted sample values predPartC[ x, y ] are
derived by


if( logWDC >= 1 )
predPartC[ x, y ] = Clip1( ( ( predPartL0C[ x, y ] * w0C + 2 [logWDC − 1] ) >> logWDC ) + o0C )
else (8-274)
predPartC[ x, y ] = Clip1( predPartL0C[ x, y ] * w0C + o0C )


- Otherwise, if the predFlagL0 is equal to 0 and predFlagL1 is equal to 1, the final predicted sample values
predPartC[ x, y ] are derived by


if( logWDC >= 1 )
predPartC[ x, y ] = Clip1( ( ( predPartL1C[ x, y ] * w1C + 2 [logWDC − 1] ) >> logWDC ) + o1C )
else (8-275)
predPartC[ x, y ] = Clip1( predPartL1C[ x, y ] * w1C + o1C )


- Otherwise (both predFlagL0 and predFlagL1 are equal to 1), the final predicted sample values predPartC[ x, y ] are
derived by


predPartC[ x, y ] = Clip1( ( ( predPartL0C[ x, y ] * w0C + predPartL1C[ x, y ] * w1C + 2 [logWDC] ) >>
( logWDC + 1 ) ) + ( ( o0C + o1C + 1 ) >> 1 ) ) (8-276)


**8.4.3** **Derivation process for prediction weights**


Inputs to this process are:


- the reference indices refIdxL0 and refIdxL1,


- the prediction utilization flags predFlagL0 and predFlagL1.


Outputs of this process are variables for weighted prediction logWDC, w0C, w1C, o0C, o1C with C being replaced by L and,
when ChromaArrayType is not equal to 0, Cb and Cr.

The variables implicitModeFlag and explicitModeFlag are derived as follows:





- If weighted_bipred_idc is equal to 2, (slice_type % 5) is equal to 1, predFlagL0 is equal to 1, and predFlagL1 is equal
to 1, implicitModeFlag is set equal to 1 and explicitModeFlag is set equal to 0.


- Otherwise, if weighted_bipred_idc is equal to 1, (slice_type % 5) is equal to 1, and predFlagL0 + predFlagL1 is equal
to 1 or 2, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 1.


- Otherwise, if weighted_pred_flag is equal to 1, (slice_type % 5) is equal to 0 or 3, and predFlagL0 is equal to 1,
implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 1.


- Otherwise, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 0.

For C being replaced by L and, when ChromaArrayType is not equal to 0, Cb and Cr, the variables logWDC, w0C, w1C,
o0C, o1C are derived as follows:


- If implicitModeFlag is equal to 1, implicit mode weighted prediction is used as follows:


logWDC = 5 (8-277)


o0C = 0 (8-278)


o1C = 0 (8-279)


and w0C and w1C are derived as specified in the following ordered steps:


1. The variables currPicOrField, pic0, and pic1 are derived as follows:


      - If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies:


a. currPicOrField is the field of the current picture CurrPic that has the same parity as the current
macroblock.


b. The variable pic0 is derived as follows:

            - If refIdxL0 % 2 is equal to 0, pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the same
parity as the current macroblock.

            - Otherwise (refIdxL0 % 2 is not equal to 0), pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that
has the opposite parity of the current macroblock.


c. The variable pic1 is derived as follows:

            - If refIdxL1 % 2 is equal to 0, pic1 is the field of RefPicList1[ refIdxL1 / 2 ] that has the same
parity as the current macroblock.

            - Otherwise (refIdxL1 % 2 is not equal to 0), pic1 is the field of RefPicList1[ refIdxL1 / 2 ] that
has the opposite parity of the current macroblock.


      - Otherwise (field_pic_flag is equal to 1 or the current macroblock is a frame macroblock), currPicOrField
is the current picture CurrPic, pic1 is RefPicList1[ refIdxL1 ], and pic0 is RefPicList0[ refIdxL0 ].


2. The variables w0C and w1C are derived as follows:


      - If DiffPicOrderCnt( pic1, pic0 ) is equal to 0 or one or both of pic1 and pic0 is marked as "used for
long-term reference" or ( DistScaleFactor >> 2 ) < −64 or ( DistScaleFactor >> 2 ) > 128, w0C and w1C are
derived as:


w0C = 32 (8-280)


w1C = 32 (8-281)


      - Otherwise, the variables tb, td, tx, and DistScaleFactor are derived from the values of currPicOrField, pic0,
and pic1 using Equations 8-201, 8-202, 8-197, and 8-198, respectively, and the weights w0C and w1C are
derived as


w0C = 64 − (DistScaleFactor >> 2) (8-282)


w1C = DistScaleFactor >> 2 (8-283)


- Otherwise, if explicitModeFlag is equal to 1, explicit mode weighted prediction is used as specified by the following
ordered steps:
