1. The variables refIdxL0WP and refIdxL1WP are derived as follows:


      - If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock


refIdxL0WP = refIdxL0 >> 1 (8-284)


refIdxL1WP = refIdxL1 >> 1 (8-285)


      - Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock),


refIdxL0WP = refIdxL0 (8-286)


refIdxL1WP = refIdxL1 (8-287)


2. The variables logWDC, w0C, w1C, o0C, and o1C are derived as follows:


      - If C is equal to L for luma samples


logWDC = luma_log2_weight_denom (8-288)


w0C = luma_weight_l0[ refIdxL0WP ] (8-289)


w1C = luma_weight_l1[ refIdxL1WP ] (8-290)


o0C = luma_offset_l0[ refIdxL0WP ] * ( 1 << ( BitDepthY − 8 ) ) (8-291)


o1C = luma_offset_l1[ refIdxL1WP ] * ( 1 << ( BitDepthY − 8 ) ) (8-292)


      - Otherwise (C is equal to Cb or Cr for chroma samples, with iCbCr = 0 for Cb, iCbCr = 1 for Cr),


logWDC = chroma_log2_weight_denom (8-293)


w0C = chroma_weight_l0[ refIdxL0WP ][ iCbCr ] (8-294)


w1C = chroma_weight_l1[ refIdxL1WP ][ iCbCr ] (8-295)


o0C = chroma_offset_l0[ refIdxL0WP ][ iCbCr ] * ( 1 << ( BitDepthC − 8 ) ) (8-296)


o1C = chroma_offset_l1[ refIdxL1WP ][ iCbCr ] * ( 1 << ( BitDepthC − 8 ) ) (8-297)


- Otherwise (implicitModeFlag is equal to 0 and explicitModeFlag is equal to 0), the variables logWDC, w0C, w1C, o0C,
o1C are not used in the reconstruction process for the current macroblock.


When explicitModeFlag is equal to 1 and predFlagL0 and predFlagL1 are equal to 1, the following constraint shall be
obeyed for C equal to L and, when ChromaArrayType is not equal to 0, Cb and Cr:


−128 <= w0C + w1C <= ( ( logWDC = = 7 ) ? 127 : 128 ) (8-298)


NOTE – For implicitModeFlag equal to 1, weights w0C and w1C are each guaranteed to be in the range of −64..128 and the constraint
expressed in Equation 8-298, although not explicitly imposed, will always be met. For explicitModeFlag equal to 1 with logWDC
equal to 7, when one of the two weights w0C or w1C is inferred to be equal to 128 (as a consequence of luma_weight_l0_flag,
luma_weight_l1_flag, chroma_weight_l0_flag, or chroma_weight_l1_flag equal to 0), the other weight (w1C or w0C) must have a
negative value in order for the constraint expressed in Equation 8-298 to hold (and therefore the other flag luma_weight_l0_flag,
luma_weight_l1_flag, chroma_weight_l0_flag, or chroma_weight_l1_flag must be equal to 1).


**8.5** **Transform coefficient decoding process and picture construction process prior to deblocking**
**filter process**


Inputs to this process are Intra16x16DCLevel (if available), Intra16x16ACLevel (if available), CbIntra16x16DCLevel (if
available), CbIntra16x16ACLevel (if available), CrIntra16x16DCLevel (if available), CrIntra16x16ACLevel (if available),
LumaLevel4x4 (if available), LumaLevel8x8 (if available), ChromaDCLevel (if available), ChromaACLevel (if available),
CbLevel4x4 (if available), CrLevel4x4 (if available), CbLevel8x8 (if available), CrLevel8x8 (if available), and available
Inter or Intra prediction sample arrays for the current macroblock for the applicable components predL, predCb, or predCr.

NOTE 1 – When decoding a macroblock in Intra_4x4 (or Intra_8x8) macroblock prediction mode, the luma component of the
macroblock prediction array may not be complete, since for each 4x4 (or 8x8) luma block, the Intra_4x4 (or Intra_8x8) prediction





process for luma samples as specified in clause 8.3.1 (or 8.3.2) and the process specified in this clause are iterated. When
ChromaArrayType is equal to 3, the Cb and Cr component of the macroblock prediction array may not be complete for the same
reason.


Outputs of this process are the constructed sample arrays prior to the deblocking filter process for the applicable
components S′L, S′Cb, or S′Cr.

NOTE 2 – When decoding a macroblock in Intra_4x4 (or Intra_8x8) macroblock prediction mode, the luma component of the
macroblock constructed sample arrays prior to the deblocking filter process may not be complete, since for each 4x4 (or 8x8) luma
block, the Intra_4x4 (or Intra_8x8) prediction process for luma samples as specified in clause 8.3.1 (or 8.3.2) and the process
specified in this clause are iterated. When ChromaArrayType is equal to 3, the Cb and Cr component of the macroblock constructed
sample arrays prior to the deblocking filter process may not be complete for the same reason.


This clause specifies transform coefficient decoding and picture construction prior to the deblocking filter process.


When the current macroblock is coded as P_Skip or B_Skip, all values of LumaLevel4x4, LumaLevel8x8, CbLevel4x4,
CbLevel8x8, CrLevel4x4, CrLevel8x8, ChromaDCLevel, ChromaACLevel are set equal to 0 for the current macroblock.


**8.5.1** **Specification of transform decoding process for 4x4 luma residual blocks**


This specification applies when transform_size_8x8_flag is equal to 0.


When the current macroblock prediction mode is not equal to Intra_16x16, the variable LumaLevel4x4 contains the levels
for the luma transform coefficients. For a 4x4 luma block indexed by luma4x4BlkIdx = 0..15, the following ordered steps
are specified:


1. The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked
with LumaLevel4x4[ luma4x4BlkIdx ] as the input and the two-dimensional array c as the output.


2. The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c as
the input and r as the output.


3. When TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to Intra_4x4, and
Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 0 or 1, the intra residual transform-bypass decoding process as
specified in clause 8.5.15 is invoked with nW set equal to 4, nH set equal to 4, horPredFlag set equal to
Intra4x4PredMode[ luma4x4BlkIdx ], and the 4x4 array r as the inputs, and the output is a modified version of the
4x4 array r.


4. The position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the macroblock is
derived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as the input
and the output being assigned to ( xO, yO ).


5. The 4x4 array u with elements uij for i, j = 0..3 is derived as:


uij = Clip1Y( predL[ xO + j, yO + i ] + rij ) (8-299)


When TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of uij as
computed by Equation 8-299 that is not equal to predL[ xO + j, yO + i ] + rij.


6. The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u and
luma4x4BlkIdx as the inputs.


**8.5.2** **Specification of transform decoding process for luma samples of Intra_16x16 macroblock prediction mode**


When the current macroblock prediction mode is equal to Intra_16x16, the variables Intra16x16DCLevel and
Intra16x16ACLevel contain the levels for the luma transform coefficients. The transform coefficient decoding proceeds in
the following ordered steps:


1. The 4x4 luma DC transform coefficients of all 4x4 luma blocks of the macroblock are decoded.


a. The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is

invoked with Intra16x16DCLevel as the input and the two-dimensional array c as the output.


b. The scaling and transformation process for luma DC transform coefficients for Intra_16x16 macroblock type

as specified in clause 8.5.10 is invoked with BitDepthY, QP′Y, and c as the input and dcY as the output.


2. The 16x16 array rMb is derived by processing the 4x4 luma blocks indexed by luma4x4BlkIdx = 0..15, and for

each 4x4 luma block, the following ordered steps are specified:


a. The variable lumaList, which is a list of 16 entries, is derived. The first entry of lumaList is the corresponding

value from the array dcY. Figure 8-6 shows the assignment of the indices of the array dcY to the





luma4x4BlkIdx. The two numbers in the small squares refer to indices i and j in dcYij, and the numbers in
large squares refer to luma4x4BlkIdx.

|Col1|Col2|Col3|03|
|---|---|---|---|
|11|12||13|
|21|22||23|
|21|22|33|33|



**Figure 8-6 – Assignment of the indices of dcY to luma4x4BlkIdx**


The elements in lumaList with index k = 1..15 are specified as:


lumaList[ k ] = Intra16x16ACLevel[ luma4x4BlkIdx ][ k − 1 ] (8-300)


b. The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is

invoked with lumaList as the input and the two-dimensional array c as the output.


c. The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c

as the input and r as the output.


d. The position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the macroblock

is derived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as
the input and the output being assigned to ( xO, yO ).


e. The elements rMb[ x, y ] of the 16x16 array rMb with x = xO..xO + 3 and y = yO..yO + 3 are derived by


rMb[ xO + j, yO + i ] = rij (8-301)


3. When TransformBypassModeFlag is equal to 1 and Intra16x16PredMode is equal to 0 or 1, the intra residual

transform-bypass decoding process as specified in clause 8.5.15 is invoked with nW set equal to 16, nH set equal
to 16, horPredFlag set equal to Intra16x16PredMode, and the 16x16 array rMb as the inputs, and the output is a
modified version of the 16x16 array rMb.


4. The 16x16 array u with elements uij for i, j = 0..15 is derived as


uij = Clip1Y( predL[ j, i ] + rMb[ j, i ] ) (8-302)


When TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of uij as
computed by Equation 8-302 that is not equal to predL[ j, i ] + rMb[ j, i ].


5. The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u as the input.


**8.5.3** **Specification of transform decoding process for 8x8 luma residual blocks**


This specification applies when transform_size_8x8_flag is equal to 1.


The variable LumaLevel8x8[ luma8x8BlkIdx ] with luma8x8BlkIdx = 0..3 contains the levels for the luma transform
coefficients for the luma 8x8 block with index luma8x8BlkIdx.


For an 8x8 luma block indexed by luma8x8BlkIdx = 0..3, the following ordered steps are specified:


1. The inverse scanning process for 8x8 transform coefficients and scaling lists as specified in clause 8.5.7 is invoked

with LumaLevel8x8[ luma8x8BlkIdx ] as the input and the two-dimensional array c as the output.


2. The scaling and transformation process for residual 8x8 blocks as specified in clause 8.5.13 is invoked with c as

the input and r as the output.





3. When TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to Intra_8x8, and

Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 0 or 1, the intra residual transform-bypass decoding process as
specified in clause 8.5.15 is invoked with nW set equal to 8, nH set equal to 8, horPredFlag set equal to
Intra8x8PredMode[ luma8x8BlkIdx ], and the 8x8 array r as the inputs, and the output is a modified version of the
8x8 array r.


4. The position of the upper-left sample of an 8x8 luma block with index luma8x8BlkIdx inside the macroblock is

derived by invoking the inverse 8x8 luma block scanning process in clause 6.4.5 with luma8x8BlkIdx as the input
and the output being assigned to ( xO, yO ).


5. The 8x8 array u with elements uij for i, j = 0..7 is derived as:


uij = Clip1Y( predL[ xO + j, yO + i ] + rij ) (8-303)


When TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of uij as
computed by Equation 8-303 that is not equal to predL[ xO + j, yO + i ] + rij.


6. The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u and

luma8x8BlkIdx as the inputs.


**8.5.4** **Specification of transform decoding process for chroma samples**


This process is invoked for each chroma component Cb and Cr separately when ChromaArrayType is not equal to 0.


Depending on ChromaArrayType, the following applies:


- If ChromaArrayType is equal to 3, the transform decoding process for chroma samples with ChromaArrayType equal
to 3 as specified in clause 8.5.5 is invoked.


- Otherwise (ChromaArrayType is not equal to 3), the following text specifies the transform decoding process for
chroma samples.


For each chroma component, the variables ChromaDCLevel[ iCbCr ] and ChromaACLevel[ iCbCr ], with iCbCr set equal
to 0 for Cb and iCbCr set equal to 1 for Cr, contain the levels for both components of the chroma transform coefficients.


Let the variable numChroma4x4Blks be set equal to (MbWidthC / 4) * (MbHeightC / 4).


For each chroma component, the transform decoding proceeds separately in the following ordered steps:


1. The numChroma4x4Blks chroma DC transform coefficients of the 4x4 chroma blocks of the component indexed

by iCbCr of the macroblock are decoded as specified in the following ordered steps:


a. Depending on the variable ChromaArrayType, the following applies:


      - If ChromaArrayType is equal to 1, the 2x2 array c is derived using the inverse raster scanning process
applied to ChromaDCLevel as follows:



 ChromaDCLevel[ iCbCr ][ 0 ] ChromaDCLevel[ iCbCr ][ 1]
=

 ChromaDCLevel[ iCbCr ][ 2 ] ChromaDCLevel[ iCbCr ][3]



 ChromaDCLevel[ iCbCr ][ 0 ] ChromaDCLevel[ iCbCr ][ 1] 

 ChromaDCLevel[ iCbCr ][ 2 ] ChromaDCLevel[ iCbCr ][3] 



c =  ChromaDCLevel[ iCbCr ][ 0 ] ChromaDCLevel[ iCbCr ][ 1]  (8-304)








- Otherwise (ChromaArrayType is equal to 2), the 2x4 array c is derived using the inverse raster

scanning process applied to ChromaDCLevel as follows:














=














ChromaDCLevel[ iCbCr ][0 ] ChromaDCLevel[iCbCr ][ 2 ]

ChromaDCLevel[ iCbCr ][1 ] ChromaDCLevel[ iCbCr ][5]

ChromaDCLevel[ iCbCr ][3] ChromaDCLevel[ iCbCr ][6 ]

ChromaDCLevel[ iCbCr ][ 4 ] ChromaDCLevel[iCbCr ][7 ]



c = (8-305)



b. The scaling and transformation process for chroma DC transform coefficients as specified in clause 8.5.11 is
invoked with c as the input and dcC as the output.


2. The (MbWidthC)x(MbHeightC) array rMb is derived by processing the 4x4 chroma blocks indexed by

chroma4x4BlkIdx = 0..numChroma4x4Blks − 1 of the component indexed by iCbCr, and for each 4x4 chroma
block, the following ordered steps are specified:


a. The variable chromaList, which is a list of 16 entries, is derived. The first entry of chromaList is the
corresponding value from the array dcC. Figure 8-7 shows the assignment of the indices of the array dcC to





the chroma4x4BlkIdx. The two numbers in the small squares refer to indices i and j in dcCij, and the numbers
in large squares refer to chroma4x4BlkIdx.





















H.264(09)_F8-7

**a** **b**


**Figure 8-7 – Assignment of the indices of dcC to chroma4x4BlkIdx:**
**(a) ChromaArrayType equal to 1, (b) ChromaArrayType equal to 2**


The elements in chromaList with index k = 1..15 are specified as:


chromaList[ k ] = ChromaACLevel[ chroma4x4BlkIdx ][ k − 1 ] (8-306)


b. The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is

invoked with chromaList as the input and the two-dimensional array c as the output.


c. The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with
c as the input and r as the output.


d. The position of the upper-left sample of a 4x4 chroma block with index chroma4x4BlkIdx inside the current

macroblock is derived by invoking the inverse 4x4 chroma block scanning process as specified in clause 6.4.7
with chroma4x4BlkIdx as the input and the output being assigned to ( xO, yO ).


e. The elements rMb[ x, y ] of the (MbWidthC)x(MbHeightC) array rMb with x = xO..xO + 3 and
y = yO..yO + 3 are derived by:


rMb[ xO + j, yO + i ] = rij (8-307)


3. When TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to Intra_4x4, Intra_8x8,

or Intra_16x16, and intra_chroma_pred_mode is equal to 1 or 2, the intra residual transform-bypass decoding
process as specified in clause 8.5.15 is invoked with nW set equal to MbWidthC, nH set equal to MbHeightC,
horPredFlag set equal to (2 − intra_chroma_pred_mode), and the (MbWidthC)x(MbHeightC) array rMb as the
inputs, and the output is a modified version of the (MbWidthC)x(MbHeightC) array rMb.


4. The (MbWidthC)x(MbHeightC) array u with elements uij for i = 0..MbHeightC − 1 and j = 0..MbWidthC − 1 is

derived as:


uij = Clip1C( predC[ j, i ] + rMb[ j, i ] ) (8-308)


When TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of uij as
computed by Equation 8-308 that is not equal to predC[ j, i ] + rMb[ j, i ].


5. The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u as the input.





**8.5.5** **Specification of transform decoding process for chroma samples with ChromaArrayType equal to 3**


This process is invoked for each chroma component Cb and Cr separately when ChromaArrayType is equal to 3.


Depending on the macroblock prediction mode and transform_size_8x8_flag, the following applies:


- If the macroblock prediction mode is equal to Intra_16x16, the transform decoding process for Cb or Cr residual
blocks shall be identical to the process described in clause 8.5.2 when substituting luma with Cb or Cr, substituting
Intra16x16DCLevel with CbIntra16x16DCLevel or CrIntra16x16DCLevel, substituting Intra16x16ACLevel with
CbIntra16x16ACLevel or CrIntra16x16ACLevel, and substituting predL with predCb or predCr, substituting
luma4x4BlkIdx with cb4x4BlkIdx or cr4x4BlkIdx, substituting lumaList with CbList or CrList, substituting BitDepthY
with BitDepthC, substituting QP′Y with QP′C, and substituting Clip1Y with Clip1C. During the scaling of 4x4 block
transform coefficient levels that is specified in clause 8.5.12.1, which is invoked as part of the process specified in
clause 8.5.2, the input 4x4 array c is treated as relating to a luma residual block coded using an Intra_16x16 macroblock
prediction mode.


- Otherwise, if transform_size_8x8_flag is equal to 1, the transform decoding process for 8x8 Cb or 8x8 Cr residual
blocks shall be identical to the process described in clause 8.5.3 when substituting luma with Cb or Cr, substituting
LumaLevel8x8 with CbLevel8x8 or CrLevel8x8, substituting predL with predCb or predCr, substituting luma8x8BlkIdx
with cb8x8BlkIdx or cr8x8BlkIdx, and substituting Clip1Y with Clip1C _._


- Otherwise (the macroblock prediction mode is not equal to Intra_16x16 and transform_size_8x8_flag is equal to 0),
the transform decoding process for 4x4 Cb or 4x4 Cr residual blocks shall be identical to the process described in
clause 8.5.1 when substituting luma with Cb or Cr, substituting LumaLevel4x4 with CbLevel4x4 or CrLevel4x4,
substituting predL with predCb or predCr, substituting luma4x4BlkIdx with cb4x4BlkIdx or cr4x4BlkIdx, and
substituting Clip1Y with Clip1C. During the scaling of 4x4 block transform coefficient levels that is specified in
clause 8.5.12.1, which is invoked as part of the process specified in clause 8.5.1, the input 4x4 array c is treated as
relating to a luma residual block not coded using an Intra_16x16 macroblock prediction mode.


**8.5.6** **Inverse scanning process for 4x4 transform coefficients and scaling lists**


Input to this process is a list of 16 values.


Output of this process is a variable c containing a two-dimensional array of 4x4 values. In the case of transform coefficients,
these 4x4 values represent levels assigned to locations in the transform block. In the case of applying the inverse scanning
process to a scaling list, the output variable c contains a two-dimensional array representing a 4x4 scaling matrix.


When this clause is invoked with a list of transform coefficient levels as the input, the sequence of transform coefficient
levels is mapped to the transform coefficient level positions. Table 8-13 specifies the two mappings: inverse zig-zag scan
and inverse field scan. The inverse zig-zag scan is used for transform coefficients in frame macroblocks and the inverse
field scan is used for transform coefficients in field macroblocks.


When this clause is invoked with a scaling list as the input, the sequence of scaling list entries is mapped to the positions
in the corresponding scaling matrix. For this mapping, the inverse zig-zag scan is used.


Figure 8-8 illustrates the scans.



2 4 7 12



0 2 8 12



9 10 14 15 4 7 11 15
**a** **b**



**Figure 8-8 – 4x4 block scans. (a) Zig-zag scan. (b) Field scan (informative)**


Table 8-13 provides the mapping from the index idx of input list of 16 elements to indices i and j of the two-dimensional
array c.





**Table 8-13 – Specification of mapping of idx to cij for zig-zag and field scan**

|idx|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**zig-zag**|c00|c01|c10|c20|c11|c02|c03|c12|c21|c30|c31|c22|c13|c23|c32|c33|
|**field**|c00|c10|c01|c20|c30|c11|c21|c31|c02|c12|c22|c32|c03|c13|c23|c33|



**8.5.7** **Inverse scanning process for 8x8 transform coefficients and scaling lists**


Input to this process is a list of 64 values.


Output of this process is a variable c containing a two-dimensional array of 8x8 values. In the case of transform coefficients,
these 8x8 values represent levels assigned to locations in the transform block. In the case of applying the inverse scanning
process to a scaling list, the output variable c contains a two-dimensional array representing an 8x8 scaling matrix.


When this clause is invoked with a list of transform coefficient levels as the input, the sequence of transform coefficient
levels is mapped to the transform coefficient level positions. Table 8-14 specifies the two mappings: inverse 8x8 zig-zag
scan and inverse 8x8 field scan. The inverse 8x8 zig-zag scan is used for transform coefficient levels in frame macroblocks
and the inverse 8x8 field scan is used for transform coefficient levels in field macroblocks.


When this clause is invoked with a scaling list as the input, the sequence of scaling list entries is mapped to the positions
in the corresponding scaling matrix. For this mapping, the inverse zig-zag scan is used.


Figure 8-9 illustrates the scans.



0


2


3


9


10


20


21


35



1


4


8


11


19


22


34


36



5


7


12



48



6


13


17



14


16


25



15


26


30



27


29


41



0



3



8



15



22



30



38



52



18 24 31 40 44



24



31



40



23 32 39



45



52



28


42


43


53


54


60


61



33 38 51 55



38



51



37 47 50 56 59



47



56



49



57 58 62 63 12 19 27 35 43 50 57 63

H.264(09)_F8-9
**a** **b**



57



58



62



63



12



19



27



35



43



50



57



**Figure 8-9 – 8x8 block scans. (a) 8x8 zig-zag scan. (b) 8x8 field scan (informative)**


Table 8-14 provides the mapping from the index idx of the input list of 64 elements to indices i and j of the two-dimensional
array c.





**Table 8-14 – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan**

|idx|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**zig-zag**|c00|c01|c10|c20|c11|c02|c03|c12|c21|c30|c40|c31|c22|c13|c04|c05|
|**field**|c00|c10|c20|c01|c11|c30|c40|c21|c02|c31|c50|c60|c70|c41|c12|c03|



**Table 8-14 (continued) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan**

|idx|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**zig-zag**|c14|c23|c32|c41|c50|c60|c51|c42|c33|c24|c15|c06|c07|c16|c25|c34|
|**field**|c22|c51|c61|c71|c32|c13|c04|c23|c42|c52|c62|c72|c33|c14|c05|c24|



**Table 8-14 (continued) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan**

|idx|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**zig-zag**|c43|c52|c61|c70|c71|c62|c53|c44|c35|c26|c17|c27|c36|c45|c54|c63|
|**field**|c43|c53|c63|c73|c34|c15|c06|c25|c44|c54|c64|c74|c35|c16|c26|c45|



**Table 8-14 (concluded) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan**

|idx|48|49|50|51|52|53|54|55|56|57|58|59|60|61|62|63|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**zig-zag**|c72|c73|c64|c55|c46|c37|c47|c56|c65|c74|c75|c66|c57|c67|c76|c77|
|**field**|c55|c65|c75|c36|c07|c17|c46|c56|c66|c76|c27|c37|c47|c57|c67|c77|



**8.5.8** **Derivation process for chroma quantization parameters**


Outputs of this process are:

- QPC: the chroma quantization parameter for each chroma component Cb and Cr,

- QSC: the additional chroma quantization parameter for each chroma component Cb and Cr required for decoding SP
and SI slices (if applicable).
NOTE 1 – QP quantization parameter values QPY and QSY are always in the range of −QpBdOffsetY to 51, inclusive. QP
quantization parameter values QPC and QSC are always in the range of −QpBdOffsetC to 39, inclusive.


The value of QPC for a chroma component is determined from the current value of QPY and the value of
chroma_qp_index_offset (for Cb) or second_chroma_qp_index_offset (for Cr).

NOTE 2 – The scaling equations are specified such that the equivalent transform coefficient level scaling factor doubles for every
increment of 6 in QPY. Thus, there is an increase in the factor used for scaling of approximately 12 % for each increase of 1 in the
value of QPY.


The value of QPC for each chroma component is determined as specified in Table 8-15 based on the index denoted as qPI.


The variable qPOffset for each chroma component is derived as follows:

- If the chroma component is the Cb component, qPOffset is specified as:


qPOffset = chroma_qp_index_offset (8-309)


- Otherwise (the chroma component is the Cr component), qPOffset is specified as:


qPOffset = second_chroma_qp_index_offset (8-310)


The value of qPI for each chroma component is derived as:


qPI = Clip3( −QpBdOffsetC, 51, QPY + qPOffset ) (8-311)





The value of QP′C for the chroma components is derived as:


QP′C = QPC + QpBdOffsetC (8-312)


**Table 8-15 – Specification of QPC as a function of qPI**




















































|qP<br>I|<30|3<br>0|3<br>1|3<br>2|3<br>3|3<br>4|3<br>5|3<br>6|3<br>7|3<br>8|3<br>9|4<br>0|4<br>1|4<br>2|4<br>3|4<br>4|4<br>5|4<br>6|4<br>7|4<br>8|4<br>9|5<br>0|5<br>1|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|QP<br>C|= qP<br>I|2<br>9|3<br>0|3<br>1|3<br>2|3<br>2|3<br>3|3<br>4|3<br>4|3<br>5|3<br>5|3<br>6|3<br>6|3<br>7|3<br>7|3<br>7|3<br>8|3<br>8|3<br>8|3<br>9|3<br>9|3<br>9|3<br>9|



When the current slice is an SP or SI slice, QSC is derived using the above process, substituting QPY with QSY and QPC
with QSC.


**8.5.9** **Derivation process for scaling functions**


Outputs of this process are:

- LevelScale4x4: the scaling factor for 4x4 block transform luma or chroma coefficient levels,

- LevelScale8x8: the scaling factor for 8x8 block transform luma or chroma coefficient levels.


The variable mbIsInterFlag is derived as follows:

- If the current macroblock is coded using Inter macroblock prediction modes, mbIsInterFlag is set equal to 1.

- Otherwise (the current macroblock is coded using Intra macroblock prediction modes), mbIsInterFlag is set equal
to 0.


The variable iYCbCr derived as follows:

- If separate_colour_plane_flag is equal to 1, iYCbCr is set equal to colour_plane_id.

- Otherwise (separate_colour_plane_flag is equal to 0), the following applies:


   - If the scaling function LevelScale4x4 or LevelScale8x8 is derived for a luma residual block, iYCbCr is set equal
to 0.


   - Otherwise, if the scaling function LevelScale4x4 or LevelScale8x8 is derived for a chroma residual block and
the chroma component is equal to Cb, iYCbCr is set equal to 1.


   - Otherwise (the scaling function LevelScale4x4 or LevelScale8x8 is derived for a chroma residual block and the
chroma component is equal to Cr), iYCbCr is set equal to 2.


The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked with
ScalingList4x4[ iYCbCr + ( (mbIsInterFlag = = 1 ) ? 3 : 0 )] as the input and the output is assigned to the 4x4 matrix
weightScale4x4.


LevelScale4x4( m, i, j ) is specified by:


LevelScale4x4( m, i, j ) = weightScale4x4( i, j ) * normAdjust4x4( m, i, j ) (8-313)


where



normAdjust4x4 ( m,i, j )




= 





v m0 for i (% 2, j % ) 2 equal to (0,0),



v m0 for i (% 2, j % ) 2 equal to (0,0),

v m1 for i (% 2, j % ) 2 equal to (1,1),



v for i (% 2, j % ) 2 equal to (1,1),



(8-314)



v m2 otherwise;



where the first and second subscripts of v are row and column indices, respectively, of the matrix specified as:



=
















v =   . (8-315)







10 16 13

11 18 14

13 20 16

14 23 18

16 25 20

18 29 23























The inverse scanning process for 8x8 transform coefficients and scaling lists as specified in clause 8.5.7 is invoked with
ScalingList8x8[ 2 * iYCbCr + mbIsInterFlag ] as the input and the output is assigned to the 8x8 matrix weightScale8x8.


LevelScale8x8( m, i, j ) is specified by:


LevelScale8x8( m, i, j ) = weightScale8x8( i, j ) * normAdjust8x8( m, i, j ) (8-316)


where



vm0 for i(% j,4 %4 )equal to (0,0),



vm0 for i(% j,4 %4 )equal to (0,0),

vm1 for i(% j,2 %2 )equal to (1,1),



normAdjust8x8 ( m,i, j )



( m,i, j )



=







 []





 [] 



vm1 for i(% j,2 %2 )equal to (1,1),

vm2 for i(% j,4 %4 )equal to (2,2),



v for i(% j,4 %4 )equal to (2,2),



vm3 for i(% j,4 %2 )equal to (0,1) or i(% j,2 %4 )equal to (1,0),



vm3 for i(% j,4 %2 )equal to (0,1) or i(% j,2 %4 )equal to (1,0),

vm4 for i(% j,4 %4 )equal to (0,2) or i(% j,4 %4 )equal to (2,0),



(8-317)



v for i(% j,4 %4 )equal to (0,2) or i(% j,4 %4 )equal to (2,0),



vm5 otherwise;



where the first and second subscripts of v are row and column indices, respectively, of the matrix specified as:



=
















20 18 32 19 25 24

22 19 35 21 28 26

26 23 42 24 33 31



28 25 45 26 35 33



v =   . (8-318)



32 28 51 30 40 38

36 32 58 34 46 43
























**8.5.10** **Scaling and transformation process for DC transform coefficients for Intra_16x16 macroblock type**

Inputs to this process are:


- the variables bitDepth and qP,


- transform coefficient level values for DC transform coefficients of Intra_16x16 macroblocks as a 4x4 array c with
elements cij, where i and j form a two-dimensional frequency index.

Outputs of this process are 16 scaled DC values for 4x4 blocks of Intra_16x16 macroblocks as a 4x4 array dcY with
elements dcYij.


Depending on the value of TransformBypassModeFlag, the following applies:


- If TransformBypassModeFlag is equal to 1, the output dcY is derived as:


dcYij = cij with i, j = 0..3 (8-319)


- Otherwise (TransformBypassModeFlag is equal to 0), the following text of this process specifies the output.


The inverse transform for the 4x4 luma DC transform coefficients is specified by:



c00 c01 c02 c03



c30 c31 c32 c33


















c10 c11 c12 c13



c20 c21 c22 c23



f



1 1  - 1
= 














1 1 1 1

1 1 - 1 - 1

1 - 1 - 1 1

1 - 1 1 - 1




- 1


. (8-320)



1 1  - 1
 




- 1



- 1 1














































1 1 1 1

1 1 - 1 - 1

1 - 1 - 1 1

1 - 1 1 - 1




- 1 1


The bitstream shall not contain data that result in any element fij of f with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


After the inverse transform, the scaling is performed as follows:


- If qP is greater than or equal to 36, the scaled result is derived as:


dcYij = ( fij * LevelScale4x4( qP % 6, 0, 0 ) ) << ( qP / 6 − 6 ),  with i, j = 0...3 (8-321)





- Otherwise (qP is less than 36), the scaled result is derived as:


dcYij = ( fij * LevelScale4x4( qP % 6, 0, 0 ) + ( 1 << ( 5 − qP / 6) ) ) >> ( 6 − qP / 6 ),  with i, j = 0...3 (8-322)


The bitstream shall not contain data that result in any element dcYij of dcY with i, j = 0..3 that exceeds the range of integer
values from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.

NOTE 1 – When entropy_coding_mode_flag is equal to 0 and qP is less than 10 and profile_idc is equal to 66, 77, or 88, the range
of values that can be represented for the elements cij of c is not sufficient to represent the full range of values of the elements dcYij
of dcY that could be necessary to form a close approximation of the content of any possible source picture by use of the Intra_16x16
macroblock type.
NOTE 2 – Since the range limit imposed on the elements dcYij of dcY is imposed after the right shift in Equation 8-322, a larger
range of values must be supported in the decoder prior to the right shift.


**8.5.11** **Scaling and transformation process for chroma DC transform coefficients**


This process is only invoked when ChromaArrayType is equal to 1 or 2.


Inputs to this process are transform coefficient level values for chroma DC transform coefficients of one chroma component
of the macroblock as an (MbWidthC / 4)x(MbHeightC / 4) array c with elements cij, where i and j form a two-dimensional
frequency index.


Outputs of this process are the scaled DC values as an (MbWidthC / 4)x(MbHeightC / 4) array dcC with elements dcCij.

The variables bitDepth and qP are set equal to BitDepthC and QP′C, respectively.


Depending on the value of TransformBypassModeFlag, the following applies:


- If TransformBypassModeFlag is equal to 1, the output dcC is derived as:


dcCij = cij with i = 0..( MbWidthC / 4 )      - 1 and j = 0..( MbHeightC / 4 )      - 1. (8-323)


- Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified:


1. The transformation process for chroma DC transform coefficients as specified in clause 8.5.11.1 is invoked

with bitDepth and c as the inputs and the output is assigned to the (MbWidthC / 4)x(MbHeightC / 4) array f of
chroma DC values with elements fij.


2. The scaling process for chroma DC transform coefficients as specified in clause 8.5.11.2 is invoked with

bitDepth, qP, and f as the inputs and the output is assigned to the (MbWidthC / 4)x(MbHeightC / 4) array dcC
of scaled chroma DC values with elements dcCij.


**8.5.11.1** **Transformation process for chroma DC transform coefficients**


Inputs of this process are transform coefficient level values for chroma DC transform coefficients of one chroma
component of the macroblock as an (MbWidthC / 4)x(MbHeightC / 4) array c with elements cij, where i and j form a twodimensional frequency index.


Outputs of this process are the DC values as an (MbWidthC / 4)x(MbHeightC / 4) array f with elements fij.

Depending on the variable ChromaArrayType, the inverse transform is specified as follows:


- If ChromaArrayType is equal to 1, the inverse transform for the 2x2 chroma DC transform coefficients is specified
as:



 1 1 

 1 - 1 







 

  



 c00 c01 

 c10 c11 



00 01  (8-324)







1 1    c00 c

1 - 1   c c







 1 1

f =



c00 c01    1 1

c c   1 - 1



=  00 01 

 1   - 1   c c   1   - 1



10 11




  1


 1 1 

 1 - 1 




- Otherwise, (ChromaArrayType is equal to 2), the inverse transform for the 2x4 chroma DC transform coefficients is
specified as:





 1


c00 c01



c30 c31



 1 1 

 1 - 1 







1 1














c00 c

c10 c

c c



10 11

20 c21







f



=  1 1 - 1 - 1    c10 c11    1 1

 1  - 1  - 1 1   c c   1  - 1














1 1 1 1

1 1 - 1 - 1

1 - 1 - 1 1

1 - 1 1 - 1




- 1







- 1 1













c c














**8.5.11.2** **Scaling process for chroma DC transform coefficients**

Inputs of this process are:



(8-325)





- the variables bitDepth and qP,


- DC values as an (MbWidthC / 4)x(MbHeightC / 4) array f with elements fij.


Outputs of this process are scaled DC values as an (MbWidthC / 4)x(MbHeightC / 4) array dcC with elements dcCij.

The bitstream shall not contain data that result in any element fij of f with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.

Scaling is performed depending on the variable ChromaArrayType as follows:


- If ChromaArrayType is equal to 1, the scaled result is derived as:


dcCij = f ( (ij *LevelScale4x4( qP % 6, 0,) ) 0  (qP/ 6 ) )  5, _with_ i, j = 0,1 (8-326)


- Otherwise (ChromaArrayType is equal to 2), the following ordered steps are specified:

1. The variable qPDC is derived as:


qPDC = qP + 3 (8-327)


2. Depending on the value of qPDC, the following applies:

       - If qPDC is greater than or equal to 36, the scaled result is derived as:


dcCij = f (ij           - LevelScale4x4 (qPDC %6, 0,) ) 0  (qPDC / 6           - ) 6, with i = 0..3, j = 0, 1 (8-328)


       - Otherwise (qPDC is less than 36), the scaled result is derived as:







= f ( *LevelScale4x4( qP % 6, 0,) 0 + 25 - qPDC/6 )  6 ( - qP / ), 6 with  i = 0..3, j =



dcCij = f (ij *LevelScale4x4( qPDC % 6, 0,) 0 + 25 - qPDC/6 )  6 ( - qPDC / ), 6 with  i = 0..3, j = 0,1



(8-329)


The bitstream shall not contain data that result in any element dcCij of dcC with i, j = 0..3 that exceeds the range of integer
values from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.

NOTE 1 – When entropy_coding_mode_flag is equal to 0 and qP is less than 4 and profile_idc is equal to 66, 77, or 88, the range
of values that can be represented for the elements cij of c in clause 8.5.11.1 may not be sufficient to represent the full range of values
of the elements dcCij of dcC that could be necessary to form a close approximation of the content of any possible source picture.
NOTE 2 – Since the range limit imposed on the elements dcCij of dcC is imposed after the right shift in Equation 8-326 or 8-329,
a larger range of values must be supported in the decoder prior to the right shift.


**8.5.12** **Scaling and transformation process for residual 4x4 blocks**

Input to this process is a 4x4 array c with elements cij which is either an array relating to a residual block of the luma
component or an array relating to a residual block of a chroma component.


Outputs of this process are residual sample values as 4x4 array r with elements rij.


The variable bitDepth is derived as follows:


- If the input array c relates to a luma residual block, bitDepth is set equal to BitDepthY.


- Otherwise (the input array c relates to a chroma residual block), bitDepth is set equal to BitDepthC.


The variable sMbFlag is derived as follows:


- If mb_type is equal to SI or the macroblock prediction mode is equal to Inter in an SP slice, sMbFlag is set equal to 1,


- Otherwise (mb_type not equal to SI and the macroblock prediction mode is not equal to Inter in an SP slice), sMbFlag
is set equal to 0.


The variable qP is derived as follows:


- If the input array c relates to a luma residual block and sMbFlag is equal to 0,


qP = QP′Y (8-330)


- Otherwise, if the input array c relates to a luma residual block and sMbFlag is equal to 1,


qP = QSY (8-331)





- Otherwise, if the input array c relates to a chroma residual block and sMbFlag is equal to 0,


qP = QP′C (8-332)


- Otherwise (the input array c relates to a chroma residual block and sMbFlag is equal to 1),


qP = QSC (8-333)


Depending on the value of TransformBypassModeFlag, the following applies:


- If TransformBypassModeFlag is equal to 1, the output r is derived as:


rij = cij with i, j = 0..3 (8-334)


- Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified:


1. The scaling process for residual 4x4 blocks as specified in clause 8.5.12.1 is invoked with bitDepth, qP, and c

as the inputs and the output is assigned to the 4x4 array d of scaled transform coefficients with elements dij.


2. The transformation process for residual 4x4 blocks as specified in clause 8.5.12.2 is invoked with bitDepth and

d as the inputs and the output is assigned to the 4x4 array r of residual sample values with elements rij.


**8.5.12.1** **Scaling process for residual 4x4 blocks**

Inputs of this process are:


- the variables bitDepth and qP,


- a 4x4 array c with elements cij which is either an array relating to a residual block of luma component or an array
relating to a residual block of a chroma component.


Output of this process is a 4x4 array of scaled transform coefficients d with elements dij.

The bitstream shall not contain data that result in any element cij of c with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


Scaling of 4x4 block transform coefficient levels cij proceeds as follows:


- If all of the following conditions are true:


   - i is equal to 0,


   - j is equal to 0,


   - c relates to a luma residual block coded using Intra_16x16 macroblock prediction mode or c relates to a chroma
residual block.


the variable d00 is derived by


d00 = c00 (8-335)


- Otherwise, the following applies:


   - If qP is greater than or equal to 24, the scaled result is derived as


dij = ( cij * LevelScale4x4( qP % 6, i, j) ) << ( qP / 6 − 4), with i, j = 0..3 except as noted above (8-336)


   - Otherwise (qP is less than 24), the scaled result is derived as




- qP/6)  4 ( - qP / ), 6 with i, j = 0..3 except as noted above (8-337)



ij = c (ij *LevelScale4x4( qP % 6,) j i, + 23 - qP/6)  4 ( - qP / ), 6 with i, j =



d = c ( *LevelScale4x4( qP % 6,) j i, + 23 qP/6)  4 ( - qP / ), 6 with i, j = 0..3 except as noted above



The bitstream shall not contain data that result in any element dij of d with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


**8.5.12.2** **Transformation process for residual 4x4 blocks**

Inputs of this process are:


- the variable bitDepth,


- a 4x4 array of scaled transform coefficients d with elements dij.





Outputs of this process are residual sample values as 4x4 array r with elements rij.


The bitstream shall not contain data that result in any element dij of d with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


The transform process shall convert the block of scaled transform coefficients to a block of output samples in a manner
mathematically equivalent to the following.

First, each (horizontal) row of scaled transform coefficients is transformed using a one-dimensional inverse transform as
follows.

A set of intermediate values is computed as follows:


ei0 = di0 + di2,  with  i = 0..3 (8-338)


ei1 = di0 − di2,  with  i = 0..3 (8-339)


ei2 = ( di1 >> 1 ) − di3,  with  i = 0..3 (8-340)


ei3 = di1 + ( di3 >> 1 ),  with  i = 0..3 (8-341)


The bitstream shall not contain data that result in any element eij of e with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


Then, the transformed result is computed from these intermediate values as follows:


fi0 = ei0 + ei3,  with  i = 0..3 (8-342)


fi1 = ei1 + ei2,  with  i = 0..3 (8-343)


fi2 = ei1 − ei2,  with  i = 0..3 (8-344)


fi3 = ei0 − ei3,  with  i = 0..3 (8-345)


The bitstream shall not contain data that result in any element fij of f with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.

Then, each (vertical) column of the resulting matrix is transformed using the same one-dimensional inverse transform as
follows.

A set of intermediate values is computed as follows:


g0j = f0j + f2j,  with  j = 0..3 (8-346)


g1j = f0j − f2j,  with  j = 0..3 (8-347)


g2j = ( f1j >> 1 ) − f3j,  with  j = 0..3 (8-348)


g3j = f1j + ( f3j >> 1 ),  with  j = 0..3 (8-349)


The bitstream shall not contain data that result in any element gij of g with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


Then, the transformed result is computed from these intermediate values as follows:


h0j = g0j + g3j,  with  j = 0..3 (8-350)


h1j = g1j + g2j,  with  j = 0..3 (8-351)


h2j = g1j − g2j,  with  j = 0..3 (8-352)


h3j = g0j − g3j,  with  j = 0..3 (8-353)


The bitstream shall not contain data that result in any element hij of h with i, j = 0..3 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 33, inclusive.





After performing both the one-dimensional horizontal and the one-dimensional vertical inverse transforms to produce an
array of transformed samples, the final constructed residual sample values is derived as:


5

rij = h ( ij + 2 )  6 with  i, j = 0..3 (8-354)


**8.5.13** **Scaling and transformation process for residual 8x8 blocks**

Input to this process is an 8x8 array c with elements cij which is either an array relating to an 8x8 residual block of the
luma component or, when ChromaArrayType is equal to 3, an array relating to an 8x8 residual block of a chroma
component.

NOTE 1 – When separate_colour_plane_flag is equal to 1, all residual blocks are considered to be associated with the luma
component for purposes of the decoding process of each coded picture (prior to the final assignment of the decoded picture to a
particular luma or chroma picture array according to the value of colour_plane_id).


Outputs of this process are residual sample values as 8x8 array r with elements rij.

The variables bitDepth and qP are derived as follows:


- If the input array c relates to a luma residual block, bitDepth is set equal to BitDepthY and qP is set equal to QP′Y.


- Otherwise (the input array c relates to a chroma residual block), bitDepth is set equal to BitDepthC and qP is set equal
to QP′C.
NOTE 2 – When separate_colour_plane_flag is equal to 1, all residual blocks are considered to be associated with the luma
component for purposes of the decoding process of each colour component of a picture.


Depending on the value of TransformBypassModeFlag, the following applies:


- If TransformBypassModeFlag is equal to 1, the output r is derived as


rij = cij with i, j = 0..7 (8-355)


- Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified:


1. The scaling process for residual 8x8 blocks as specified in clause 8.5.13.1 is invoked with bitDepth, qP, and

c as the inputs and the output is assigned to the 8x8 array d of scaled transform coefficients with elements dij.


2. The transformation process for residual 8x8 blocks as specified in clause 8.5.13.2 is invoked with bitDepth

and d as the inputs and the output is assigned to the 8x8 array r of residual sample values with elements rij.


**8.5.13.1** **Scaling process for residual 8x8 blocks**

Inputs of this process are:


- the variables bitDepth and qP,


- an 8x8 array c with elements cij which is either an array relating to a residual block of luma component or an array
relating to a residual block of a chroma component.


Output of this process is an 8x8 array of scaled transform coefficients d with elements dij.

The bitstream shall not contain data that result in any element cij of c with i, j = 0..7 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


The scaling process for 8x8 block transform coefficient levels cij proceeds as follows:


- If qP is greater than or equal to 36, the scaled result is derived as:


dij = (cij * LevelScale8x8( qP % 6, i, j) ) << ( qP / 6 − 6), with i, j = 0..7 (8-356)


- Otherwise (qP is less than 36), the scaled result is derived as:


dij = (cij * LevelScale8x8( qP % 6, i, j) ) + 2 [5−qP/6] ) >> ( 6 − qP /6), with i, j = 0..7 (8-357)


The bitstream shall not contain data that result in any element dij of d with i, j = 0..7 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


**8.5.13.2** **Transformation process for residual 8x8 blocks**

Inputs of this process are:


- the variable bitDepth,





- an 8x8 array of scaled transform coefficients d with elements dij.


Outputs of this process are residual sample values as 8x8 array r with elements rij.


The bitstream shall not contain data that result in any element dij of d with i, j = 0..7 that exceeds the range of integer values
from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


The transform process shall convert the block of scaled transform coefficients to a block of output samples in a manner
mathematically equivalent to the following.

First, each (horizontal) row of scaled transform coefficients is transformed using a one-dimensional inverse transform as
follows:

- A set of intermediate values eij is derived by:


ei0 = di0 + di4, with i = 0..7 (8-358)


ei1 = − di3 + di5 − di7 − (di7 >> 1), with i = 0..7 (8-359)


ei2 = di0 − di4, with i = 0..7 (8-360)


ei3 = di1 + di7 − di3 − (di3 >> 1), with i = 0..7 (8-361)


ei4 = ( di2 >> 1 ) − di6, with i = 0..7 (8-362)


ei5 = − di1 + di7 + di5 + (di5 >> 1), with i = 0..7 (8-363)


ei6 = di2 + ( di6 >> 1 ), with i = 0..7 (8-364)


ei7 = di3 + di5 + di1 + (di1 >> 1), with i = 0..7 (8-365)


- A second set of intermediate results fij is computed from the intermediate values eij as:


fi0 = ei0 + ei6, with i = 0..7 (8-366)


fi1 = ei1 + (ei7 >> 2), with i = 0..7 (8-367)


fi2 = ei2 + ei4, with i = 0..7 (8-368)


fi3 = ei3 + (ei5 >> 2), with  i = 0..7 (8-369)


fi4 = ei2 − ei4, with i = 0..7 (8-370)


fi5 = (ei3 >> 2) − ei5, with  i = 0..7 (8-371)


fi6 = ei0 − ei6, with i = 0..7 (8-372)


fi7 = ei7 − (ei1 >> 2), with i = 0..7 (8-373)


- Then, the transformed result gij is computed from these intermediate values fij as:


gi0 = fi0 + fi7, with i = 0..7 (8-374)


gi1 = fi2 + fi5, with i = 0..7 (8-375)


gi2 = fi4 + fi3, with i = 0..7 (8-376)


gi3 = fi6 + fi1, with i = 0..7 (8-377)


gi4 = fi6 − fi1, with i = 0..7 (8-378)


gi5 = fi4 − fi3, with i = 0..7 (8-379)


gi6 = fi2 − fi5, with i = 0..7 (8-380)





gi7 = fi0 − fi7, with i = 0..7 (8-381)


Then, each (vertical) column of the resulting matrix is transformed using the same one-dimensional inverse transform as
follows:

- A set of intermediate values hij is computed from the horizontally transformed value gij as:


h0j = g0j + g4j, with j = 0..7 (8-382)


h1j = − g3j + g5j − g7j − (g7j >> 1), with j = 0..7 (8-383)


h2j = g0j − g4j, with j = 0..7 (8-384)


h3j = g1j + g7j − g3j − (g3j >> 1), with j = 0..7 (8-385)


h4j = ( g2j >> 1 ) − g6j, with j = 0..7 (8-386)


h5j = − g1j + g7j + g5j + (g5j >> 1), with j = 0..7 (8-387)


h6j = g2j + ( g6j >> 1 ), with j = 0..7 (8-388)


h7j = g3j + g5j + g1j + (g1j >> 1), with j = 0..7 (8-389)


- A second set of intermediate results kij is computed from the intermediate values hij as:


k0j = h0j + h6j, with j = 0..7 (8-390)


k1j = h1j + (h7j >> 2), with j = 0..7 (8-391)


k2j = h2j + h4j, with j = 0..7 (8-392)


k3j = h3j + (h5j >> 2), with j = 0..7 (8-393)


k4j = h2j − h4j, with j = 0..7 (8-394)


k5j = (h3j >> 2) − h5j, with j = 0..7 (8-395)


k6j = h0j − h6j, with j = 0..7 (8-396)


k7j = h7j − (h1j >> 2), with j = 0..7 (8-397)


- Then, the transformed result mij is computed from these intermediate values kij as:


m0j = k0j + k7j, with j = 0..7 (8-398)


m1j = k2j + k5j, with j = 0..7 (8-399)


m2j = k4j + k3j, with j = 0..7 (8-400)


m3j = k6j + k1j, with j = 0..7 (8-401)


m4j = k6j − k1j, with j = 0..7 (8-402)


m5j = k4j − k3j, with j = 0..7 (8-403)


m6j = k2j − k5j, with j = 0..7 (8-404)


m7j = k0j − k7j, with j = 0..7 (8-405)


The bitstream shall not contain data that result in any element eij, fij, gij, hij, or kij for i and j in the range of 0..7, inclusive,
that exceeds the range of integer values from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 1, inclusive.


The bitstream shall not contain data that result in any element mij for i and j in the range of 0..7, inclusive, that exceeds the
range of integer values from −2 [(7 + bitDepth)] to 2 [(7 + bitDepth)] - 33, inclusive.





After performing both the one-dimensional horizontal and the one-dimensional vertical inverse transforms to produce an
array of transformed samples, the final constructed residual sample values are derived as


rij = ( mij + 2 [5] ) >> 6 with i, j = 0..7 (8-406)


**8.5.14** **Picture construction process prior to deblocking filter process**


Inputs to this process are:

- a sample array u with elements uij which is a 16x16 luma block or an (MbWidthC)x(MbHeightC) chroma block or a
4x4 luma block or a 4x4 chroma block or an 8x8 luma block or, when ChromaArrayType is equal to 3, an 8x8 chroma
block,

- when u is not a 16x16 luma block or an (MbWidthC)x(MbHeightC) chroma block, a block index luma4x4BlkIdx or
chroma4x4BlkIdx or luma8x8BlkIdx or cb4x4BlkIdx or cr4x4BlkIdx or cb8x8BlkIdx or cr8x8BlkIdx.


The position of the upper-left luma sample of the current macroblock is derived by invoking the inverse macroblock
scanning process in clause 6.4.1 with CurrMbAddr as input and the output being assigned to ( xP, yP ).


When u is a luma block, for each sample uij of the luma block, the following ordered steps are specified:


1. Depending on the size of the block u, the following applies:


     - If u is a 16x16 luma block, the position ( xO, yO ) of the upper-left sample of the 16x16 luma block inside
the macroblock is set equal to ( 0, 0 ) and the variable nE is set equal to 16.


     - Otherwise, if u is an 4x4 luma block, the position of the upper-left sample of the 4x4 luma block with index
luma4x4BlkIdx inside the macroblock is derived by invoking the inverse 4x4 luma block scanning process
in clause 6.4.3 with luma4x4BlkIdx as the input and the output being assigned to ( xO, yO ), and the variable
nE is set equal to 4.


     - Otherwise (u is an 8x8 luma block), the position of the upper-left sample of the 8x8 luma block with index
luma8x8BlkIdx inside the macroblock is derived by invoking the inverse 8x8 luma block scanning process
in clause 6.4.5 with luma8x8BlkIdx as the input and the output being assigned to ( xO, yO ), and the variable
nE is set equal to 8.


2. Depending on the variable MbaffFrameFlag and the current macroblock, the following applies:


     - If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock,


S′L[ xP + xO + j, yP + 2 * ( yO + i ) ] = uij  with i, j = 0..nE         - 1 (8-407)


     - Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock),


S′L[ xP + xO + j, yP + yO + i ] = uij  with i, j = 0..nE         - 1 (8-408)


When u is a chroma block, for each sample uij of the chroma block, the following ordered steps are specified:


1. The subscript C in the variable S′C is replaced with Cb for the Cb chroma component and with Cr for the Cr chroma

component.


2. Depending on the size of the block u, the following applies:


     - If u is an (MbWidthC)x(MbHeightC) Cb or Cr block, the variable nW is set equal to MbWidthC, the variable
nH is set equal to MbHeightC, and the position ( xO, yO ) of the upper-left sample of the (nW)x(nH) Cb or
Cr block inside the macroblock is set equal to ( 0, 0 ).


     - Otherwise, if u is a 4x4 Cb or Cr block, the variables nW and nH are set equal to 4 and, depending on the
variable ChromaArrayType, the position of the upper-left sample of a 4x4 Cb or Cr block with index
chroma4x4BlkIdx inside the macroblock is derived as follows:


        - If ChromaArrayType is equal to 1 or 2, the position of the upper-left sample of the 4x4 chroma block
with index chroma4x4BlkIdx inside the macroblock is derived by invoking the inverse 4x4 chroma
block scanning process in clause 6.4.7 with chroma4x4BlkIdx as the input and the output being assigned
to ( xO, yO ).


        - Otherwise (ChromaArrayType is equal to 3), the position of the upper-left sample of the 4x4 Cb block
with index cb4x4BlkIdx or the 4x4 Cr block with index cr4x4BlkIdx inside the macroblock is derived
by invoking the inverse 4x4 Cb or Cr block scanning process in clause 6.4.4 with cb4x4BlkIdx or
cr4x4BlkIdx as the input and the output being assigned to ( xO, yO ).





     - Otherwise (u is an 8x8 Cb or Cr block when ChromaArrayType is equal to 3), the variables nW and nH are
set equal to 8 and the position of the upper-left sample of the 8x8 Cb block with index cb8x8BlkIdx or the
Cr block with index cr8x8BlkIdx inside the macroblock is derived by invoking the inverse 8x8 Cb or Cr
block scanning process in clause 6.4.6 with cb8x8BlkIdx or cr8x8BlkIdx as the input and the output being
assigned to ( xO, yO ).


3. Depending on the variable MbaffFrameFlag and the current macroblock, the following applies:


     - If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock,


S′C[ ( xP / subWidthC ) + xO + j, ( ( yP + SubHeightC − 1 ) / SubHeightC ) + 2 * ( yO + i ) ] = uij
with i = 0..nH − 1 and  j = 0..nW − 1 (8-409)


     - Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock),


S′C[ ( xP/ subWidthC ) + xO + j, ( yP / SubHeightC ) + yO + i ] = uij
with i = 0..nH − 1 and j = 0..nW − 1 (8-41 ) 0


**8.5.15** **Intra residual transform-bypass decoding process**


This process is invoked when TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to
Intra_4x4, Intra_8x8, or Intra_16x16, and the applicable intra prediction mode is equal to the vertical or horizontal mode.
The process for the Cb and Cr components is applied in the same way as for the luma (L or Y) component.


Inputs to this process are:

- two variables nW and nH,

- a variable horPredFlag,

- an (nW)x(nH) array r with elements rij which is either an array relating to a residual transform-bypass block of the
luma component or an array relating to a residual transform-bypass block of the Cb and Cr component.


Output of this process is a modified version of the (nW)x(nH) array r with elements rij containing the result of the intra
residual transform-bypass decoding process.


Let f be a temporary (nW)x(nH) array with elements fij, which are derived by:


fij = rij   with i = 0..nH − 1 and j = 0..nW − 1 (8-411)


Depending on horPredFlag, the following applies:

- If horPredFlag is equal to 0, the modified array r is derived by:



i


##### 

k = 0


##### rij =  f kj   with i = 0..nH − 1 and j = 0..nW − 1 (8-412)



=

k = 0




- Otherwise (horPredFlag is equal to 1), the modified array r is derived by:



j


### 



=

k =



rij = fik with i = 0..nH − 1 and j = 0..nW − 1 (8-413)



k = 0
