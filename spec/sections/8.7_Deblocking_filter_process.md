**8.7** **Deblocking filter process**


A conditional filtering process is specified in this clause that is an integral part of the decoding process which shall be
applied by decoders conforming to the Baseline, Constrained Baseline, Main, Extended, High, Progressive High,
Constrained High, High 10, Progressive High 10, High 4:2:2, and High 4:4:4 Predictive profiles. For decoders conforming
to the High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles, the filtering process specified in
this clause, or one similar to it, should be applied but is not required.


The conditional filtering process is applied to all NxN (where N = 4 or N = 8 for luma, N = 4 for chroma when
ChromaArrayType is equal to 1 or 2, and N = 4 or N = 8 for chroma when ChromaArrayType is equal to 3) block edges
of a picture, except edges at the boundary of the picture and any edges for which the deblocking filter process is disabled
by disable_deblocking_filter_idc, as specified below. This filtering process is performed on a macroblock basis after the
completion of the picture construction process prior to deblocking filter process (as specified in clauses 8.5 and 8.6) for
the entire decoded picture, with all macroblocks in a picture processed in order of increasing macroblock addresses.

NOTE 1 – Prior to the operation of the deblocking filter process for each macroblock, the deblocked samples of the macroblock or
macroblock pair above (if any) and the macroblock or macroblock pair to the left (if any) of the current macroblock are always
available because the deblocking filter process is performed after the completion of the picture construction process prior to
deblocking filter process for the entire decoded picture. However, for purposes of determining which edges are to be filtered when
disable_deblocking_filter_idc is equal to 2, macroblocks in different slices are considered not available during specified steps of the
operation of the deblocking filter process.


The deblocking filter process is invoked for the luma and chroma components separately. For each macroblock and each
component, vertical edges are filtered first, starting with the edge on the left-hand side of the macroblock proceeding
through the edges towards the right-hand side of the macroblock in their geometrical order, and then horizontal edges are
filtered, starting with the edge on the top of the macroblock proceeding through the edges towards the bottom of the
macroblock in their geometrical order. Figure 8-10 shows edges of a macroblock which can be interpreted as luma or
chroma edges.


When interpreting the edges in Figure 8-10 as luma edges, depending on the transform_size_8x8_flag, the following
applies:

- If transform_size_8x8_flag is equal to 0, both types, the solid bold and dashed bold luma edges are filtered.

- Otherwise (transform_size_8x8_flag is equal to 1), only the solid bold luma edges are filtered.


When interpreting the edges in Figure 8-10 as chroma edges, depending on ChromaArrayType, the following applies:

- If ChromaArrayType is equal to 1 (4:2:0 format), only the solid bold chroma edges are filtered.

- Otherwise, if ChromaArrayType is equal to 2 (4:2:2 format), the solid bold vertical chroma edges are filtered and
both types, the solid bold and dashed bold horizontal chroma edges are filtered.

- Otherwise, if ChromaArrayType is equal to 3 (4:4:4 format), the following applies:


    - If transform_size_8x8_flag is equal to 0, both types, the solid bold and dashed bold chroma edges are filtered.


    - Otherwise (transform_size_8x8_flag is equal to 1), only the solid bold chroma edges are filtered.

- Otherwise (ChromaArrayType is equal to 0), no chroma edges are filtered.





H.264(09)_F8-10
Vertical edges


**Figure 8-10 – Boundaries in a macroblock to be filtered**


For the current macroblock address CurrMbAddr proceeding over values 0..PicSizeInMbs − 1, the following ordered steps
are specified:


1. The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is
assigned to mbAddrA and mbAddrB.


2. The variables fieldMbInFrameFlag, filterInternalEdgesFlag, filterLeftMbEdgeFlag and filterTopMbEdgeFlag are
derived as specified by the following ordered steps:


a. The variable fieldMbInFrameFlag is derived as follows:


        - If MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1, fieldMbInFrameFlag is set
equal to 1.


        - Otherwise (MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0),
fieldMbInFrameFlag is set equal to 0.


b. The variable filterInternalEdgesFlag is derived as follows:


        - If disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal to 1,
the variable filterInternalEdgesFlag is set equal to 0.


        - Otherwise (disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is
not equal to 1), the variable filterInternalEdgesFlag is set equal to 1.


c. The variable filterLeftMbEdgeFlag is derived as follows:


        - If any of the following conditions are true, the variable filterLeftMbEdgeFlag is set equal to 0:


           - MbaffFrameFlag is equal to 0 and CurrMbAddr % PicWidthInMbs is equal to 0,


           - MbaffFrameFlag is equal to 1 and ( CurrMbAddr >> 1 ) % PicWidthInMbs is equal to 0,


           - disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal
to 1,


           - disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal
to 2 and the macroblock mbAddrA is not available.


        - Otherwise, the variable filterLeftMbEdgeFlag is set equal to 1.


d. The variable filterTopMbEdgeFlag is derived as follows:


        - If any of the following conditions are true, the variable filterTopMbEdgeFlag is set equal to 0:


           - MbaffFrameFlag is equal to 0 and CurrMbAddr is less than PicWidthInMbs,


           - MbaffFrameFlag is equal to 1, ( CurrMbAddr >> 1 ) is less than PicWidthInMbs, and the
macroblock CurrMbAddr is a field macroblock,


           - MbaffFrameFlag is equal to 1, ( CurrMbAddr >> 1 ) is less than PicWidthInMbs, the
macroblock CurrMbAddr is a frame macroblock, and CurrMbAddr % 2 is equal to 0,





           - disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal
to 1,


           - disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal
to 2 and the macroblock mbAddrB is not available.


        - Otherwise, the variable filterTopMbEdgeFlag is set equal to 1.


3. Given the variables fieldMbInFrameFlag, filterInternalEdgesFlag, filterLeftMbEdgeFlag and
filterTopMbEdgeFlag the deblocking filtering is controlled as follows:


a. When filterLeftMbEdgeFlag is equal to 1, the left vertical luma edge is filtered by invoking the process
specified in clause 8.7.1 with chromaEdgeFlag = 0, verticalEdgeFlag = 1,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (0, k) with k = 0..15 as the inputs
and S′L as the output.


b. When filterInternalEdgesFlag is equal to 1, the filtering of the internal vertical luma edges is specified by the

following ordered steps:


i. When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with
chromaEdgeFlag = 0, verticalEdgeFlag = 1, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag,
and (xEk, yEk) = (4, k) with k = 0..15 as the inputs and S′L as the output.


ii. The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 1,

fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (8, k) with k = 0..15 as the
inputs and S′L as the output.


iii. When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with

chromaEdgeFlag = 0, verticalEdgeFlag = 1, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag,
and (xEk, yEk) = (12, k) with k = 0..15 as the inputs and S′L as the output.


c. When filterTopMbEdgeFlag is equal to 1, the filtering of the top horizontal luma edge is specified as follows:


        - If MbaffFrameFlag is equal to 1, (CurrMbAddr % 2) is equal to 0, CurrMbAddr is greater than or equal
to 2 * PicWidthInMbs, the macroblock CurrMbAddr is a frame macroblock, and the macroblock
(CurrMbAddr − 2 * PicWidthInMbs + 1) is a field macroblock, the following ordered steps are
specified:


i. The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 0,

fieldModeInFrameFilteringFlag = 1, and (xEk, yEk) = (k, 0) with k = 0..15 as the inputs and S′L
as the output.


ii. The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 0,

fieldModeInFrameFilteringFlag = 1, and (xEk, yEk) = (k, 1) with k = 0..15 as the inputs and S′L
as the output.


        - Otherwise, the process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0,
verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (k, 0)
with k = 0..15 as the inputs and S′L as the output.


d. When filterInternalEdgesFlag is equal to 1, the filtering of the internal horizontal luma edges is specified by

the following ordered steps:


i. When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with
chromaEdgeFlag = 0, verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag,
and (xEk, yEk) = (k, 4) with k = 0..15 as the inputs and S′L as the output.


ii. The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 0,

fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (k, 8) with k = 0..15 as the
inputs and S′L as the output.


iii. When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with

chromaEdgeFlag = 0, verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag,
and (xEk, yEk) = (k, 12) with k = 0..15 as the inputs and S′L as the output.


e. When ChromaArrayType is not equal to 0, for the filtering of both chroma components, with iCbCr = 0 for
Cb and iCbCr = 1 for Cr, the following ordered steps are specified:


i. When filterLeftMbEdgeFlag is equal to 1, the left vertical chroma edge is filtered by invoking the
process specified in clause 8.7.1 with chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 1,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (0, k) with





k = 0..MbHeightC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C being
replaced by Cr for iCbCr = 1 as the output.


ii. When filterInternalEdgesFlag is equal to 1, the filtering of the internal vertical chroma edge is specified

by the following ordered steps:


(1) When ChromaArrayType is not equal to 3 or transform_size_8x8_flag is equal to 0, the process

specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 1,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (4, k) with
k = 0..MbHeightC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C being
replaced by Cr for iCbCr = 1 as the output.


(2) When ChromaArrayType is equal to 3, the process specified in clause 8.7.1 is invoked with

chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 1, fieldModeInFrameFilteringFlag =
fieldMbInFrameFlag, and (xEk, yEk) = (8, k) with k = 0..MbHeightC − 1 as the inputs and S′C with
C being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output.


(3) When ChromaArrayType is equal to 3 and transform_size_8x8_flag is equal to 0, the process

specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 1,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (12, k) with
k = 0..MbHeightC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C being
replaced by Cr for iCbCr = 1 as the output.


iii. When filterTopMbEdgeFlag is equal to 1, the filtering of the top horizontal chroma edge is specified

as follows:


   - If MbaffFrameFlag is equal to 1, (CurrMbAddr % 2) is equal to 0, CurrMbAddr is greater than or
equal to 2 * PicWidthInMbs, the macroblock CurrMbAddr is a frame macroblock, and the
macroblock (CurrMbAddr − 2 * PicWidthInMbs + 1) is a field macroblock, the following
ordered steps are specified:


(1) The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr,

verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = 1, and (xEk, yEk) = (k, 0) with
k = 0..MbWidthC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C
being replaced by Cr for iCbCr = 1 as the output.


(2) The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr,

verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = 1, and (xEk, yEk) = (k, 1) with
k = 0..MbWidthC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C
being replaced by Cr for iCbCr = 1 as the output.


   - Otherwise, the process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr,
verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and
(xEk, yEk) = (k, 0) with k = 0..MbWidthC − 1 as the inputs and S′C with C being replaced by Cb
for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output.


iv. When filterInternalEdgesFlag is equal to 1, the filtering of the internal horizontal chroma edge is

specified by the following ordered steps:


(1) When ChromaArrayType is not equal to 3 or transform_size_8x8_flag is equal to 0, the process

specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 0,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (k, 4) with
k = 0..MbWidthC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C being
replaced by Cr for iCbCr = 1 as the output.


(2) When ChromaArrayType is not equal to 1, the process specified in clause 8.7.1 is invoked with

chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag =
fieldMbInFrameFlag, and (xEk, yEk) = (k, 8) with k = 0..MbWidthC − 1 as the inputs and S′C with
C being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output.


(3) When ChromaArrayType is equal to 2, the process specified in clause 8.7.1 is invoked with

chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 0, fieldModeInFrameFilteringFlag =
fieldMbInFrameFlag, and (xEk, yEk) = (k, 12) with k = 0..MbWidthC − 1 as the inputs and S′C with
C being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output.


(4) When ChromaArrayType is equal to 3 and transform_size_8x8_flag is equal to 0, the process

specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr, verticalEdgeFlag = 0,
fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xEk, yEk) = (k, 12) with





k = 0..MbWidthC − 1 as the inputs and S′C with C being replaced by Cb for iCbCr = 0 and C being
replaced by Cr for iCbCr = 1 as the output.
NOTE 2 – When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied across the top
horizontal edges of a frame macroblock, this vertical filtering across the top or bottom macroblock boundary may
involve some samples that extend across an internal block edge that is also filtered internally in frame mode.
NOTE 3 – For example, in 4:2:0 chroma format when transform_size_8x8_flag is equal to 0, the following applies.
3 horizontal luma edges, 1 horizontal chroma edge for Cb, and 1 horizontal chroma edge for Cr are filtered that are
internal to a macroblock. When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied to the
top edges of a frame macroblock, 2 horizontal luma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma
edges for Cr between the frame macroblock and the above macroblock pair are filtered using field mode filtering,
for a total of up to 5 horizontal luma edges, 3 horizontal chroma edges for Cb, and 3 horizontal chroma edges for
Cr filtered that are considered to be controlled by the frame macroblock. In all other cases, at most 4 horizontal
luma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma edges for Cr are filtered that are considered to be
controlled by a particular macroblock.


Depending on separate_colour_plane_flag the following applies:

- If separate_colour_plane_flag is equal to 0, the arrays S′L, S′Cb, S′Cr are assigned to the arrays SL, SCb, SCr (which
represent the decoded picture), respectively.

- Otherwise (separate_colour_plane_flag is equal to 1), the following applies:


   - If colour_plane_id is equal to 0, the arrays S′L is assigned to the array SL (which represent the luma component
of the decoded picture).


   - Otherwise, if colour_plane_id is equal to 1, the arrays S′L is assigned to the array SCb (which represents the Cb
component of the decoded picture).


   - Otherwise (colour_plane_id is equal to 2), the arrays S′L is assigned to the array SCr (which represents the Cr
component of the decoded picture).


**8.7.1** **Filtering process for block edges**


Inputs to this process are chromaEdgeFlag, the chroma component index iCbCr (when chromaEdgeFlag is equal to 1),
verticalEdgeFlag, fieldModeInFrameFilteringFlag, and a set of nE sample locations (xEk, yEk), with k = 0..nE − 1,
expressed relative to the upper left corner of the macroblock CurrMbAddr. The set of sample locations (xEk, yEk) represent
the sample locations immediately to the right of a vertical edge (when verticalEdgeFlag is equal to 1) or immediately below
a horizontal edge (when verticalEdgeFlag is equal to 0).


The variable nE is derived as follows:

- If chromaEdgeFlag is equal to 0, nE is set equal to 16.

- Otherwise (chromaEdgeFlag is equal to 1), nE is set equal to ( verticalEdgeFlag = = 1 ) ? MbHeightC : MbWidthC.


Let s′ be a variable specifying a luma or chroma sample array. s′ is derived as follows:

- If chromaEdgeFlag is equal to 0, s′ represents the luma sample array S′L of the current picture.

- Otherwise, if chromaEdgeFlag is equal to 1 and iCbCr is equal to 0, s′ represents the chroma sample array S′Cb of the
chroma component Cb of the current picture.

- Otherwise (chromaEdgeFlag is equal to 1 and iCbCr is equal to 1), s′ represents the chroma sample array S′Cr of the
chroma component Cr of the current picture.


The variable dy is set equal to (1 + fieldModeInFrameFilteringFlag).


The position of the upper-left luma sample of the macroblock CurrMbAddr is derived by invoking the inverse macroblock
scanning process in clause 6.4.1 with mbAddr = CurrMbAddr as input and the output being assigned to ( xI, yI ).


The variables xP and yP are derived as follows:

- If chromaEdgeFlag is equal to 0, xP is set equal to xI and yP is set equal to yI.

- Otherwise (chromaEdgeFlag is equal to 1), xP is set equal to xI / SubWidthC and yP is set equal to
(yI + SubHeightC − 1) / SubHeightC.





**Figure 8-11 – Convention for describing samples across a 4x4 block horizontal or vertical boundary**


For each sample location ( xEk, yEk ), k = 0..(nE − 1), the following ordered steps are specified:


1. The filtering process is applied to a set of eight samples across a 4x4 block horizontal or vertical edge denoted as
pi and qi with i = 0..3 as shown in Figure 8-11 with the edge lying between p0 and q0. pi and qi with i = 0..3 are
specified as follows:


    - If verticalEdgeFlag is equal to 1,


qi = s′[ xP + xEk + i, yP + dy * yEk ] (8-442)


pi = s′[ xP + xEk − i − 1, yP + dy * yEk ] (8-443)


    - Otherwise (verticalEdgeFlag is equal to 0),


qi = s′[ xP + xEk, yP + dy * ( yEk + i ) − (yEk % 2 ) ] (8-444)


pi = s′[ xP + xEk, yP + dy * ( yEk − i − 1 ) − (yEk % 2 ) ] (8-445)


2. The process specified in clause 8.7.2 is invoked with the sample values pi and qi (i = 0..3), chromaEdgeFlag, and
verticalEdgeFlag as the inputs, and the output is assigned to the filtered result sample values p′i and q′i with i = 0..2.


3. The input sample values pi and qi with i = 0..2 are replaced by the corresponding filtered result sample values p′i
and q′i with i = 0..2 inside the sample array s′ as follows:


    - If verticalEdgeFlag is equal to 1,


s′[ xP + xEk + i, yP + dy * yEk ] = q′i (8-446)


s′[ xP + xEk − i − 1, yP + dy * yEk ] = p′i (8-447)


    - Otherwise (verticalEdgeFlag is equal to 0),


s′[ xP + xEk, yP + dy * ( yEk + i ) − ( yEk % 2 ) ] = q′i (8-448)


s′[ xP + xEk, yP + dy * ( yEk − i − 1 ) − ( yEk % 2 ) ] = p′i (8-449)


**8.7.2** **Filtering process for a set of samples across a horizontal or vertical block edge**


Inputs to this process are the input sample values pi and qi with i in the range of 0..3 of a single set of samples across an
edge that is to be filtered, chromaEdgeFlag, and verticalEdgeFlag.


Outputs of this process are the filtered result sample values p′i and q′i with i in the range of 0..2.


The content dependent boundary filtering strength variable bS is derived as follows:


- If chromaEdgeFlag is equal to 0, the derivation process for the content dependent boundary filtering strength specified
in clause 8.7.2.1 is invoked with p0, q0, and verticalEdgeFlag as input, and the output is assigned to bS.


- Otherwise (chromaEdgeFlag is equal to 1), the bS used for filtering a set of samples of a horizontal or vertical chroma
edge is set equal to the value of bS for filtering the set of samples of a horizontal or vertical luma edge, respectively,
that contains the luma sample at location ( SubWidthC * x, SubHeightC * y ) inside the luma array of the same field,
where ( x, y ) is the location of the chroma sample q0 inside the chroma array for that field.


Let filterOffsetA and filterOffsetB be the values of FilterOffsetA and FilterOffsetB as specified in clause 7.4.3 for the slice
that contains the macroblock containing sample q0.


Let qPp and qPq be variables specifying quantization parameter values for the macroblocks containing the samples p0 and
q0, respectively. The variables qPz (with z being replaced by p or q) are derived as follows:


- If chromaEdgeFlag is equal to 0, the following applies:





   - If the macroblock containing the sample z0 is an I_PCM macroblock, qPz is set to 0.


   - Otherwise (the macroblock containing the sample z0 is not an I_PCM macroblock), qPz is set to the value of QPY
of the macroblock containing the sample z0.


- Otherwise (chromaEdgeFlag is equal to 1), the following applies:


   - If the macroblock containing the sample z0 is an I_PCM macroblock, qPz is set equal to the value of QPC that
corresponds to a value of 0 for QPY as specified in clause 8.5.8.


   - Otherwise (the macroblock containing the sample z0 is not an I_PCM macroblock), qPz is set equal to the value
of QPC that corresponds to the value QPY of the macroblock containing the sample z0 as specified in clause 8.5.8.


The process specified in clause 8.7.2.2 is invoked with p0, q0, p1, q1, chromaEdgeFlag, bS, filterOffsetA, filterOffsetB, qPp,
and qPq as inputs, and the outputs are assigned to filterSamplesFlag, indexA, , and  .


The variable chromaStyleFilteringFlag is set by


chromaStyleFilteringFlag = chromaEdgeFlag && ( ChromaArrayType != 3 ) (8-450)


Depending on the variable filterSamplesFlag, the following applies:


- If filterSamplesFlag is equal to 1, the following applies:


   - If bS is less than 4, the process specified in clause 8.7.2.3 is invoked with pi and qi (i = 0..2), chromaEdgeFlag,
chromaStyleFilteringFlag, bS, , and indexA given as input, and the output is assigned to p′i and q′i (i = 0..2).


   - Otherwise (bS is equal to 4), the process specified in clause 8.7.2.4 is invoked with pi and qi (i = 0..3),
chromaEdgeFlag, chromaStyleFilteringFlag, , and  given as input, and the output is assigned to p′i and q′i
(i = 0..2).


- Otherwise (filterSamplesFlag is equal to 0), the filtered result samples p′i and q′i (i = 0..2) are replaced by the
corresponding input samples pi and qi:


for i = 0..2, p′i = pi (8-451)


for i = 0..2, q′i = qi (8-452)


**8.7.2.1** **Derivation process for the luma content dependent boundary filtering strength**


Inputs to this process are the input sample values p0 and q0 of a single set of samples across an edge that is to be filtered
and verticalEdgeFlag.


Output of this process is the variable bS.


Let the variable mixedModeEdgeFlag be derived as follows:


- If MbaffFrameFlag is equal to 1 and the samples p0 and q0 are in different macroblock pairs, one of which is a field
macroblock pair and the other is a frame macroblock pair, mixedModeEdgeFlag is set equal to 1.


- Otherwise, mixedModeEdgeFlag is set equal to 0.


The variable bS is derived as follows:


- If the block edge is also a macroblock edge and any of the following conditions are true, a value of bS equal to 4 is
the output:


   - the samples p0 and q0 are both in frame macroblocks and either or both of the samples p0 or q0 is in a macroblock
coded using an Intra macroblock prediction mode,


   - the samples p0 and q0 are both in frame macroblocks and either or both of the samples p0 or q0 is in a macroblock
that is in a slice with slice_type equal to SP or SI,


   - MbaffFrameFlag is equal to 1 or field_pic_flag is equal to 1, and verticalEdgeFlag is equal to 1, and either or
both of the samples p0 or q0 is in a macroblock coded using an Intra macroblock prediction mode,


   - MbaffFrameFlag is equal to 1 or field_pic_flag is equal to 1, and verticalEdgeFlag is equal to 1, and either or
both of the samples p0 or q0 is in a macroblock that is in a slice with slice_type equal to SP or SI.


- Otherwise, if any of the following conditions are true, a value of bS equal to 3 is the output:


   - mixedModeEdgeFlag is equal to 0 and either or both of the samples p0 or q0 is in a macroblock coded using an
Intra macroblock prediction mode,





   - mixedModeEdgeFlag is equal to 0 and either or both of the samples p0 or q0 is in a macroblock that is in a slice
with slice_type equal to SP or SI,


   - mixedModeEdgeFlag is equal to 1, verticalEdgeFlag is equal to 0, and either or both of the samples p0 or q0 is in
a macroblock coded using an Intra macroblock prediction mode,


   - mixedModeEdgeFlag is equal to 1, verticalEdgeFlag is equal to 0, and either or both of the samples p0 or q0 is in
a macroblock that is in a slice with slice_type equal to SP or SI.


- Otherwise, if any of the following conditions are true, a value of bS equal to 2 is the output:


   - transform_size_8x8_flag is equal to 1 for the macroblock containing the sample p0 and the 8x8 luma transform
block associated with the 8x8 luma block containing the sample p0 contains non-zero transform coefficient levels,


   - transform_size_8x8_flag is equal to 0 for the macroblock containing the sample p0 and the 4x4 luma transform
block associated with the 4x4 luma block containing the sample p0 contains non-zero transform coefficient levels,


   - transform_size_8x8_flag is equal to 1 for the macroblock containing the sample q0 and the 8x8 luma transform
block associated with the 8x8 luma block containing the sample q0 contains non-zero transform coefficient levels,


   - transform_size_8x8_flag is equal to 0 for the macroblock containing the sample q0 and the 4x4 luma transform
block associated with the 4x4 luma block containing the sample q0 contains non-zero transform coefficient levels.


- Otherwise, if any of the following conditions are true, a value of bS equal to 1 is the output:


   - mixedModeEdgeFlag is equal to 1,


   - mixedModeEdgeFlag is equal to 0 and for the prediction of the macroblock/sub-macroblock partition containing
the sample p0 different reference pictures or a different number of motion vectors are used than for the prediction
of the macroblock/sub-macroblock partition containing the sample q0,

NOTE 1 – The determination of whether the reference pictures used for the two macroblock/sub-macroblock partitions
are the same or different is based only on which pictures are referenced, without regard to whether a prediction is formed
using an index into reference picture list 0 or an index into reference picture list 1, and also without regard to whether
the index position within a reference picture list is different.
NOTE 2 – The number of motion vectors that are used for the prediction of a macroblock partition with macroblock
partition index mbPartIdx, or a sub-macroblock partition contained in this macroblock partition, is equal to
PredFlagL0[ mbPartIdx ] + PredFlagL1[ mbPartIdx ].


   - mixedModeEdgeFlag is equal to 0 and one motion vector is used to predict the macroblock/sub-macroblock
partition containing the sample p0 and one motion vector is used to predict the macroblock/sub-macroblock
partition containing the sample q0 and the absolute difference between the horizontal or vertical components of
the motion vectors used is greater than or equal to 4 in units of quarter luma frame samples,


   - mixedModeEdgeFlag is equal to 0 and two motion vectors and two different reference pictures are used to predict
the macroblock/sub-macroblock partition containing the sample p0 and two motion vectors for the same two
reference pictures are used to predict the macroblock/sub-macroblock partition containing the sample q0 and, for
either or both of the two used reference pictures, the absolute difference between the horizontal or vertical
components of the two motion vectors used in the prediction of the two macroblock/sub-macroblock partitions
for the particular reference picture is greater than or equal to 4 in units of quarter luma frame samples,


   - mixedModeEdgeFlag is equal to 0 and two motion vectors for the same reference picture are used to predict the
macroblock/sub-macroblock partition containing the sample p0 and two motion vectors for the same reference
picture are used to predict the macroblock/sub-macroblock partition containing the sample q0 and both of the
following conditions are true:

      - The absolute difference between the horizontal or vertical components of list 0 motion vectors used in the
prediction of the two macroblock/sub-macroblock partitions is greater than or equal to 4 in quarter luma
frame samples or the absolute difference between the horizontal or vertical components of the list 1 motion
vectors used in the prediction of the two macroblock/sub-macroblock partitions is greater than or equal to 4
in units of quarter luma frame samples,

      - The absolute difference between the horizontal or vertical components of list 0 motion vector used in the
prediction of the macroblock/sub-macroblock partition containing the sample p0 and the list 1 motion vector
used in the prediction of the macroblock/sub-macroblock partition containing the sample q0 is greater than
or equal to 4 in units of quarter luma frame samples or the absolute difference between the horizontal or
vertical components of the list 1 motion vector used in the prediction of the macroblock/sub-macroblock
partition containing the sample p0 and list 0 motion vector used in the prediction of the macroblock/submacroblock partition containing the sample q0 is greater than or equal to 4 in units of quarter luma frame
samples.





NOTE 3 – A vertical difference of 4 in units of quarter luma frame samples is a difference of 2 in units of quarter
luma field samples.


- Otherwise, a value of bS equal to 0 is the output.


**8.7.2.2** **Derivation process for the thresholds for each block edge**


Inputs to this process are:


- the input sample values p0, q0, p1 and q1 of a single set of samples across an edge that is to be filtered,


- the variables chromaEdgeFlag and bS, for the set of input samples, as specified in clause 8.7.2,


- the variables filterOffsetA, filterOffsetB, qPp, and qPq.


Outputs of this process are the variable filterSamplesFlag, which indicates whether the input samples are filtered, the value
of indexA, and the values of the threshold variables  and  .


Let qPav be a variable specifying an average quantization parameter. It is derived as:


qPav = ( qPp + qPq + 1 ) >> 1 (8-453)


NOTE – In SP and SI slices, qPav is derived in the same way as in other slice types. QSY from Equation 7-31 is not used in the
deblocking filter.


Let indexA be a variable that is used to access the  table (Table 8-16) as well as the tC0 table (Table 8-17), which is used
in filtering of edges with bS less than 4 as specified in clause 8.7.2.3, and let indexB be a variable that is used to access the
 table (Table 8-16). The variables indexA and indexB are derived as:


indexA = Clip3( 0, 51, qPav + filterOffsetA ) (8-454)


indexB = Clip3( 0, 51, qPav + filterOffsetB ) (8-455)


The variables  ′ and  ′ depending on the values of indexA and indexB are specified in Table 8-16. Depending on
chromaEdgeFlag, the corresponding threshold variables  and  are derived as follows:


- If chromaEdgeFlag is equal to 0,


 =  ′ * (1 << ( BitDepthY − 8 ) ) (8-456)


β = β′ * (1 << ( BitDepthY − 8 ) ) (8-457)


- Otherwise (chromaEdgeFlag is equal to 1),


 =  ′ * (1 << ( BitDepthC − 8 ) ) (8-458)


β = β′ * (1 << ( BitDepthC − 8 ) ) (8-459)


The variable filterSamplesFlag is derived by:


filterSamplesFlag = ( bS != 0 && Abs( p0 − q0 ) <  && Abs( p1 − p0 ) <  && Abs( q1 − q0 ) <  ) (8-460)

|Col1|Table 8-16 – Derivation of offset dependent threshold variables ´ and ´ from indexA and indexB|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|Col17|Col18|Col19|Col20|Col21|Col22|Col23|Col24|Col25|Col26|Col27|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|<br>|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|indexA (for′) or indexB (for′)|
|<br>|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|
|′|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|4|4|5|6|7|8|9|10|12|13|
|′|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|2|2|2|3|3|3|3|4|4|4|






**Table 8-16 (concluded) – Derivation of indexA and indexB from offset dependent threshold variables**  **′ and**  **′**

|Col1|indexA (for ′) or indexB (for ′)|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|Col17|Col18|Col19|Col20|Col21|Col22|Col23|Col24|Col25|Col26|Col27|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|<br>|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|
|′|15|17|20|22|25|28|32|36|40|45|50|56|63|71|80|90|101|113|127|144|162|182|203|226|255|255|
|′|6|6|7|7|8|8|9|9|10|10|11|11|12|12|13|13|14|14|15|15|16|16|17|17|18|18|



**8.7.2.3** **Filtering process for edges with bS less than 4**


Inputs to this process are the input sample values pi and qi (i = 0..2) of a single set of samples across an edge that is to be
filtered, chromaEdgeFlag, chromaStyleFilteringFlag, bS, , and indexA, for the set of input samples, as specified in
clause 8.7.2.


Outputs of this process are the filtered result sample values p′i and q′i (i = 0..2) for the set of input sample values.


Depending on the values of indexA and bS, the variable t′C0 is specified in Table 8-17. Depending on chromaEdgeFlag,
the corresponding threshold variable tC0 is derived as follows:


- If chromaEdgeFlag is equal to 0,


tC0 = t′C0 * (1 << ( BitDepthY − 8 ) ) (8-461)


- Otherwise (chromaEdgeFlag is equal to 1),


tC0 = t′C0 * (1 << ( BitDepthC − 8 ) ) (8-462)

|Col1|Table 8-17 – Value of variable t´C0 as a function of indexA and bS|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|Col17|Col18|Col19|Col20|Col21|Col22|Col23|Col24|Col25|Col26|Col27|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|<br>|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|
|<br>|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|
|bS = 1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|
|bS = 2|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|1|1|
|bS = 3|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|1|1|1|1|1|1|


|Col1|Table 8-17 (concluded) – Value of variable t′C0 as a function of indexA and bS|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|Col17|Col18|Col19|Col20|Col21|Col22|Col23|Col24|Col25|Col26|Col27|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|<br>|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|indexA|
|<br>|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|
|bS = 1|1|1|1|1|1|1|1|2|2|2|2|3|3|3|4|4|4|5|6|6|7|8|9|10|11|13|
|bS = 2|1|1|1|1|1|2|2|2|2|3|3|3|4|4|5|5|6|7|8|8|10|11|12|13|15|17|
|bS = 3|1|2|2|2|2|3|3|3|4|4|4|5|6|6|7|8|9|10|11|13|14|16|18|20|23|25|



The threshold variables ap and aq are derived by:


ap = Abs( p2 − p0 ) (8-463)
aq = Abs( q2 − q0 ) (8-464)


The threshold variable tC is determined as follows:


- If chromaStyleFilteringFlag is equal to 0,


tC = tC0 + ( ( ap <  ) ? 1 : 0 ) + ( ( aq <  ) ? 1 : 0 ) (8-465)





- Otherwise (chromaStyleFilteringFlag is equal to 1),


tC = tC0 + 1 (8-466)


Let Clip1( ) be a function that is replaced by Clip1Y( ) when chromaEdgeFlag is equal to 0 and by Clip1C( ) when
chromaEdgeFlag is equal to 1.


The filtered result samples p′0 and q′0 are derived by:


 = Clip3( −tC, tC, ( ( ( ( q0 − p0 ) << 2 ) + ( p1 − q1 ) + 4 ) >> 3 ) ) (8-467)
p′0 = Clip1( p0 +  ) (8-468)
q′0 = Clip1( q0 −  ) (8-469)


The filtered result sample p′1 is derived as follows:


- If chromaStyleFilteringFlag is equal to 0 and ap is less than ,


p′1 = p1 + Clip3( −tC0, tC0, ( p2 + ( ( p0 + q0 + 1 ) >> 1 ) − ( p1 << 1 ) ) >> 1 ) (8-470)


- Otherwise (chromaStyleFilteringFlag is equal to 1 or ap is greater than or equal to  ),


p′1 = p1 (8-471)


The filtered result sample q′1 is derived as follows:


- If chromaStyleFilteringFlag is equal to 0 and aq is less than ,


q′1 = q1 + Clip3( −tC0, tC0, ( q2 + ( ( p0 + q0 + 1 ) >> 1 ) − ( q1 << 1 ) ) >> 1 ) (8-472)


- Otherwise (chromaStyleFilteringFlag is equal to 1 or aq is greater than or equal to  ),


q′1 = q1 (8-473)


The filtered result samples p′2 and q′2 are always set equal to the input samples p2 and q2:


p′2 = p2 (8-474)
q′2 = q2 (8-475)


**8.7.2.4** **Filtering process for edges for bS equal to 4**


Inputs to this process are the input sample values pi and qi (i = 0..3) of a single set of samples across an edge that is to be
filtered, chromaEdgeFlag, chromaStyleFilteringFlag, and the values of the threshold variables  and  for the set of
samples, as specified in clause 8.7.2.


Outputs of this process are the filtered result sample values p′i and q′i (i = 0..2) for the set of input sample values.


Let ap and aq be two threshold variables as specified in Equations 8-463 and 8-464, respectively, in clause 8.7.2.3.


The filtered result samples p′i (i = 0..2) are derived as follows:


- If chromaStyleFilteringFlag is equal to 0 and the following condition holds,


ap <  && Abs( p0 − q0 ) < ( (  >> 2 ) + 2 ) (8-476)


then the variables p′0, p′1, and p′2 are derived by:


p′0 = ( p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4 ) >> 3 (8-477)


p′1 = ( p2 + p1 + p0 + q0 + 2 ) >> 2 (8-478)


p′2 = ( 2*p3 + 3*p2 + p1 + p0 + q0 + 4 ) >> 3 (8-479)


- Otherwise (chromaStyleFilteringFlag is equal to 1 or the condition in Equation 8-476 does not hold), the variables
p′0, p′1, and p′2 are derived by:


p′0 = ( 2*p1 + p0 + q1 + 2 ) >> 2 (8-480)





p′1 = p1 (8-481)


p′2 = p2 (8-482)


The filtered result samples q′i (i = 0..2) are derived as follows:


- If chromaStyleFilteringFlag is equal to 0 and the following condition holds,


aq <  && Abs( p0 − q0 ) < ( (  >> 2 ) + 2 ) (8-483)


then the variables q′0, q′1, and q′2 are derived by


q′0 = ( p1 + 2*p0 + 2*q0 + 2*q1 + q2 + 4 ) >> 3 (8-484)


q′1 = ( p0 + q0 + q1 + q2 + 2 ) >> 2 (8-485)


q′2 = ( 2*q3 + 3*q2 + q1 + q0 + p0 + 4 ) >> 3 (8-486)


- Otherwise (chromaStyleFilteringFlag is equal to 1 or the condition in Equation 8-483 does not hold), the variables
q′0, q′1, and q′2 are derived by:


q′0 = ( 2*q1 + q0 + p1 + 2 ) >> 2 (8-487)


q′1 = q1 (8-488)


q′2 = q2 (8-489)
