**9.2** **CAVLC parsing process for transform coefficient levels**


This process is invoked for the parsing of syntax elements with descriptor equal to ce(v) in clause 7.3.5.3.2 when
entropy_coding_mode_flag is equal to 0.


Inputs to this process are bits from slice data, a maximum number of non-zero transform coefficient levels maxNumCoeff,
the luma block index luma4x4BlkIdx or the chroma block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx of the
current block of transform coefficient levels.


Output of this process is the list coeffLevel containing transform coefficient levels of the luma block with block index
luma4x4BlkIdx or the chroma block with block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx.


The process is specified in the following ordered steps:


1. All transform coefficient level values coeffLevel[ i ], with indices i ranging from 0 to maxNumCoeff − 1, in the
list coeffLevel are set equal to 0.


2. The total number of non-zero transform coefficient levels TotalCoeff( coeff_token ) and the number of trailing one
transform coefficient levels TrailingOnes( coeff_token ) are derived by parsing coeff_token as specified in
clause 9.2.1.


3. The following then applies:


    - If the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is equal to 0, the list
coeffLevel (in which all transform coefficient level values are equal to 0) is returned and no further steps are
carried out.


    - Otherwise, the following steps are carried out:


a. The non-zero transform coefficient levels are derived by parsing trailing_ones_sign_flag, level_prefix,

and level_suffix as specified in clause 9.2.2.


b. The runs of zero transform coefficient levels before each non-zero transform coefficient level are derived

by parsing total_zeros and run_before as specified in clause 9.2.3.


c. The level and run information are combined into the list coeffLevel as specified in clause 9.2.4.


**9.2.1** **Parsing process for total number of non-zero transform coefficient levels and number of trailing ones**


Inputs to this process are bits from slice data, a maximum number of non-zero transform coefficient levels maxNumCoeff,
the luma block index luma4x4BlkIdx or the chroma block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx of the
current block of transform coefficient levels.


Outputs of this process are TotalCoeff( coeff_token ), TrailingOnes( coeff_token ), and the variable nC.


The syntax element coeff_token is decoded using one of the six VLCs specified in the six right-most columns of Table 9-5.
Each VLC specifies both TotalCoeff( coeff_token ) and TrailingOnes( coeff_token ) for a given codeword coeff_token.
The selection of the applicable column of Table 9-5 is determined by a variable nC. The value of nC is derived as follows:


- If the CAVLC parsing process is invoked for ChromaDCLevel, nC is derived as follows:





   - If ChromaArrayType is equal to 1, nC is set equal to −1,


   - Otherwise (ChromaArrayType is equal to 2), nC is set equal to −2,


- Otherwise, the following ordered steps are performed:


1. When the CAVLC parsing process is invoked for Intra16x16DCLevel, luma4x4BlkIdx is set equal to 0.


2. When the CAVLC parsing process is invoked for CbIntra16x16DCLevel, cb4x4BlkIdx is set equal to 0.


3. When the CAVLC parsing process is invoked for CrIntra16x16DCLevel, cr4x4BlkIdx is set equal to 0.


4. The variables blkA and blkB are derived as follows:


       - If the CAVLC parsing process is invoked for Intra16x16DCLevel, Intra16x16ACLevel, or
LumaLevel4x4, the process specified in clause 6.4.11.4 is invoked with luma4x4BlkIdx as the input, and
the output is assigned to mbAddrA, mbAddrB, luma4x4BlkIdxA, and luma4x4BlkIdxB. The 4x4 luma
block specified by mbAddrA\luma4x4BlkIdxA is assigned to blkA, and the 4x4 luma block specified by
mbAddrB\luma4x4BlkIdxB is assigned to blkB.


       - Otherwise, if the CAVLC parsing process is invoked for CbIntra16x16DCLevel, CbIntra16x16ACLevel,
or CbLevel4x4, the process specified in clause 6.4.11.6 is invoked with cb4x4BlkIdx as the input, and
the output is assigned to mbAddrA, mbAddrB, cb4x4BlkIdxA, and cb4x4BlkIdxB. The 4x4 Cb block
specified by mbAddrA\cb4x4BlkIdxA is assigned to blkA, and the 4x4 Cb block specified by
mbAddrB\cb4x4BlkIdxB is assigned to blkB.


       - Otherwise, if the CAVLC parsing process is invoked for CrIntra16x16DCLevel, CrIntra16x16ACLevel,
or CrLevel4x4, the process specified in clause 6.4.11.6 is invoked with cr4x4BlkIdx as the input, and the
output is assigned to mbAddrA, mbAddrB, cr4x4BlkIdxA, and cr4x4BlkIdxB. The 4x4 Cr block
specified by mbAddrA\cr4x4BlkIdxA is assigned to blkA, and the 4x4 Cr block specified by
mbAddrB\cr4x4BlkIdxB is assigned to blkB.


       - Otherwise (the CAVLC parsing process is invoked for ChromaACLevel), the process specified in
clause 6.4.11.5 is invoked with chroma4x4BlkIdx as input, and the output is assigned to mbAddrA,
mbAddrB, chroma4x4BlkIdxA, and chroma4x4BlkIdxB. The 4x4 chroma block specified by
mbAddrA\iCbCr\chroma4x4BlkIdxA is assigned to blkA, and the 4x4 chroma block specified by
mbAddrB\iCbCr\chroma4x4BlkIdxB is assigned to blkB.


5. The variable availableFlagN with N being replaced by A and B is derived as follows:


       - If any of the following conditions are true, availableFlagN is set equal to 0:


          - mbAddrN is not available,


          - the current macroblock is coded using an Intra macroblock prediction mode,
constrained_intra_pred_flag is equal to 1, mbAddrN is coded using an Inter macroblock prediction
mode, and slice data partitioning is in use (nal_unit_type is in the range of 2 to 4, inclusive).


       - Otherwise, availableFlagN is set equal to 1.


6. For N being replaced by A and B, when availableFlagN is equal to 1, the variable nN is derived as follows:


       - If any of the following conditions are true, nN is set equal to 0:


          - The macroblock mbAddrN has mb_type equal to P_Skip or B_Skip,


          - The macroblock mbAddrN has mb_type not equal to I_PCM and all AC residual transform
coefficient levels of the neighbouring block blkN are equal to 0 due to the corresponding bit of
CodedBlockPatternLuma or CodedBlockPatternChroma being equal to 0.


       - Otherwise, if mbAddrN is an I_PCM macroblock, nN is set equal to 16.


       - Otherwise, nN is set equal to the value TotalCoeff( coeff_token ) of the neighbouring block blkN.

NOTE 1 – The values nA and nB that are derived using TotalCoeff( coeff_token ) do not include the DC transform
coefficient levels in Intra_16x16 macroblocks or DC transform coefficient levels in chroma blocks, because these
transform coefficient levels are decoded separately. When the block above or to the left belongs to an Intra_16x16
macroblock, nA or nB is the number of decoded non-zero AC transform coefficient levels for the adjacent 4x4
block in the Intra_16x16 macroblock. When the block above or to the left is a chroma block, nA or nB is the
number of decoded non-zero AC transform coefficient levels for the adjacent chroma block.
NOTE 2 – When parsing for Intra16x16DCLevel, CbIntra16x16DCLevel, or CrIntra16x16DCLevel, the values
nA and nB are based on the number of non-zero transform coefficient levels in adjacent 4x4 blocks and not on the
number of non-zero DC transform coefficient levels in adjacent 16x16 blocks.





7. The variable nC is derived as follows:


       - If availableFlagA is equal to 1 and availableFlagB is equal to 1, the variable nC is set equal to
( nA + nB + 1 ) >> 1.


       - Otherwise, if availableFlagA is equal to 1 (and availableFlagB is equal to 0), the variable nC is set equal
to nA.


       - Otherwise, if availableFlagB is equal to 1 (and availableFlagA is equal to 0), the variable nC is set equal
to nB.


       - Otherwise (availableFlagA is equal to 0 and availableFlagB is equal to 0), the variable nC is set equal
to 0.


When maxNumCoeff is equal to 15, it is a requirement of bitstream conformance that the value of
TotalCoeff( coeff_token ) resulting from decoding coeff_token shall not be equal to 16.


**Table 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token )**

|TrailingOnes ( coeff_token )|TotalCoeff ( coeff_token )|0 <= nC < 2|2 <= nC < 4|4 <= nC < 8|8 <= nC|nC = = −1|nC = = −2|
|---|---|---|---|---|---|---|---|
|0|0|1|11|1111|0000 11|01|1|
|0|1|0001 01|0010 11|0011 11|0000 00|0001 11|0001 111|
|1|1|01|10|1110|0000 01|1|01|
|0|2|0000 0111|0001 11|0010 11|0001 00|0001 00|0001 110|
|1|2|0001 00|0011 1|0111 1|0001 01|0001 10|0001 101|
|2|2|001|011|1101|0001 10|001|001|
|0|3|0000 0011 1|0000 111|0010 00|0010 00|0000 11|0000 0011 1|
|1|3|0000 0110|0010 10|0110 0|0010 01|0000 011|0001 100|
|2|3|0000 101|0010 01|0111 0|0010 10|0000 010|0001 011|
|3|3|0001 1|0101|1100|0010 11|0001 01|0000 1|
|0|4|0000 0001 11|0000 0111|0001 111|0011 00|0000 10|0000 0011 0|
|1|4|0000 0011 0|0001 10|0101 0|0011 01|0000 0011|0000 0010 1|
|2|4|0000 0101|0001 01|0101 1|0011 10|0000 0010|0001 010|
|3|4|0000 11|0100|1011|0011 11|0000 000|0000 01|
|0|5|0000 0000 111|0000 0100|0001 011|0100 00|-|0000 0001 11|
|1|5|0000 0001 10|0000 110|0100 0|0100 01|-|0000 0001 10|
|2|5|0000 0010 1|0000 101|0100 1|0100 10|-|0000 0010 0|
|3|5|0000 100|0011 0|1010|0100 11|-|0001 001|
|0|6|0000 0000 0111 1|0000 0011 1|0001 001|0101 00|-|0000 0000 111|
|1|6|0000 0000 110|0000 0110|0011 10|0101 01|-|0000 0000 110|
|2|6|0000 0001 01|0000 0101|0011 01|0101 10|-|0000 0001 01|
|3|6|0000 0100|0010 00|1001|0101 11|-|0001 000|
|0|7|0000 0000 0101 1|0000 0001 111|0001 000|0110 00|-|0000 0000 0111|
|1|7|0000 0000 0111 0|0000 0011 0|0010 10|0110 01|-|0000 0000 0110|
|2|7|0000 0000 101|0000 0010 1|0010 01|0110 10|-|0000 0000 101|






**Table 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token )**

|TrailingOnes ( coeff_token )|TotalCoeff ( coeff_token )|0 <= nC < 2|2 <= nC < 4|4 <= nC < 8|8 <= nC|nC = = −1|nC = = −2|
|---|---|---|---|---|---|---|---|
|3|7|0000 0010 0|0001 00|1000|0110 11|-|0000 0001 00|
|0|8|0000 0000 0100 0|0000 0001 011|0000 1111|0111 00|-|0000 0000 0011 1|
|1|8|0000 0000 0101 0|0000 0001 110|0001 110|0111 01|-|0000 0000 0101|
|2|8|0000 0000 0110 1|0000 0001 101|0001 101|0111 10|-|0000 0000 0100|
|3|8|0000 0001 00|0000 100|0110 1|0111 11|-|0000 0000 100|
|0|9|0000 0000 0011 11|0000 0000 1111|0000 1011|1000 00|-|-|
|1|9|0000 0000 0011 10|0000 0001 010|0000 1110|1000 01|-|-|
|2|9|0000 0000 0100 1|0000 0001 001|0001 010|1000 10|-|-|
|3|9|0000 0000 100|0000 0010 0|0011 00|1000 11|-|-|
|0|10|0000 0000 0010 11|0000 0000 1011|0000 0111 1|1001 00|-|-|
|1|10|0000 0000 0010 10|0000 0000 1110|0000 1010|1001 01|-|-|
|2|10|0000 0000 0011 01|0000 0000 1101|0000 1101|1001 10|-|-|
|3|10|0000 0000 0110 0|0000 0001 100|0001 100|1001 11|-|-|
|0|11|0000 0000 0001 111|0000 0000 1000|0000 0101 1|1010 00|-|-|
|1|11|0000 0000 0001 110|0000 0000 1010|0000 0111 0|1010 01|-|-|
|2|11|0000 0000 0010 01|0000 0000 1001|0000 1001|1010 10|-|-|
|3|11|0000 0000 0011 00|0000 0001 000|0000 1100|1010 11|-|-|
|0|12|0000 0000 0001 011|0000 0000 0111 1|0000 0100 0|1011 00|-|-|
|1|12|0000 0000 0001 010|0000 0000 0111 0|0000 0101 0|1011 01|-|-|
|2|12|0000 0000 0001 101|0000 0000 0110 1|0000 0110 1|1011 10|-|-|
|3|12|0000 0000 0010 00|0000 0000 1100|0000 1000|1011 11|-|-|
|0|13|0000 0000 0000 1111|0000 0000 0101 1|0000 0011 01|1100 00|-|-|
|1|13|0000 0000 0000 001|0000 0000 0101 0|0000 0011 1|1100 01|-|-|
|2|13|0000 0000 0001 001|0000 0000 0100 1|0000 0100 1|1100 10|-|-|
|3|13|0000 0000 0001 100|0000 0000 0110 0|0000 0110 0|1100 11|-|-|
|0|14|0000 0000 0000 1011|0000 0000 0011 1|0000 0010 01|1101 00|-|-|
|1|14|0000 0000 0000 1110|0000 0000 0010 11|0000 0011 00|1101 01|-|-|
|2|14|0000 0000 0000 1101|0000 0000 0011 0|0000 0010 11|1101 10|-|-|
|3|14|0000 0000 0001 000|0000 0000 0100 0|0000 0010 10|1101 11|-|-|
|0|15|0000 0000 0000 0111|0000 0000 0010 01|0000 0001 01|1110 00|-|-|
|1|15|0000 0000 0000 1010|0000 0000 0010 00|0000 0010 00|1110 01|-|-|
|2|15|0000 0000 0000 1001|0000 0000 0010 10|0000 0001 11|1110 10|-|-|
|3|15|0000 0000 0000 1100|0000 0000 0000 1|0000 0001 10|1110 11|-|-|
|0|16|0000 0000 0000 0100|0000 0000 0001 11|0000 0000 01|1111 00|-|-|






**Table 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token )**

|TrailingOnes ( coeff_token )|TotalCoeff ( coeff_token )|0 <= nC < 2|2 <= nC < 4|4 <= nC < 8|8 <= nC|nC = = −1|nC = = −2|
|---|---|---|---|---|---|---|---|
|1|16|0000 0000 0000 0110|0000 0000 0001 10|0000 0001 00|1111 01|-|-|
|2|16|0000 0000 0000 0101|0000 0000 0001 01|0000 0000 11|1111 10|-|-|
|3|16|0000 0000 0000 1000|0000 0000 0001 00|0000 0000 10|1111 11|-|-|



**9.2.2** **Parsing process for level information**


Inputs to this process are bits from slice data, the number of non-zero transform coefficient levels
TotalCoeff( coeff_token ), and the number of trailing one transform coefficient levels TrailingOnes( coeff_token ).


Output of this process is a list with name levelVal containing transform coefficient levels.


Initially an index i is set equal to 0. Then, when TrailingOnes( coeff_token ) is not equal to 0, the following ordered steps
are applied TrailingOnes( coeff_token ) times to decode the trailing one transform coefficient levels:


1. A 1-bit syntax element trailing_ones_sign_flag is decoded and evaluated as follows:


    - If trailing_ones_sign_flag is equal to 0, levelVal[ i ] is set equal to 1.


    - Otherwise (trailing_ones_sign_flag is equal to 1), levelVal[ i ] is set equal to −1.


2. The index i is incremented by 1.


Then, the variable suffixLength is initialized as follows:


- If TotalCoeff( coeff_token ) is greater than 10 and TrailingOnes( coeff_token ) is less than 3, suffixLength is set
equal to 1.


- Otherwise (TotalCoeff( coeff_token ) is less than or equal to 10 or TrailingOnes( coeff_token ) is equal to 3),
suffixLength is set equal to 0.


Then, when TotalCoeff( coeff_token ) − TrailingOnes( coeff_token ) is not equal to 0, the following ordered steps are
applied TotalCoeff( coeff_token ) − TrailingOnes( coeff_token ) times to decode the remaining non-zero level values:


1. The syntax element level_prefix is decoded as specified in clause 9.2.2.1.


2. The variable levelSuffixSize is set as follows:


    - If level_prefix is equal to 14 and suffixLength is equal to 0, levelSuffixSize is set equal to 4.


    - Otherwise, if level_prefix is greater than or equal to 15, levelSuffixSize is set equal to level_prefix − 3.


    - Otherwise, levelSuffixSize is set equal to suffixLength.


3. The syntax element level_suffix is decoded as follows:


    - If levelSuffixSize is greater than 0, the syntax element level_suffix is decoded as unsigned integer
representation u(v) with levelSuffixSize bits.


    - Otherwise (levelSuffixSize is equal to 0), the syntax element level_suffix is inferred to be equal to 0.


4. The variable levelCode is set equal to ( Min( 15, level_prefix ) << suffixLength ) + level_suffix.


5. When level_prefix is greater than or equal to 15 and suffixLength is equal to 0, levelCode is incremented by 15.


6. When level_prefix is greater than or equal to 16, levelCode is incremented by (1<<( level_prefix − 3 )) − 4096.


7. When the index i is equal to TrailingOnes( coeff_token ) and TrailingOnes( coeff_token ) is less than 3, levelCode

is incremented by 2.


8. The variable levelVal[ i ] is derived as follows:


    - If levelCode is an even number, levelVal[ i ] is set equal to ( levelCode + 2 ) >> 1.





    - Otherwise (levelCode is an odd number), levelVal[ i ] is set equal to ( −levelCode − 1) >> 1.


9. When suffixLength is equal to 0, suffixLength is set equal to 1.


10. When the absolute value of levelVal[ i ] is greater than ( 3 << ( suffixLength − 1 ) ) and suffixLength is less than 6,

suffixLength is incremented by 1.


11. The index i is incremented by 1.


**9.2.2.1** **Parsing process for level_prefix**


Inputs to this process are bits from slice data.


Output of this process is level_prefix.


The parsing process for this syntax element consists in reading the bits starting at the current location in the bitstream up
to and including the first non-zero bit, and counting the number of leading bits that are equal to 0. This process is specified
as follows:

leadingZeroBits = −1
for( b = 0; !b; leadingZeroBits++ ) (9-4)
b = read_bits( 1 )
level_prefix = leadingZeroBits


Table 9-6 illustrates the codeword table for level_prefix.

NOTE – The value of level_prefix is constrained to not exceed 15 in bitstreams conforming to the Baseline, Constrained Baseline,
Main, and Extended profiles, as specified in clauses A.2.1, A.2.1.1, A.2.2, and A.2.3, respectively. In bitstreams conforming to other
profiles, it has been reported that the value of level_prefix cannot exceed 11 + bitDepth with bitDepth being the variable BitDepthY
for transform coefficient blocks related to the luma component and being the variable BitDepthC for transform coefficient blocks
related to a chroma component.


**Table 9-6 – Codeword table for level_prefix (informative)**

|level_prefix|bit string|
|---|---|
|0|1|
|1|01|
|2|001|
|3|0001|
|4|0000 1|
|5|0000 01|
|6|0000 001|
|7|0000 0001|
|8|0000 0000 1|
|9|0000 0000 01|
|10|0000 0000 001|
|11|0000 0000 0001|
|12|0000 0000 0000 1|
|13|0000 0000 0000 01|
|14|0000 0000 0000 001|
|15|0000 0000 0000 0001|
|…|…|






**9.2.3** **Parsing process for run information**


Inputs to this process are bits from slice data, the number of non-zero transform coefficient levels
TotalCoeff( coeff_token ), and the maximum number of non-zero transform coefficient levels maxNumCoeff.


Output of this process is a list of runs of zero transform coefficient levels preceding non-zero transform coefficient levels
called runVal.


Initially, an index i is set equal to 0.


The variable zerosLeft is derived as follows:


- If the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is equal to the maximum number of
non-zero transform coefficient levels maxNumCoeff, a variable zerosLeft is set equal to 0.


- Otherwise (the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is less than the maximum
number of non-zero transform coefficient levels maxNumCoeff), total_zeros is decoded and zerosLeft is set equal to
its value.


The variable tzVlcIndex is set equal to TotalCoeff( coeff_token ).


The VLC used to decode total_zeros is derived as follows:


- If maxNumCoeff is equal to 4, one of the VLCs specified in Table 9-9 (a) is used.


- Otherwise, if maxNumCoeff is equal to 8, one of the VLCs specified in Table 9-9 (b) is used.


- Otherwise (maxNumCoeff is not equal to 4 and not equal to 8), VLCs from Tables 9-7 and 9-8 are used.


The following ordered steps are then performed TotalCoeff( coeff_token ) − 1 times:


1. The variable runVal[ i ] is derived as follows:


     - If zerosLeft is greater than zero, a value run_before is decoded based on Table 9-10 and zerosLeft. runVal[ i ]
is set equal to run_before.


     - Otherwise (zerosLeft is equal to 0), runVal[ i ] is set equal to 0.


2. The value of runVal[ i ] is subtracted from zerosLeft and the result is assigned to zerosLeft. It is a requirement of

bitstream conformance that the result of the subtraction shall be greater than or equal to 0.


3. The index i is incremented by 1.


Finally the value of zerosLeft is assigned to runVal[ i ].





**Table 9-7 – total_zeros tables for 4x4 blocks with tzVlcIndex 1 to 7**

|total_zeros|tzVlcIndex|Col3|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
||1|2|3|4|5|6|7|
|0|1|111|0101|0001 1|0101|0000 01|0000 01|
|1|011|110|111|111|0100|0000 1|0000 1|
|2|010|101|110|0101|0011|111|101|
|3|0011|100|101|0100|111|110|100|
|4|0010|011|0100|110|110|101|011|
|5|0001 1|0101|0011|101|101|100|11|
|6|0001 0|0100|100|100|100|011|010|
|7|0000 11|0011|011|0011|011|010|0001|
|8|0000 10|0010|0010|011|0010|0001|001|
|9|0000 011|0001 1|0001 1|0010|0000 1|001|0000 00|
|10|0000 010|0001 0|0001 0|0001 0|0001|0000 00|-|
|11|0000 0011|0000 11|0000 01|0000 1|0000 0|-|-|
|12|0000 0010|0000 10|0000 1|0000 0|-|-|-|
|13|0000 0001 1|0000 01|0000 00|-|-|-|-|
|14|0000 0001 0|0000 00|-|-|-|-|-|
|15|0000 0000 1|-|-|-|-|-|-|



**Table 9-8 – total_zeros tables for 4x4 blocks with tzVlcIndex 8 to 15**

|total_zeros|tzVlcIndex|Col3|Col4|Col5|Col6|Col7|Col8|Col9|
|---|---|---|---|---|---|---|---|---|
||8|9|10|11|12|13|14|15|
|0|0000 01|0000 01|0000 1|0000|0000|000|00|0|
|1|0001|0000 00|0000 0|0001|0001|001|01|1|
|2|0000 1|0001|001|001|01|1|1|-|
|3|011|11|11|010|1|01|-|-|
|4|11|10|10|1|001|-|-|-|
|5|10|001|01|011|-|-|-|-|
|6|010|01|0001|-|-|-|-|-|
|7|001|0000 1|-|-|-|-|-|-|
|8|0000 00|-|- <br>|-|-|-|-|-|






**Table 9-9 – total_zeros tables for chroma DC 2x2 and 2x4 blocks**


**(a) Chroma DC 2x2 block (4:2:0 chroma sampling)**

|total_zeros|tzVlcIndex|Col3|Col4|
|---|---|---|---|
|**total_zeros**|1|2|3|
|0|1|1|1|
|1|01|01|0|
|2|001|00|-|
|3|000<br>|-|-|



**(b) Chroma DC 2x4 block (4:2:2 chroma sampling)**

|total_zeros|tzVlcIndex|Col3|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
|**total_zeros**|1|2|3|4|5|6|7|
|0|1|000|000|110|00|00|0|
|1|010|01|001|00|01|01|1|
|2|011|001|01|01|10|1|-|
|3|0010|100|10|10|11|-|-|
|4|0011|101|110|111|-|-|-|
|5|0001|110|111|-|-|-|-|
|6|0000 1|111|-|-|-|-|-|
|7|0000 0|-|-|-|-|-|-|






**Table 9-10 – Tables for run_before**







|run_before|zerosLeft|Col3|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
|run_before<br>|1|2|3|4|5|6|>6|
|0|1|1|11|11|11|11|111|
|1|0|01|10|10|10|000|110|
|2|-|00|01|01|011|001|101|
|3|-|-|00|001|010|011|100|
|4|-|-|-|000|001|010|011|
|5|-|-|-|-|000|101|010|
|6|-|-|-|-|-|100|001|
|7|-|-|-|-|-|-|0001|
|8||-|-|-|-|-|00001|
|9|-|-|-|-|-|-|000001|
|10|-|-|-|-|-|-|0000001|
|11|-|-|-|-|-|-|00000001|
|12|-|-|-|-|-|-|000000001|
|13|-|-|-|-|-|-|0000000001|
|14|-|-|-|-|-|-|00000000001|


**9.2.4** **Combining level and run information**


Input to this process are a list of transform coefficient levels called levelVal, a list of runs called runVal, and the number
of non-zero transform coefficient levels TotalCoeff( coeff_token ).


Output of this process is an list coeffLevel of transform coefficient levels.


A variable coeffNum is set equal to −1 and an index i is set equal to TotalCoeff( coeff_token ) − 1. The following ordered
steps are then applied TotalCoeff( coeff_token ) times:


1. coeffNum is incremented by runVal[ i ] + 1.


2. coeffLevel[ coeffNum ] is set equal to levelVal[ i ].


3. The index i is decremented by 1.
