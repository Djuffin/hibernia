**9.3** **CABAC parsing process for slice data**


This process is invoked when parsing syntax elements with descriptor ae(v) in clauses 7.3.4 and 7.3.5 when
entropy_coding_mode_flag is equal to 1.


Inputs to this process are a request for a value of a syntax element and values of prior parsed syntax elements.


Output of this process is the value of the syntax element.


When starting the parsing of the slice data of a slice in clause 7.3.4, the initialization process of the CABAC parsing process
is invoked as specified in clause 9.3.1.


The parsing of syntax elements proceeds as follows.


For each requested value of a syntax element a binarization is derived as described in clause 9.3.2.


The binarization for the syntax element and the sequence of parsed bins determines the decoding process flow as described
in clause 9.3.3.





For each bin of the binarization of the syntax element, which is indexed by the variable binIdx, a context index ctxIdx is
derived as specified in clause 9.3.3.1.


For each ctxIdx the arithmetic decoding process is invoked as specified in clause 9.3.3.2.


The resulting sequence ( b0..bbinIdx ) of parsed bins is compared to the set of bin strings given by the binarization process
after decoding of each bin. When the sequence matches a bin string in the given set, the corresponding value is assigned
to the syntax element.


In case the request for a value of a syntax element is processed for the syntax element mb_type and the decoded value of
mb_type is equal to I_PCM, the decoding engine is initialized after the decoding of any pcm_alignment_zero_bit and all
pcm_sample_luma and pcm_sample_chroma data as specified in clause 9.3.1.2.


The whole CABAC parsing process is illustrated in the flowchart of Figure 9-1 with the abbreviation SE for syntax element.





**Figure 9-1 – Illustration of CABAC parsing process for a syntax element SE (informative)**


**9.3.1** **Initialization process**


Outputs of this process are initialized CABAC internal variables.


The processes in clauses 9.3.1.1 and 9.3.1.2 are invoked when starting the parsing of the slice data of a slice in clause 7.3.4.


The process in clause 9.3.1.2 is also invoked after decoding any pcm_alignment_zero_bit and all pcm_sample_luma and
pcm_sample_chroma data for a macroblock of type I_PCM.


**9.3.1.1** **Initialization process for context variables**


Outputs of this process are the initialized CABAC context variables indexed by ctxIdx.





Tables 9-12 to 9-33 contain the values of the variables n and m used in the initialization of context variables that are
assigned to all syntax elements in clauses 7.3.4 and 7.3.5 except for the end-of-slice flag.


For each context variable, the two variables pStateIdx and valMPS are initialized.

NOTE 1 – The variable pStateIdx corresponds to a probability state index and the variable valMPS corresponds to the value of the
most probable symbol as further described in clause 9.3.3.2.


The two values assigned to pStateIdx and valMPS for the initialization are derived from SliceQPY, which is derived in
Equation 7-30. Given the two table entries ( m, n ), the initialization is specified by the following pseudo-code process:

preCtxState = Clip3( 1, 126, ( ( m  Clip3( 0, 51, SliceQPY ) ) >> 4 ) + n )
if( preCtxState <= 63 ) {
pStateIdx = 63 − preCtxState
valMPS = 0 (9-5)
} else {
pStateIdx = preCtxState − 64
valMPS = 1
}


In Table 9-11, the ctxIdx for which initialization is needed for each of the slice types are listed. Also listed is the table
number that includes the values of m and n needed for the initialization. For P, SP and B slice type, the initialization
depends also on the value of the cabac_init_idc syntax element. Note that the syntax element names do not affect the
initialization process.





**Table 9-11 – Association of ctxIdx and syntax elements for each slice type in the initialization process**















|Col1|Syntax element|Table|Slice type|Col5|Col6|Col7|
|---|---|---|---|---|---|---|
||**Syntax element**|**Table**|**SI**|**I **|**P, SP**|**B **|
|slice_data( )|mb_skip_flag|Table9-13 <br>Table9-14|||11..13|24..26|
|slice_data( )|mb_field_decoding_flag|Table9-18|70..72|70..72|70..72|70..72|
|macroblock_layer( )|mb_type|Table9-12 <br>Table9-13 <br>Table9-14|0..10|3..10|14..20|27..35|
|macroblock_layer( )|transform_size_8x8_flag|Table9-16|na|399..401|399..401|399..401|
|macroblock_layer( )|coded_block_pattern (luma)|Table9-18|73..76|73..76|73..76|73..76|
|macroblock_layer( )|coded_block_pattern (chroma)|Table9-18|77..84|77..84|77..84|77..84|
|macroblock_layer( )|mb_qp_delta|Table9-17|60..63|60..63|60..63|60..63|
|mb_pred( )|prev_intra4x4_pred_mode_flag|Table9-17|68|68|68|68|
|mb_pred( )|rem_intra4x4_pred_mode|Table9-17|69|69|69|69|
|mb_pred( )|prev_intra8x8_pred_mode_flag|Table9-17|na|68|68|68|
|mb_pred( )|rem_intra8x8_pred_mode|Table9-17|na|69|69|69|
|mb_pred( )|intra_chroma_pred_mode|Table9-17|64..67|64..67|64..67|64..67|
|mb_pred( ) and<br>sub_mb_pred( )|ref_idx_l0|Table9-16|||54..59|54..59|
|mb_pred( ) and<br>sub_mb_pred( )|ref_idx_l1|Table9-16||||54..59|
|mb_pred( ) and<br>sub_mb_pred( )|mvd_l0[ ][ ][ 0 ]|Table9-15|||40..46|40..46|
|mb_pred( ) and<br>sub_mb_pred( )|mvd_l1[ ][ ][ 0 ]|Table9-15||||40..46|
|mb_pred( ) and<br>sub_mb_pred( )|mvd_l0[ ][ ][ 1 ]|Table9-15|||47..53|47..53|
|mb_pred( ) and<br>sub_mb_pred( )|mvd_l1[ ][ ][ 1 ]|Table9-15||||47..53|
|sub_mb_pred( )|sub_mb_type[ ]|Table9-13 <br>Table9-14|||21..23|36..39|









**Table 9-11 – Association of ctxIdx and syntax elements for each slice type in the initialization process**
















|Col1|Syntax element|Table|Slice type|Col5|Col6|Col7|
|---|---|---|---|---|---|---|
||**Syntax element**|**Table**|**SI**|**I **|**P, SP**|**B **|
|residual_block_cabac( )|coded_block_flag|Table9-18 <br>Table9-25 <br>Table9-33|85..104<br>460..483<br>|85..104<br>460..483<br>1012..1023|85..104<br>460..483<br>1012..1023|85..104<br>460..483<br>1012..1023|
|residual_block_cabac( )|significant_coeff_flag[ ]|Table9-19 <br>Table9-22 <br>Table9-24 <br>Table9-24 <br>Table9-26 <br>Table9-30 <br>Table9-28 <br>Table9-29|105..165<br>277..337<br> <br> <br> <br> <br> <br>|105..165<br>277..337<br>402..416<br>436..450<br>484..571<br>776..863<br>660..689<br>718..747|105..165<br>277..337<br>402..416<br>436..450<br>484..571<br>776..863<br>660..689<br>718..747|105..165<br>277..337<br>402..416<br>436..450<br>484..571<br>776..863<br>660..689<br>718..747|
|residual_block_cabac( )|last_significant_coeff_flag[ ]|Table9-20 <br>Table9-23 <br>Table9-24 <br>Table9-24 <br>Table9-27 <br>Table9-31 <br>Table9-28 <br>Table9-29|166..226<br>338..398<br> <br> <br> <br> <br> <br>|166..226<br>338..398<br>417..425<br>451..459<br>572..659<br>864..951<br>690..707<br>748..765|166..226<br>338..398<br>417..425<br>451..459<br>572..659<br>864..951<br>690..707<br>748..765|166..226<br>338..398<br>417..425<br>451..459<br>572..659<br>864..951<br>690..707<br>748..765|
|residual_block_cabac( )|coeff_abs_level_minus1[ ]|Table9-21 <br>Table9-24 <br>Table9-32 <br>Table9-28 <br>Table9-29 <br>|227..275<br> <br> <br> <br>|227..275<br>426..435<br>952..1011<br>708..717<br>766..775|227..275<br>426..435<br>952..1011<br>708..717<br>766..775|227..275<br>426..435<br>952..1011<br>708..717<br>766..775|



NOTE 2 – ctxIdx equal to 276 is associated with the end_of_slice_flag and the bin of mb_type, which specifies the I_PCM
macroblock type. The decoding process specified in clause 9.3.3.2.4 applies to ctxIdx equal to 276. This decoding process, however,
may also be implemented by using the decoding process specified in clause 9.3.3.2.1. In this case, the initial values associated with
ctxIdx equal to 276 are specified to be pStateIdx = 63 and valMPS = 0, where pStateIdx = 63 represents a non-adapting probability
state.


**Table 9-12 – Values of variables m and n for ctxIdx from 0 to 10**







|Initialization<br>variables|ctxIdx|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|
|---|---|---|---|---|---|---|---|---|---|---|---|
|**Initialization**<br>**variables**|**0 **|**1 **|**2 **|**3 **|**4 **|**5 **|**6 **|**7 **|**8 **|**9 **|**10**|
|**m **|20|2|3|20|2|3|−28|−23|−6|−1|7|
|**n **|−15|54|74|−15|54|74|127|104|53|54|51|


**Table 9-13 – Values of variables m and n for ctxIdx from 11 to 23**









|Value of<br>cabac_init_idc|Initialization<br>variables|ctxIdx|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Value of**<br>**cabac_init_idc**|**Initialization**<br>**variables**|**11**|**12**|**13**|**14**|**15**|**16**|**17**|**18**|**19**|**20**|**21**|**22**|**23**|
|**0 **|**m **|23|23|21|1|0|−37|5|−13|−11|1|12|−4|17|
|**0 **|**n **|33|2|0|9|49|118|57|78|65|62|49|73|50|
|**1 **|**m **|22|34|16|−2|4|−29|2|−6|−13|5|9|−3|10|
|**1 **|**n **|25|0|0|9|41|118|65|71|79|52|50|70|54|
|**2 **|**m **|29|25|14|−10|−3|−27|26|−4|−24|5|6|−17|14|
|**2 **|**n **|16|0|0|51|62<br>|99|16|85|102|57|57|73|57|





**Table 9-14 – Values of variables m and n for ctxIdx from 24 to 39**















































|Value of<br>cabac_init_idc|Initializatio<br>n variables|ctxIdx|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Value of**<br>**cabac_init_idc**|**Initializatio**<br>**n variables**|**24**|**25**|**26**|**27**|**28**|**29**|**30**|**31**|**32**|**33**|**34**|**35**|**36**|**37**|**38**|**39**|
|**0 **|**m **|18|9|29|26|16|9|−4<br>6|−2<br>0|1|−1<br>3|−1<br>1|1|−6|−1<br>7|−6|9|
|**0 **|**n **|64|43|0|67|90|104|127|104|67|78|65|62|86|95|61|45|
|**1 **|**m **|26|19|40|57|41|26|−4<br>5|−1<br>5|−4|−6|−1<br>3|5|6|−1<br>3|0|8|
|**1 **|**n **|34|22|0|2|36|69|127|101|76|71|79|52|69|90|52|43|
|**2 **|**m **|20|20|29|54|37|12|−3<br>2|−2<br>2|−2|−4|−2<br>4|5|−6|−1<br>4|−6|4|
|**2 **|**n **|40|10|0|0|42|97<br>|127|117|74|85|102|57|93|88|44|55|


**Table 9-15 – Values of variables m and n for ctxIdx from 40 to 53**









|Value of<br>cabac_init_idc|Initialization<br>variables|ctxIdx|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|Col16|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Value of**<br>**cabac_init_idc**|**Initialization**<br>**variables**|**40**|**41**|**42**|**43**|**44**|**45**|**46**|**47**|**48**|**49**|**50**|**51**|**52**|**53**|
|**0 **|**m **|−3|−6|−11|6|7|−5|2|0|−3|−10|5|4|−3|0|
|**0 **|**n **|69|81|96|55|67|86|88|58|76|94|54|69|81|88|
|**1 **|**m **|−2|−5|−10|2|2|−3|−3|1|−3|−6|0|−3|−7|−5|
|**1 **|**n **|69|82|96|59|75|87|100|56|74|85|59|81|86|95|
|**2 **|**m **|−11|−15|−21|19|20|4|6|1|−5|−13|5|6|−3|−1|
|**2 **|**n **|89|103|116|57|58<br>|84|96|63|85|106|63|75|90|101|


**Table 9-16 – Values of variables m and n for ctxIdx from 54 to 59, and 399 to 401**

|Value of cabac_init_idc|Initialization variables|ctxIdx|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|
|---|---|---|---|---|---|---|---|---|---|---|
|**Value of cabac_init_idc**|**Initialization variables**|**54**|**55**|**56**|**57**|**58**|**59**|**399**|**400**|**401**|
|**I slices**|**m **|na|na|na|na|na|na|31|31|25|
|**I slices**|**n **|na|na|na|na|na|na|21|31|50|
|**0 **|**m **|−7|−5|−4|−5|−7|1|12|11|14|
|**0 **|**n **|67|74|74|80|72|58|40|51|59|
|**1 **|**m **|−1|−1|1|−2|−5|0|25|21|21|
|**1 **|**n **|66|77|70|86|72|61|32|49|54|
|**2 **|**m **|3|−4|−2|−12|−7|1|21|19|17|
|**2 **|**n **|55|79|75|97|50|60|33|50|61|






**Table 9-17 – Values of variables m and n for ctxIdx from 60 to 69**







|Initialization<br>variables|ctxIdx|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|
|---|---|---|---|---|---|---|---|---|---|---|
|**Initialization**<br>**variables**|**60**|**61**|**62**|**63**|**64**|**65**|**66**|**67**|**68**|**69**|
|**m **|0|0|0|0|−9|4|0|−7|13|3|
|**n **|41|63|63|63|83|86|97|72|41|62|


**Table 9-18 – Values of variables m and n for ctxIdx from 70 to 104**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**70**|0|11|0|45|13|15|7|34|**88**|−11|115|−13|108|−4|92|5|78|
|**71**|1|55|−4|78|7|51|−9|88|**89**|−12|63|−3|46|0|39|−6|55|
|**72**|0|69|−3|96|2|80|−20|127|**90**|−2|68|−1|65|0|65|4|61|
|**73**|−17|127|−27|126|−39|127|−36|127|**91**|−15|84|−1|57|−15|84|−14|83|
|**74**|−13|102|−28|98|−18|91|−17|91|**92**|−13|104|−9|93|−35|127|−37|127|
|**75**|0|82|−25|101|−17|96|−14|95|**93**|−3|70|−3|74|−2|73|−5|79|
|**76**|−7|74|−23|67|−26|81|−25|84|**94**|−8|93|−9|92|−12|104|−11|104|
|**77**|−21|107|−28|82|−35|98|−25|86|**95**|−10|90|−8|87|−9|91|−11|91|
|**78**|−27|127|−20|94|−24|102|−12|89|**96**|−30|127|−23|126|−31|127|−30|127|
|**79**|−31|127|−16|83|−23|97|−17|91|**97**|−1|74|5|54|3|55|0|65|
|**80**|−24|127|−22|110|−27|119|−31|127|**98**|−6|97|6|60|7|56|−2|79|
|**81**|−18|95|−21|91|−24|99|−14|76|**99**|−7|91|6|59|7|55|0|72|
|**82**|−27|127|−18|102|−21|110|−18|103|**100**|−20|127|6|69|8|61|−4|92|
|**83**|−21|114|−13|93|−18|102|−13|90|**101**|−4|56|−1|48|−3|53|−6|56|
|**84**|−30|127|−29|127|−36|127|−37|127|**102**|−5|82|0|68|0|68|3|68|
|**85**|−17|123|−7|92|0|80|11|80|**103**|−7|76|−4|69|−7|74|−8|71|
|**86**|−12|115|−5|89|−5|89|5|76|**104**|−22|125|−8|88|−9|88|−13|98|
|**87**|−16|122|−7|96|−7|94|2|84||||||||||





**Table 9-19 – Values of variables m and n for ctxIdx from 105 to 165**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**105**|−7|93|−2|85|−13|103|−4|86|**136**|−13|101|5|53|0|58|−5|75|
|**106**|−11|87|−6|78|−13|91|−12|88|**137**|−13|91|−2|61|−1|60|−8|80|
|**107**|−3|77|−1|75|−9|89|−5|82|**138**|−12|94|0|56|−3|61|−21|83|
|**108**|−5|71|−7|77|−14|92|−3|72|**139**|−10|88|0|56|−8|67|−21|64|
|**109**|−4|63|2|54|−8|76|−4|67|**140**|−16|84|−13|63|−25|84|−13|31|
|**110**|−4|68|5|50|−12|87|−8|72|**141**|−10|86|−5|60|−14|74|−25|64|
|**111**|−12|84|−3|68|−23|110|−16|89|**142**|−7|83|−1|62|−5|65|−29|94|
|**112**|−7|62|1|50|−24|105|−9|69|**143**|−13|87|4|57|5|52|9|75|
|**113**|−7|65|6|42|−10|78|−1|59|**144**|−19|94|−6|69|2|57|17|63|
|**114**|8|61|−4|81|−20|112|5|66|**145**|1|70|4|57|0|61|−8|74|
|**115**|5|56|1|63|−17|99|4|57|**146**|0|72|14|39|−9|69|−5|35|
|**116**|−2|66|−4|70|−78|127|−4|71|**147**|−5|74|4|51|−11|70|−2|27|
|**117**|1|64|0|67|−70|127|−2|71|**148**|18|59|13|68|18|55|13|91|
|**118**|0|61|2|57|−50|127|2|58|**149**|−8|102|3|64|−4|71|3|65|
|**119**|−2|78|−2|76|−46|127|−1|74|**150**|−15|100|1|61|0|58|−7|69|
|**120**|1|50|11|35|−4|66|−4|44|**151**|0|95|9|63|7|61|8|77|
|**121**|7|52|4|64|−5|78|−1|69|**152**|−4|75|7|50|9|41|−10|66|
|**122**|10|35|1|61|−4|71|0|62|**153**|2|72|16|39|18|25|3|62|
|**123**|0|44|11|35|−8|72|−7|51|**154**|−11|75|5|44|9|32|−3|68|
|**124**|11|38|18|25|2|59|−4|47|**155**|−3|71|4|52|5|43|−20|81|
|**125**|1|45|12|24|−1|55|−6|42|**156**|15|46|11|48|9|47|0|30|
|**126**|0|46|13|29|−7|70|−3|41|**157**|−13|69|−5|60|0|44|1|7|
|**127**|5|44|13|36|−6|75|−6|53|**158**|0|62|−1|59|0|51|−3|23|
|**128**|31|17|−10|93|−8|89|8|76|**159**|0|65|0|59|2|46|−21|74|
|**129**|1|51|−7|73|−34|119|−9|78|**160**|21|37|22|33|19|38|16|66|
|**130**|7|50|−2|73|−3|75|−11|83|**161**|−15|72|5|44|−4|66|−23|124|
|**131**|28|19|13|46|32|20|9|52|**162**|9|57|14|43|15|38|17|37|
|**132**|16|33|9|49|30|22|0|67|**163**|16|54|−1|78|12|42|44|−18|
|**133**|14|62|−7|100|−44|127|−5|90|**164**|0|62|0|60|9|34|50|−34|
|**134**|−13|108|9|53|0|54|1|67|**165**|12|72|9|69|0|89|−22|127|
|**135**|−15|100|2|53|−5|61|−15|72<br>||||||||||





**Table 9-20 – Values of variables m and n for ctxIdx from 166 to 226**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**166**|24|0|11|28|4|45|4|39|**197**|26|−17|28|3|36|−28|28|−3|
|**167**|15|9|2|40|10|28|0|42|**198**|30|−25|28|4|38|−28|24|10|
|**168**|8|25|3|44|10|31|7|34|**199**|28|−20|32|0|38|−27|27|0|
|**169**|13|18|0|49|33|−11|11|29|**200**|33|−23|34|−1|34|−18|34|−14|
|**170**|15|9|0|46|52|−43|8|31|**201**|37|−27|30|6|35|−16|52|−44|
|**171**|13|19|2|44|18|15|6|37|**202**|33|−23|30|6|34|−14|39|−24|
|**172**|10|37|2|51|28|0|7|42|**203**|40|−28|32|9|32|−8|19|17|
|**173**|12|18|0|47|35|−22|3|40|**204**|38|−17|31|19|37|−6|31|25|
|**174**|6|29|4|39|38|−25|8|33|**205**|33|−11|26|27|35|0|36|29|
|**175**|20|33|2|62|34|0|13|43|**206**|40|−15|26|30|30|10|24|33|
|**176**|15|30|6|46|39|−18|13|36|**207**|41|−6|37|20|28|18|34|15|
|**177**|4|45|0|54|32|−12|4|47|**208**|38|1|28|34|26|25|30|20|
|**178**|1|58|3|54|102|−94|3|55|**209**|41|17|17|70|29|41|22|73|
|**179**|0|62|2|58|0|0|2|58|**210**|30|−6|1|67|0|75|20|34|
|**180**|7|61|4|63|56|−15|6|60|**211**|27|3|5|59|2|72|19|31|
|**181**|12|38|6|51|33|−4|8|44|**212**|26|22|9|67|8|77|27|44|
|**182**|11|45|6|57|29|10|11|44|**213**|37|−16|16|30|14|35|19|16|
|**183**|15|39|7|53|37|−5|14|42|**214**|35|−4|18|32|18|31|15|36|
|**184**|11|42|6|52|51|−29|7|48|**215**|38|−8|18|35|17|35|15|36|
|**185**|13|44|6|55|39|−9|4|56|**216**|38|−3|22|29|21|30|21|28|
|**186**|16|45|11|45|52|−34|4|52|**217**|37|3|24|31|17|45|25|21|
|**187**|12|41|14|36|69|−58|13|37|**218**|38|5|23|38|20|42|30|20|
|**188**|10|49|8|53|67|−63|9|49|**219**|42|0|18|43|18|45|31|12|
|**189**|30|34|−1|82|44|−5|19|58|**220**|35|16|20|41|27|26|27|16|
|**190**|18|42|7|55|32|7|10|48|**221**|39|22|11|63|16|54|24|42|
|**191**|10|55|−3|78|55|−29|12|45|**222**|14|48|9|59|7|66|0|93|
|**192**|17|51|15|46|32|1|0|69|**223**|27|37|9|64|16|56|14|56|
|**193**|17|46|22|31|0|0|20|33|**224**|21|60|−1|94|11|73|15|57|
|**194**|0|89|−1|84|27|36|8|63|**225**|12|68|−2|89|10|67|26|38|
|**195**|26|−19|25|7|33|−25|35|−18|**226**|2|97|−9|108|−10|116|−24|127|
|**196**|22|−17|30|−7|34|−30|33|−25||||||||||





**Table 9-21 – Values of variables m and n for ctxIdx from 227 to 275**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**227**|−3|71|−6|76|−23|112|−24|115|**252**|−12|73|−6|55|−16|72|−14|75|
|**228**|−6|42|−2|44|−15|71|−22|82|**253**|−8|76|0|58|−7|69|−10|79|
|**229**|−5|50|0|45|−7|61|−9|62|**254**|−7|80|0|64|−4|69|−9|83|
|**230**|−3|54|0|52|0|53|0|53|**255**|−9|88|−3|74|−5|74|−12|92|
|**231**|−2|62|−3|64|−5|66|0|59|**256**|−17|110|−10|90|−9|86|−18|108|
|**232**|0|58|−2|59|−11|77|−14|85|**257**|−11|97|0|70|2|66|−4|79|
|**233**|1|63|−4|70|−9|80|−13|89|**258**|−20|84|−4|29|−9|34|−22|69|
|**234**|−2|72|−4|75|−9|84|−13|94|**259**|−11|79|5|31|1|32|−16|75|
|**235**|−1|74|−8|82|−10|87|−11|92|**260**|−6|73|7|42|11|31|−2|58|
|**236**|−9|91|−17|102|−34|127|−29|127|**261**|−4|74|1|59|5|52|1|58|
|**237**|−5|67|−9|77|−21|101|−21|100|**262**|−13|86|−2|58|−2|55|−13|78|
|**238**|−5|27|3|24|−3|39|−14|57|**263**|−13|96|−3|72|−2|67|−9|83|
|**239**|−3|39|0|42|−5|53|−12|67|**264**|−11|97|−3|81|0|73|−4|81|
|**240**|−2|44|0|48|−7|61|−11|71|**265**|−19|117|−11|97|−8|89|−13|99|
|**241**|0|46|0|55|−11|75|−10|77|**266**|−8|78|0|58|3|52|−13|81|
|**242**|−16|64|−6|59|−15|77|−21|85|**267**|−5|33|8|5|7|4|−6|38|
|**243**|−8|68|−7|71|−17|91|−16|88|**268**|−4|48|10|14|10|8|−13|62|
|**244**|−10|78|−12|83|−25|107|−23|104|**269**|−2|53|14|18|17|8|−6|58|
|**245**|−6|77|−11|87|−25|111|−15|98|**270**|−3|62|13|27|16|19|−2|59|
|**246**|−10|86|−30|119|−28|122|−37|127|**271**|−13|71|2|40|3|37|−16|73|
|**247**|−12|92|1|58|−11|76|−10|82|**272**|−10|79|0|58|−1|61|−10|76|
|**248**|−15|55|−3|29|−10|44|−8|48|**273**|−12|86|−3|70|−5|73|−13|86|
|**249**|−10|60|−1|36|−10|52|−8|61|**274**|−13|90|−6|79|−1|70|−9|83|
|**250**|−6|62|1|38|−10|57|−8|66|**275**|−14|97|−8|85|−4|78|−10|87|
|**251**|−4|65|2|43|−9|58|−7|70||||||||||





**Table 9-22 – Values of variables m and n for ctxIdx from 277 to 337**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**277**|−6|93|−13|106|−21|126|−22|127|**308**|−16|96|−1|51|−16|77|−10|67|
|**278**|−6|84|−16|106|−23|124|−25|127|**309**|−7|88|7|49|−2|64|1|68|
|**279**|−8|79|−10|87|−20|110|−25|120|**310**|−8|85|8|52|2|61|0|77|
|**280**|0|66|−21|114|−26|126|−27|127|**311**|−7|85|9|41|−6|67|2|64|
|**281**|−1|71|−18|110|−25|124|−19|114|**312**|−9|85|6|47|−3|64|0|68|
|**282**|0|62|−14|98|−17|105|−23|117|**313**|−13|88|2|55|2|57|−5|78|
|**283**|−2|60|−22|110|−27|121|−25|118|**314**|4|66|13|41|−3|65|7|55|
|**284**|−2|59|−21|106|−27|117|−26|117|**315**|−3|77|10|44|−3|66|5|59|
|**285**|−5|75|−18|103|−17|102|−24|113|**316**|−3|76|6|50|0|62|2|65|
|**286**|−3|62|−21|107|−26|117|−28|118|**317**|−6|76|5|53|9|51|14|54|
|**287**|−4|58|−23|108|−27|116|−31|120|**318**|10|58|13|49|−1|66|15|44|
|**288**|−9|66|−26|112|−33|122|−37|124|**319**|−1|76|4|63|−2|71|5|60|
|**289**|−1|79|−10|96|−10|95|−10|94|**320**|−1|83|6|64|−2|75|2|70|
|**290**|0|71|−12|95|−14|100|−15|102|**321**|−7|99|−2|69|−1|70|−2|76|
|**291**|3|68|−5|91|−8|95|−10|99|**322**|−14|95|−2|59|−9|72|−18|86|
|**292**|10|44|−9|93|−17|111|−13|106|**323**|2|95|6|70|14|60|12|70|
|**293**|−7|62|−22|94|−28|114|−50|127|**324**|0|76|10|44|16|37|5|64|
|**294**|15|36|−5|86|−6|89|−5|92|**325**|−5|74|9|31|0|47|−12|70|
|**295**|14|40|9|67|−2|80|17|57|**326**|0|70|12|43|18|35|11|55|
|**296**|16|27|−4|80|−4|82|−5|86|**327**|−11|75|3|53|11|37|5|56|
|**297**|12|29|−10|85|−9|85|−13|94|**328**|1|68|14|34|12|41|0|69|
|**298**|1|44|−1|70|−8|81|−12|91|**329**|0|65|10|38|10|41|2|65|
|**299**|20|36|7|60|−1|72|−2|77|**330**|−14|73|−3|52|2|48|−6|74|
|**300**|18|32|9|58|5|64|0|71|**331**|3|62|13|40|12|41|5|54|
|**301**|5|42|5|61|1|67|−1|73|**332**|4|62|17|32|13|41|7|54|
|**302**|1|48|12|50|9|56|4|64|**333**|−1|68|7|44|0|59|−6|76|
|**303**|10|62|15|50|0|69|−7|81|**334**|−13|75|7|38|3|50|−11|82|
|**304**|17|46|18|49|1|69|5|64|**335**|11|55|13|50|19|40|−2|77|
|**305**|9|64|17|54|7|69|15|57|**336**|5|64|10|57|3|66|−2|77|
|**306**|−12|104|10|41|−7|69|1|67|**337**|12|70|26|43|18|50|25|42|
|**307**|−11|97|7|46|−6|67|0|68||||||||||





**Table 9-23 – Values of variables m and n for ctxIdx from 338 to 398**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**338**|15|6|14|11|19|−6|17|−13|**369**|32|−26|31|−4|40|−37|37|−17|
|**339**|6|19|11|14|18|−6|16|−9|**370**|37|−30|27|6|38|−30|32|1|
|**340**|7|16|9|11|14|0|17|−12|**371**|44|−32|34|8|46|−33|34|15|
|**341**|12|14|18|11|26|−12|27|−21|**372**|34|−18|30|10|42|−30|29|15|
|**342**|18|13|21|9|31|−16|37|−30|**373**|34|−15|24|22|40|−24|24|25|
|**343**|13|11|23|−2|33|−25|41|−40|**374**|40|−15|33|19|49|−29|34|22|
|**344**|13|15|32|−15|33|−22|42|−41|**375**|33|−7|22|32|38|−12|31|16|
|**345**|15|16|32|−15|37|−28|48|−47|**376**|35|−5|26|31|40|−10|35|18|
|**346**|12|23|34|−21|39|−30|39|−32|**377**|33|0|21|41|38|−3|31|28|
|**347**|13|23|39|−23|42|−30|46|−40|**378**|38|2|26|44|46|−5|33|41|
|**348**|15|20|42|−33|47|−42|52|−51|**379**|33|13|23|47|31|20|36|28|
|**349**|14|26|41|−31|45|−36|46|−41|**380**|23|35|16|65|29|30|27|47|
|**350**|14|44|46|−28|49|−34|52|−39|**381**|13|58|14|71|25|44|21|62|
|**351**|17|40|38|−12|41|−17|43|−19|**382**|29|−3|8|60|12|48|18|31|
|**352**|17|47|21|29|32|9|32|11|**383**|26|0|6|63|11|49|19|26|
|**353**|24|17|45|−24|69|−71|61|−55|**384**|22|30|17|65|26|45|36|24|
|**354**|21|21|53|−45|63|−63|56|−46|**385**|31|−7|21|24|22|22|24|23|
|**355**|25|22|48|−26|66|−64|62|−50|**386**|35|−15|23|20|23|22|27|16|
|**356**|31|27|65|−43|77|−74|81|−67|**387**|34|−3|26|23|27|21|24|30|
|**357**|22|29|43|−19|54|−39|45|−20|**388**|34|3|27|32|33|20|31|29|
|**358**|19|35|39|−10|52|−35|35|−2|**389**|36|−1|28|23|26|28|22|41|
|**359**|14|50|30|9|41|−10|28|15|**390**|34|5|28|24|30|24|22|42|
|**360**|10|57|18|26|36|0|34|1|**391**|32|11|23|40|27|34|16|60|
|**361**|7|63|20|27|40|−1|39|1|**392**|35|5|24|32|18|42|15|52|
|**362**|−2|77|0|57|30|14|30|17|**393**|34|12|28|29|25|39|14|60|
|**363**|−4|82|−14|82|28|26|20|38|**394**|39|11|23|42|18|50|3|78|
|**364**|−3|94|−5|75|23|37|18|45|**395**|30|29|19|57|12|70|−16|123|
|**365**|9|69|−19|97|12|55|15|54|**396**|34|26|22|53|21|54|21|53|
|**366**|−12|109|−35|125|11|65|0|79|**397**|29|39|22|61|14|71|22|56|
|**367**|36|−35|27|0|37|−33|36|−16|**398**|19|66|11|86|11|83|25|61|
|**368**|36|−34|28|0|39|−36|37|−14||||||||||





**Table 9-24 – Values of variables m and n for ctxIdx from 402 to 459**

















|ctxIdx|I<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I**<br>**slices**|**I**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**402**|−17|120|−4|79|−5|85|−3|78|**431**|−2|55|−12|56|−9|57|−12|59|
|**403**|−20|112|−7|71|−6|81|−8|74|**432**|0|61|−6|60|−6|63|−8|63|
|**404**|−18|114|−5|69|−10|77|−9|72|**433**|1|64|−5|62|−4|65|−9|67|
|**405**|−11|85|−9|70|−7|81|−10|72|**434**|0|68|−8|66|−4|67|−6|68|
|**406**|−15|92|−8|66|−17|80|−18|75|**435**|−9|92|−8|76|−7|82|−10|79|
|**407**|−14|89|−10|68|−18|73|−12|71|**436**|−14|106|−5|85|−3|81|−3|78|
|**408**|−26|71|−19|73|−4|74|−11|63|**437**|−13|97|−6|81|−3|76|−8|74|
|**409**|−15|81|−12|69|−10|83|−5|70|**438**|−15|90|−10|77|−7|72|−9|72|
|**410**|−14|80|−16|70|−9|71|−17|75|**439**|−12|90|−7|81|−6|78|−10|72|
|**411**|0|68|−15|67|−9|67|−14|72|**440**|−18|88|−17|80|−12|72|−18|75|
|**412**|−14|70|−20|62|−1|61|−16|67|**441**|−10|73|−18|73|−14|68|−12|71|
|**413**|−24|56|−19|70|−8|66|−8|53|**442**|−9|79|−4|74|−3|70|−11|63|
|**414**|−23|68|−16|66|−14|66|−14|59|**443**|−14|86|−10|83|−6|76|−5|70|
|**415**|−24|50|−22|65|0|59|−9|52|**444**|−10|73|−9|71|−5|66|−17|75|
|**416**|−11|74|−20|63|2|59|−11|68|**445**|−10|70|−9|67|−5|62|−14|72|
|**417**|23|−13|9|−2|17|−10|9|−2|**446**|−10|69|−1|61|0|57|−16|67|
|**418**|26|−13|26|−9|32|−13|30|−10|**447**|−5|66|−8|66|−4|61|−8|53|
|**419**|40|−15|33|−9|42|−9|31|−4|**448**|−9|64|−14|66|−9|60|−14|59|
|**420**|49|−14|39|−7|49|−5|33|−1|**449**|−5|58|0|59|1|54|−9|52|
|**421**|44|3|41|−2|53|0|33|7|**450**|2|59|2|59|2|58|−11|68|
|**422**|45|6|45|3|64|3|31|12|**451**|21|−10|21|−13|17|−10|9|−2|
|**423**|44|34|49|9|68|10|37|23|**452**|24|−11|33|−14|32|−13|30|−10|
|**424**|33|54|45|27|66|27|31|38|**453**|28|−8|39|−7|42|−9|31|−4|
|**425**|19|82|36|59|47|57|20|64|**454**|28|−1|46|−2|49|−5|33|−1|
|**426**|−3|75|−6|66|−5|71|−9|71|**455**|29|3|51|2|53|0|33|7|
|**427**|−1|23|−7|35|0|24|−7|37|**456**|29|9|60|6|64|3|31|12|
|**428**|1|34|−7|42|−1|36|−8|44|**457**|35|20|61|17|68|10|37|23|
|**429**|1|43|−8|45|−2|42|−11|49|**458**|29|36|55|34|66|27|31|38|
|**430**|0|54|−5|48|−2|52|−10|56|**459**|14|67|42|62|47|57|20|64|





**Table 9-25 – Values of variables m and n for ctxIdx from 460 to 483**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**460**|−17|123|−7|92|0|80|11|80|**472**|−17|123|−7|92|0|80|11|80|
|**461**|−12|115|−5|89|−5|89|5|76|**473**|−12|115|−5|89|−5|89|5|76|
|**462**|−16|122|−7|96|−7|94|2|84|**474**|−16|122|−7|96|−7|94|2|84|
|**463**|−11|115|−13|108|−4|92|5|78|**475**|−11|115|−13|108|−4|92|5|78|
|**464**|−12|63|−3|46|0|39|−6|55|**476**|−12|63|−3|46|0|39|−6|55|
|**465**|−2|68|−1|65|0|65|4|61|**477**|−2|68|−1|65|0|65|4|61|
|**466**|−15|84|−1|57|−15|84|−14|83|**478**|−15|84|−1|57|−15|84|−14|83|
|**467**|−13|104|−9|93|−35|127|−37|127|**479**|−13|104|−9|93|−35|127|−37|127|
|**468**|−3|70|−3|74|−2|73|−5|79|**480**|−3|70|−3|74|−2|73|−5|79|
|**469**|−8|93|−9|92|−12|104|−11|104|**481**|−8|93|−9|92|−12|104|−11|104|
|**470**|−10|90|−8|87|−9|91|−11|91|**482**|−10|90|−8|87|−9|91|−11|91|
|**471**|−30|127|−23|126|−31|127|−30|127|**483**|−30|127|−23|126|−31|127|−30|127|


**Table 9-26 – Values of variables m and n for ctxIdx from 484 to 571**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**484**|−7|93|−2|85|−13|103|−4|86|**528**|−7|93|−2|85|−13|103|−4|86|
|**485**|−11|87|−6|78|−13|91|−12|88|**529**|−11|87|−6|78|−13|91|−12|88|
|**486**|−3|77|−1|75|−9|89|−5|82|**530**|−3|77|−1|75|−9|89|−5|82|
|**487**|−5|71|−7|77|−14|92|−3|72|**531**|−5|71|−7|77|−14|92|−3|72|
|**488**|−4|63|2|54|−8|76|−4|67|**532**|−4|63|2|54|−8|76|−4|67|
|**489**|−4|68|5|50|−12|87|−8|72|**533**|−4|68|5|50|−12|87|−8|72|
|**490**|−12|84|−3|68|−23|110|−16|89|**534**|−12|84|−3|68|−23|110|−16|89|
|**491**|−7|62|1|50|−24|105|−9|69|**535**|−7|62|1|50|−24|105|−9|69|
|**492**|−7|65|6|42|−10|78|−1|59|**536**|−7|65|6|42|−10|78|−1|59|
|**493**|8|61|−4|81|−20|112|5|66|**537**|8|61|−4|81|−20|112|5|66|
|**494**|5|56|1|63|−17|99|4|57|**538**|5|56|1|63|−17|99|4|57|
|**495**|−2|66|−4|70|−78|127|−4|71|**539**|−2|66|−4|70|−78|127|−4|71|
|**496**|1|64|0|67|−70|127|−2|71|**540**|1|64|0|67|−70|127|−2|71|
|**497**|0|61|2|57|−50|127|2|58|**641**|0|61|2|57|−50|127|2|58|
|**498**|−2|78|−2|76|−46|127|−1|74|**542**|−2|78|−2|76|−46|127|−1|74|





**Table 9-26 – Values of variables m and n for ctxIdx from 484 to 571**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**499**|1|50|11|35|−4|66|−4|44|**543**|1|50|11|35|−4|66|−4|44|
|**500**|7|52|4|64|−5|78|−1|69|**544**|7|52|4|64|−5|78|−1|69|
|**501**|10|35|1|61|−4|71|0|62|**545**|10|35|1|61|−4|71|0|62|
|**502**|0|44|11|35|−8|72|−7|51|**546**|0|44|11|35|−8|72|−7|51|
|**503**|11|38|18|25|2|59|−4|47|**547**|11|38|18|25|2|59|−4|47|
|**504**|1|45|12|24|−1|55|−6|42|**548**|1|45|12|24|−1|55|−6|42|
|**505**|0|46|13|29|−7|70|−3|41|**549**|0|46|13|29|−7|70|−3|41|
|**506**|5|44|13|36|−6|75|−6|53|**550**|5|44|13|36|−6|75|−6|53|
|**507**|31|17|−10|93|−8|89|8|76|**551**|31|17|−10|93|−8|89|8|76|
|**508**|1|51|−7|73|−34|119|−9|78|**552**|1|51|−7|73|−34|119|−9|78|
|**509**|7|50|−2|73|−3|75|−11|83|**553**|7|50|−2|73|−3|75|−11|83|
|**510**|28|19|13|46|32|20|9|52|**554**|28|19|13|46|32|20|9|52|
|**511**|16|33|9|49|30|22|0|67|**555**|16|33|9|49|30|22|0|67|
|**512**|14|62|−7|100|−44|127|−5|90|**556**|14|62|−7|100|−44|127|−5|90|
|**513**|−13|108|9|53|0|54|1|67|**557**|−13|108|9|53|0|54|1|67|
|**514**|−15|100|2|53|−5|61|−15|72|**558**|−15|100|2|53|−5|61|−15|72|
|**515**|−13|101|5|53|0|58|−5|75|**559**|−13|101|5|53|0|58|−5|75|
|**516**|−13|91|−2|61|−1|60|−8|80|**560**|−13|91|−2|61|−1|60|−8|80|
|**517**|−12|94|0|56|−3|61|−21|83|**561**|−12|94|0|56|−3|61|−21|83|
|**518**|−10|88|0|56|−8|67|−21|64|**562**|−10|88|0|56|−8|67|−21|64|
|**519**|−16|84|−13|63|−25|84|−13|31|**563**|−16|84|−13|63|−25|84|−13|31|
|**520**|−10|86|−5|60|−14|74|−25|64|**564**|−10|86|−5|60|−14|74|−25|64|
|**521**|−7|83|−1|62|−5|65|−29|94|**565**|−7|83|−1|62|−5|65|−29|94|
|**522**|−13|87|4|57|5|52|9|75|**566**|−13|87|4|57|5|52|9|75|
|**523**|−19|94|−6|69|2|57|17|63|**567**|−19|94|−6|69|2|57|17|63|
|**524**|1|70|4|57|0|61|−8|74|**568**|1|70|4|57|0|61|−8|74|
|**525**|0|72|14|39|−9|69|−5|35|**569**|0|72|14|39|−9|69|−5|35|
|**526**|−5|74|4|51|−11|70|−2|27|**570**|−5|74|4|51|−11|70|−2|27|
|**527**|18|59|13|68|18|55|13|91|**571**|18|59|13|68|18|55|13|91|





**Table 9-27 – Values of variables m and n for ctxIdx from 572 to 659**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**572**|24|0|11|28|4|45|4|39|**616**|24|0|11|28|4|45|4|39|
|**573**|15|9|2|40|10|28|0|42|**617**|15|9|2|40|10|28|0|42|
|**574**|8|25|3|44|10|31|7|34|**618**|8|25|3|44|10|31|7|34|
|**575**|13|18|0|49|33|−11|11|29|**619**|13|18|0|49|33|−11|11|29|
|**576**|15|9|0|46|52|−43|8|31|**620**|15|9|0|46|52|−43|8|31|
|**577**|13|19|2|44|18|15|6|37|**621**|13|19|2|44|18|15|6|37|
|**578**|10|37|2|51|28|0|7|42|**622**|10|37|2|51|28|0|7|42|
|**579**|12|18|0|47|35|−22|3|40|**623**|12|18|0|47|35|−22|3|40|
|**580**|6|29|4|39|38|−25|8|33|**624**|6|29|4|39|38|−25|8|33|
|**581**|20|33|2|62|34|0|13|43|**625**|20|33|2|62|34|0|13|43|
|**582**|15|30|6|46|39|−18|13|36|**626**|15|30|6|46|39|−18|13|36|
|**583**|4|45|0|54|32|−12|4|47|**627**|4|45|0|54|32|−12|4|47|
|**584**|1|58|3|54|102|−94|3|55|**628**|1|58|3|54|102|−94|3|55|
|**585**|0|62|2|58|0|0|2|58|**629**|0|62|2|58|0|0|2|58|
|**586**|7|61|4|63|56|−15|6|60|**630**|7|61|4|63|56|−15|6|60|
|**587**|12|38|6|51|33|−4|8|44|**631**|12|38|6|51|33|−4|8|44|
|**588**|11|45|6|57|29|10|11|44|**632**|11|45|6|57|29|10|11|44|
|**589**|15|39|7|53|37|−5|14|42|**633**|15|39|7|53|37|−5|14|42|
|**590**|11|42|6|52|51|−29|7|48|**634**|11|42|6|52|51|−29|7|48|
|**591**|13|44|6|55|39|−9|4|56|**635**|13|44|6|55|39|−9|4|56|
|**592**|16|45|11|45|52|−34|4|52|**636**|16|45|11|45|52|−34|4|52|
|**593**|12|41|14|36|69|−58|13|37|**637**|12|41|14|36|69|−58|13|37|
|**594**|10|49|8|53|67|−63|9|49|**638**|10|49|8|53|67|−63|9|49|
|**595**|30|34|−1|82|44|−5|19|58|**639**|30|34|−1|82|44|−5|19|58|
|**596**|18|42|7|55|32|7|10|48|**640**|18|42|7|55|32|7|10|48|
|**597**|10|55|−3|78|55|−29|12|45|**641**|10|55|−3|78|55|−29|12|45|
|**598**|17|51|15|46|32|1|0|69|**642**|17|51|15|46|32|1|0|69|
|**599**|17|46|22|31|0|0|20|33|**643**|17|46|22|31|0|0|20|33|
|**600**|0|89|−1|84|27|36|8|63|**644**|0|89|−1|84|27|36|8|63|
|**601**|26|−19|25|7|33|−25|35|−18|**645**|26|−19|25|7|33|−25|35|−18|
|**602**|22|−17|30|−7|34|−30|33|−25|**646**|22|−17|30|−7|34|−30|33|−25|





**Table 9-27 – Values of variables m and n for ctxIdx from 572 to 659**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**603**|26|−17|28|3|36|−28|28|−3|**647**|26|−17|28|3|36|−28|28|−3|
|**604**|30|−25|28|4|38|−28|24|10|**648**|30|−25|28|4|38|−28|24|10|
|**605**|28|−20|32|0|38|−27|27|0|**649**|28|−20|32|0|38|−27|27|0|
|**606**|33|−23|34|−1|34|−18|34|−14|**650**|33|−23|34|−1|34|−18|34|−14|
|**607**|37|−27|30|6|35|−16|52|−44|**651**|37|−27|30|6|35|−16|52|−44|
|**608**|33|−23|30|6|34|−14|39|−24|**652**|33|−23|30|6|34|−14|39|−24|
|**609**|40|−28|32|9|32|−8|19|17|**653**|40|−28|32|9|32|−8|19|17|
|**610**|38|−17|31|19|37|−6|31|25|**654**|38|−17|31|19|37|−6|31|25|
|**611**|33|−11|26|27|35|0|36|29|**655**|33|−11|26|27|35|0|36|29|
|**612**|40|−15|26|30|30|10|24|33|**656**|40|−15|26|30|30|10|24|33|
|**613**|41|−6|37|20|28|18|34|15|**657**|41|−6|37|20|28|18|34|15|
|**614**|38|1|28|34|26|25|30|20|**658**|38|1|28|34|26|25|30|20|
|**615**|41|17|17|70|29|41|22|73|**659**|41|17|17|70|29|41|22|73|





**Table 9-28 – Values of variables m and n for ctxIdx from 660 to 717**

















|ctxIdx|I<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I**<br>**slices**|**I**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**660**|−17|120|−4|79|−5|85|−3|78|**689**|2|59|2|59|2|58|−11|68|
|**661**|−20|112|−7|71|−6|81|−8|74|**690**|23|−13|9|−2|17|−10|9|−2|
|**662**|−18|114|−5|69|−10|77|−9|72|**691**|26|−13|26|−9|32|−13|30|−10|
|**663**|−11|85|−9|70|−7|81|−10|72|**692**|40|−15|33|−9|42|−9|31|−4|
|**664**|−15|92|−8|66|−17|80|−18|75|**693**|49|−14|39|−7|49|−5|33|−1|
|**665**|−14|89|−10|68|−18|73|−12|71|**694**|44|3|41|−2|53|0|33|7|
|**666**|−26|71|−19|73|−4|74|−11|63|**695**|45|6|45|3|64|3|31|12|
|**667**|−15|81|−12|69|−10|83|−5|70|**696**|44|34|49|9|68|10|37|23|
|**668**|−14|80|−16|70|−9|71|−17|75|**697**|33|54|45|27|66|27|31|38|
|**669**|0|68|−15|67|−9|67|−14|72|**698**|19|82|36|59|47|57|20|64|
|**670**|−14|70|−20|62|−1|61|−16|67|**699**|21|−10|21|−13|17|−10|9|−2|
|**671**|−24|56|−19|70|−8|66|−8|53|**700**|24|−11|33|−14|32|−13|30|−10|
|**672**|−23|68|−16|66|−14|66|−14|59|**701**|28|−8|39|−7|42|−9|31|−4|
|**673**|−24|50|−22|65|0|59|−9|52|**702**|28|−1|46|−2|49|−5|33|−1|
|**674**|−11|74|−20|63|2|59|−11|68|**703**|29|3|51|2|53|0|33|7|
|**675**|−14|106|−5|85|−3|81|−3|78|**704**|29|9|60|6|64|3|31|12|
|**676**|−13|97|−6|81|−3|76|−8|74|**705**|35|20|61|17|68|10|37|23|
|**677**|−15|90|−10|77|−7|72|−9|72|**706**|29|36|55|34|66|27|31|38|
|**678**|−12|90|−7|81|−6|78|−10|72|**707**|14|67|42|62|47|57|20|64|
|**679**|−18|88|-17|80|−12|72|−18|75|**708**|−3|75|−6|66|−5|71|−9|71|
|**680**|−10|73|−18|73|−14|68|−12|71|**709**|−1|23|−7|35|0|24|−7|37|
|**681**|−9|79|−4|74|−3|70|−11|63|**710**|1|34|−7|42|−1|36|−8|44|
|**682**|−14|86|−10|83|−6|76|−5|70|**711**|1|43|−8|45|−2|42|−11|49|
|**683**|−10|73|−9|71|−5|66|−17|75|**712**|0|54|−5|48|−2|52|−10|56|
|**684**|−10|70|−9|67|−5|62|−14|72|**713**|−2|55|−12|56|−9|57|−12|59|
|**685**|−10|69|−1|61|0|57|−16|67|**714**|0|61|−6|60|−6|63|−8|63|
|**686**|−5|66|−8|66|−4|61|−8|53|**715**|1|64|−5|62|−4|65|−9|67|
|**687**|−9|64|−14|66|−9|60|−14|59|**716**|0|68|−8|66|−4|67|−6|68|
|**688**|−5|58|0|59|1|54|−9|52|**717**|−9|92|−8|76|−7|82|−10|79|





**Table 9-29 – Values of variables m and n for ctxIdx from 718 to 775**

















|ctxIdx|I<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I**<br>**slices**|**I**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**718**|−17|120|−4|79|−5|85|−3|78|**747**|2|59|2|59|2|58|−11|68|
|**719**|−20|112|−7|71|−6|81|−8|74|**748**|23|−13|9|−2|17|−10|9|−2|
|**720**|−18|114|−5|69|−10|77|−9|72|**749**|26|−13|26|−9|32|−13|30|−10|
|**721**|−11|85|−9|70|−7|81|−10|72|**750**|40|−15|33|−9|42|−9|31|−4|
|**722**|−15|92|−8|66|−17|80|−18|75|**751**|49|−14|39|−7|49|−5|33|−1|
|**723**|−14|89|−10|68|−18|73|−12|71|**752**|44|3|41|−2|53|0|33|7|
|**724**|−26|71|−19|73|−4|74|−11|63|**753**|45|6|45|3|64|3|31|12|
|**725**|−15|81|−12|69|−10|83|−5|70|**754**|44|34|49|9|68|10|37|23|
|**726**|−14|80|−16|70|−9|71|−17|75|**755**|33|54|45|27|66|27|31|38|
|**727**|0|68|−15|67|−9|67|−14|72|**756**|19|82|36|59|47|57|20|64|
|**728**|−14|70|−20|62|−1|61|−16|67|**757**|21|−10|21|−13|17|−10|9|−2|
|**729**|−24|56|−19|70|−8|66|−8|53|**758**|24|−11|33|−14|32|−13|30|−10|
|**730**|−23|68|−16|66|−14|66|−14|59|**759**|28|−8|39|−7|42|−9|31|−4|
|**731**|−24|50|−22|65|0|59|−9|52|**760**|28|−1|46|−2|49|−5|33|−1|
|**732**|−11|74|−20|63|2|59|−11|68|**761**|29|3|51|2|53|0|33|7|
|**733**|−14|106|−5|85|−3|81|−3|78|**762**|29|9|60|6|64|3|31|12|
|**734**|−13|97|−6|81|−3|76|−8|74|**763**|35|20|61|17|68|10|37|23|
|**735**|−15|90|−10|77|−7|72|−9|72|**764**|29|36|55|34|66|27|31|38|
|**736**|−12|90|−7|81|−6|78|−10|72|**765**|14|67|42|62|47|57|20|64|
|**737**|−18|88|−17|80|−12|72|−18|75|**766**|−3|75|−6|66|−5|71|−9|71|
|**738**|−10|73|−18|73|−14|68|−12|71|**767**|−1|23|−7|35|0|24|−7|37|
|**739**|−9|79|−4|74|−3|70|−11|63|**768**|1|34|−7|42|−1|36|−8|44|
|**740**|−14|86|−10|83|−6|76|−5|70|**769**|1|43|−8|45|−2|42|−11|49|
|**741**|−10|73|−9|71|−5|66|−17|75|**770**|0|54|−5|48|−2|52|−10|56|
|**742**|−10|70|−9|67|−5|62|−14|72|**771**|−2|55|−12|56|−9|57|−12|59|
|**743**|−10|69|−1|61|0|57|−16|67|**772**|0|61|−6|60|−6|63|−8|63|
|**744**|−5|66|−8|66|−4|61|−8|53|**773**|1|64|−5|62|−4|65|−9|67|
|**745**|−9|64|−14|66|−9|60|−14|59|**774**|0|68|−8|66|−4|67|−6|68|
|**746**|−5|58|0|59|1|54|−9|52|**775**|−9|92|−8|76|−7|82|−10|79|





**Table 9-30 – Values of variables m and n for ctxIdx from 776 to 863**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**776**|−6|93|−13|106|−21|126|−22|127|**820**|−6|93|−13|106|−21|126|−22|127|
|**777**|−6|84|−16|106|−23|124|−25|127|**821**|−6|84|−16|106|−23|124|−25|127|
|**778**|−8|79|−10|87|−20|110|−25|120|**822**|−8|79|−10|87|−20|110|−25|120|
|**779**|0|66|−21|114|−26|126|−27|127|**823**|0|66|−21|114|−26|126|−27|127|
|**780**|−1|71|−18|110|−25|124|−19|114|**824**|−1|71|−18|110|−25|124|−19|114|
|**781**|0|62|−14|98|−17|105|−23|117|**825**|0|62|−14|98|−17|105|−23|117|
|**782**|−2|60|−22|110|−27|121|−25|118|**826**|−2|60|−22|110|−27|121|−25|118|
|**783**|−2|59|−21|106|−27|117|−26|117|**827**|−2|59|−21|106|−27|117|−26|117|
|**784**|−5|75|−18|103|−17|102|−24|113|**828**|−5|75|−18|103|−17|102|−24|113|
|**785**|−3|62|−21|107|−26|117|−28|118|**829**|−3|62|−21|107|−26|117|−28|118|
|**786**|−4|58|−23|108|−27|116|−31|120|**830**|−4|58|−23|108|−27|116|−31|120|
|**787**|−9|66|−26|112|−33|122|−37|124|**831**|−9|66|−26|112|−33|122|−37|124|
|**788**|−1|79|−10|96|−10|95|−10|94|**832**|−1|79|−10|96|−10|95|−10|94|
|**789**|0|71|−12|95|−14|100|−15|102|**833**|0|71|−12|95|−14|100|−15|102|
|**790**|3|68|−5|91|−8|95|−10|99|**834**|3|68|−5|91|−8|95|−10|99|
|**791**|10|44|−9|93|−17|111|−13|106|**835**|10|44|−9|93|−17|111|−13|106|
|**792**|−7|62|−22|94|−28|114|−50|127|**836**|−7|62|−22|94|−28|114|−50|127|
|**793**|15|36|−5|86|−6|89|−5|92|**837**|15|36|−5|86|−6|89|−5|92|
|**794**|14|40|9|67|−2|80|17|57|**838**|14|40|9|67|−2|80|17|57|
|**795**|16|27|−4|80|−4|82|−5|86|**839**|16|27|−4|80|−4|82|−5|86|
|**796**|12|29|−10|85|−9|85|−13|94|**840**|12|29|−10|85|−9|85|−13|94|
|**797**|1|44|−1|70|−8|81|−12|91|**841**|1|44|−1|70|−8|81|−12|91|
|**798**|20|36|7|60|−1|72|−2|77|**842**|20|36|7|60|−1|72|−2|77|
|**799**|18|32|9|58|5|64|0|71|**843**|18|32|9|58|5|64|0|71|
|**800**|5|42|5|61|1|67|−1|73|**844**|5|42|5|61|1|67|−1|73|
|**801**|1|48|12|50|9|56|4|64|**845**|1|48|12|50|9|56|4|64|
|**802**|10|62|15|50|0|69|−7|81|**846**|10|62|15|50|0|69|−7|81|
|**803**|17|46|18|49|1|69|5|64|**847**|17|46|18|49|1|69|5|64|
|**804**|9|64|17|54|7|69|15|57|**848**|9|64|17|54|7|69|15|57|
|**805**|−12|104|10|41|−7|69|1|67|**849**|−12|104|10|41|−7|69|1|67|
|**806**|−11|97|7|46|−6|67|0|68|**850**|−11|97|7|46|−6|67|0|68|





**Table 9-30 – Values of variables m and n for ctxIdx from 776 to 863**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**807**|−16|96|−1|51|−16|77|−10|67|**851**|−16|96|−1|51|−16|77|−10|67|
|**808**|−7|88|7|49|−2|64|1|68|**852**|−7|88|7|49|−2|64|1|68|
|**809**|−8|85|8|52|2|61|0|77|**853**|−8|85|8|52|2|61|0|77|
|**810**|−7|85|9|41|−6|67|2|64|**854**|−7|85|9|41|−6|67|2|64|
|**811**|−9|85|6|47|−3|64|0|68|**855**|−9|85|6|47|−3|64|0|68|
|**812**|−13|88|2|55|2|57|−5|78|**856**|−13|88|2|55|2|57|−5|78|
|**813**|4|66|13|41|−3|65|7|55|**857**|4|66|13|41|−3|65|7|55|
|**814**|−3|77|10|44|−3|66|5|59|**858**|−3|77|10|44|−3|66|5|59|
|**815**|−3|76|6|50|0|62|2|65|**859**|−3|76|6|50|0|62|2|65|
|**816**|−6|76|5|53|9|51|14|54|**860**|−6|76|5|53|9|51|14|54|
|**817**|10|58|13|49|−1|66|15|44|**861**|10|58|13|49|−1|66|15|44|
|**818**|−1|76|4|63|−2|71|5|60|**862**|−1|76|4|63|−2|71|5|60|
|**819**|−1|83|6|64|−2|75|2|70|**863**|−1|83|6|64|−2|75|2|70|





**Table 9-31 – Values of variables m and n for ctxIdx from 864 to 951**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**864**|15|6|14|11|19|−6|17|−13|**908**|15|6|14|11|19|−6|17|−13|
|**865**|6|19|11|14|18|−6|16|−9|**909**|6|19|11|14|18|−6|16|−9|
|**866**|7|16|9|11|14|0|17|−12|**910**|7|16|9|11|14|0|17|−12|
|**867**|12|14|18|11|26|−12|27|−21|**911**|12|14|18|11|26|−12|27|−21|
|**868**|18|13|21|9|31|−16|37|−30|**912**|18|13|21|9|31|−16|37|−30|
|**869**|13|11|23|−2|33|−25|41|−40|**913**|13|11|23|−2|33|−25|41|−40|
|**870**|13|15|32|−15|33|−22|42|−41|**914**|13|15|32|−15|33|−22|42|−41|
|**871**|15|16|32|−15|37|−28|48|−47|**915**|15|16|32|−15|37|−28|48|−47|
|**872**|12|23|34|−21|39|−30|39|−32|**916**|12|23|34|−21|39|−30|39|−32|
|**873**|13|23|39|−23|42|−30|46|−40|**917**|13|23|39|−23|42|−30|46|−40|
|**874**|15|20|42|−33|47|−42|52|−51|**918**|15|20|42|−33|47|−42|52|−51|
|**875**|14|26|41|−31|45|−36|46|−41|**919**|14|26|41|−31|45|−36|46|−41|
|**876**|14|44|46|−28|49|−34|52|−39|**920**|14|44|46|−28|49|−34|52|−39|
|**877**|17|40|38|−12|41|−17|43|−19|**921**|17|40|38|−12|41|−17|43|−19|
|**878**|17|47|21|29|32|9|32|11|**922**|17|47|21|29|32|9|32|11|
|**879**|24|17|45|−24|69|−71|61|−55|**923**|24|17|45|−24|69|−71|61|−55|
|**880**|21|21|53|−45|63|−63|56|−46|**924**|21|21|53|−45|63|−63|56|−46|
|**881**|25|22|48|−26|66|−64|62|−50|**925**|25|22|48|−26|66|−64|62|−50|
|**882**|31|27|65|−43|77|−74|81|−67|**926**|31|27|65|−43|77|−74|81|−67|
|**883**|22|29|43|−19|54|−39|45|−20|**927**|22|29|43|−19|54|−39|45|−20|
|**884**|19|35|39|−10|52|−35|35|−2|**928**|19|35|39|−10|52|−35|35|−2|
|**885**|14|50|30|9|41|−10|28|15|**929**|14|50|30|9|41|−10|28|15|
|**886**|10|57|18|26|36|0|34|1|**930**|10|57|18|26|36|0|34|1|
|**887**|7|63|20|27|40|−1|39|1|**931**|7|63|20|27|40|−1|39|1|
|**888**|−2|77|0|57|30|14|30|17|**932**|−2|77|0|57|30|14|30|17|
|**889**|−4|82|−14|82|28|26|20|38|**933**|−4|82|−14|82|28|26|20|38|
|**890**|−3|94|−5|75|23|37|18|45|**934**|−3|94|−5|75|23|37|18|45|
|**891**|9|69|−19|97|12|55|15|54|**935**|9|69|−19|97|12|55|15|54|
|**892**|−12|109|−35|125|11|65|0|79|**936**|−12|109|−35|125|11|65|0|79|
|**893**|36|−35|27|0|37|−33|36|−16|**937**|36|−35|27|0|37|−33|36|−16|
|**894**|36|−34|28|0|39|−36|37|−14|**938**|36|−34|28|0|39|−36|37|−14|





**Table 9-31 – Values of variables m and n for ctxIdx from 864 to 951**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**895**|32|−26|31|−4|40|−37|37|−17|**939**|32|−26|31|−4|40|−37|37|−17|
|**896**|37|−30|27|6|38|−30|32|1|**940**|37|−30|27|6|38|−30|32|1|
|**897**|44|−32|34|8|46|−33|34|15|**941**|44|−32|34|8|46|−33|34|15|
|**898**|34|−18|30|10|42|−30|29|15|**942**|34|−18|30|10|42|−30|29|15|
|**899**|34|−15|24|22|40|−24|24|25|**943**|34|−15|24|22|40|−24|24|25|
|**900**|40|−15|33|19|49|−29|34|22|**944**|40|−15|33|19|49|−29|34|22|
|**901**|33|−7|22|32|38|−12|31|16|**945**|33|−7|22|32|38|−12|31|16|
|**902**|35|−5|26|31|40|−10|35|18|**946**|35|−5|26|31|40|−10|35|18|
|**903**|33|0|21|41|38|−3|31|28|**947**|33|0|21|41|38|−3|31|28|
|**904**|38|2|26|44|46|−5|33|41|**948**|38|2|26|44|46|−5|33|41|
|**905**|33|13|23|47|31|20|36|28|**949**|33|13|23|47|31|20|36|28|
|**906**|23|35|16|65|29|30|27|47|**950**|23|35|16|65|29|30|27|47|
|**907**|13|58|14|71|25|44|21|62|**951**|13|58|14|71|25|44|21|62|





**Table 9-32 – Values of variables m and n for ctxIdx from 952 to 1011**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**n **|**m **|**n **|
|**952**|−3|71|−6|76|−23|112|−24|115|**982**|−3|71|−6|76|−23|112|−24|115|
|**953**|−6|42|−2|44|−15|71|−22|82|**983**|−6|42|−2|44|−15|71|−22|82|
|**954**|−5|50|0|45|−7|61|−9|62|**984**|−5|50|0|45|−7|61|−9|62|
|**955**|−3|54|0|52|0|53|0|53|**985**|−3|54|0|52|0|53|0|53|
|**956**|−2|62|−3|64|−5|66|0|59|**986**|−2|62|−3|64|−5|66|0|59|
|**957**|0|58|−2|59|−11|77|−14|85|**987**|0|58|−2|59|−11|77|−14|85|
|**958**|1|63|−4|70|−9|80|−13|89|**988**|1|63|−4|70|−9|80|−13|89|
|**959**|−2|72|−4|75|−9|84|−13|94|**989**|−2|72|−4|75|−9|84|−13|94|
|**960**|−1|74|−8|82|−10|87|−11|92|**990**|−1|74|−8|82|−10|87|−11|92|
|**961**|−9|91|−17|102|−34|127|−29|127|**991**|−9|91|−17|102|−34|127|−29|127|
|**962**|−5|67|−9|77|−21|101|−21|100|**992**|−5|67|−9|77|−21|101|−21|100|
|**963**|−5|27|3|24|−3|39|−14|57|**993**|−5|27|3|24|−3|39|−14|57|
|**964**|−3|39|0|42|−5|53|−12|67|**994**|−3|39|0|42|−5|53|−12|67|
|**965**|−2|44|0|48|−7|61|−11|71|**995**|−2|44|0|48|−7|61|−11|71|
|**966**|0|46|0|55|−11|75|−10|77|**996**|0|46|0|55|−11|75|−10|77|
|**967**|−16|64|−6|59|−15|77|−21|85|**997**|−16|64|−6|59|−15|77|−21|85|
|**968**|−8|68|−7|71|−17|91|−16|88|**998**|−8|68|−7|71|−17|91|−16|88|
|**969**|−10|78|−12|83|−25|107|−23|104|**999**|−10|78|−12|83|−25|107|−23|104|
|**970**|−6|77|−11|87|−25|111|−15|98|**1000**|−6|77|−11|87|−25|111|−15|98|
|**971**|−10|86|−30|119|−28|122|−37|127|**1001**|−10|86|−30|119|−28|122|−37|127|
|**972**|−12|92|1|58|−11|76|−10|82|**1002**|−12|92|1|58|−11|76|−10|82|
|**973**|−15|55|−3|29|−10|44|−8|48|**1003**|−15|55|−3|29|−10|44|−8|48|
|**974**|−10|60|−1|36|−10|52|−8|61|**1004**|−10|60|−1|36|−10|52|−8|61|
|**975**|−6|62|1|38|−10|57|−8|66|**1005**|−6|62|1|38|−10|57|−8|66|
|**976**|−4|65|2|43|−9|58|−7|70|**1006**|−4|65|2|43|−9|58|−7|70|
|**977**|−12|73|−6|55|−16|72|−14|75|**1007**|−12|73|−6|55|−16|72|−14|75|
|**978**|−8|76|0|58|−7|69|−10|79|**1008**|−8|76|0|58|−7|69|−10|79|
|**979**|−7|80|0|64|−4|69|−9|83|**1009**|−7|80|0|64|−4|69|−9|83|
|**980**|−9|88|−3|74|−5|74|−12|92|**1010**|−9|88|−3|74|−5|74|−12|92|
|**981**|−17|110|−10|90|−9|86|−18|108|**1011**|−17|110|−10|90|−9|86|−18|108|





**Table 9-33 – Values of variables m and n for ctxIdx from 1012 to 1023**



















|ctxIdx|I and SI<br>slices|Col3|Value of cabac_init_idc|Col5|Col6|Col7|Col8|Col9|ctxIdx|I and SI<br>slices|Col12|Value of cabac_init_idc|Col14|Col15|Col16|Col17|Col18|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**ctxIdx**|**I and SI**<br>**slices**|**I and SI**<br>**slices**|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|**2 **|**2 **|**2 **|**0 **|**0 **|**1 **|**1 **|**2 **|**2 **|
|**ctxIdx**|**m**|**n**|**m**|**n**|**m**|**n**|**m**|**n**|**n**|**m **|**n **|**m **|**n **|**m **|**N **|**m **|**n **|
|**1012**|−3|70|−3|74|−2|73|−5|79|**1018**|−10|90|−8|87|−9|91|−11|91|
|**1013**|−8|93|−9|92|−12|104|−11|104|**1019**|−30|127|−23|126|−31|127|−30|127|
|**1014**|−10|90|−8|87|−9|91|−11|91|**1020**|−3|70|−3|74|−2|73|−5|79|
|**1015**|−30|127|−23|126|−31|127|−30|127|**1021**|−8|93|−9|92|−12|104|−11|104|
|**1016**|−3|70|−3|74|−2|73|−5|79|**1022**|−10|90|−8|87|−9|91|−11|91|
|**1017**|−8|93|−9|92|−12|104|−11|104|**1023**|−30|127|−23|126|−31|127|−30|127|


**9.3.1.2** **Initialization process for the arithmetic decoding engine**


This process is invoked before decoding the first macroblock of a slice or after the decoding of any
pcm_alignment_zero_bit and all pcm_sample_luma and pcm_sample_chroma data for a macroblock of type I_PCM.


Outputs of this process are the initialized decoding engine registers codIRange and codIOffset both in 16 bit register
precision.


The status of the arithmetic decoding engine is represented by the variables codIRange and codIOffset. In the initialization
procedure of the arithmetic decoding process, codIRange is set equal to 510 and codIOffset is set equal to the value returned
from read_bits( 9 ) interpreted as a 9 bit binary representation of an unsigned integer with most significant bit written first.


The bitstream shall not contain data that result in a value of codIOffset being equal to 510 or 511.

NOTE – The description of the arithmetic decoding engine in this Recommendation | International Standard utilizes 16 bit register
precision. However, a minimum register precision of 9 bits is required for storing the values of the variables codIRange and
codIOffset after invocation of the arithmetic decoding process (DecodeBin) as specified in clause 9.3.3.2. The arithmetic decoding
process for a binary decision (DecodeDecision) as specified in clause 9.3.3.2.1 and the decoding process for a binary decision before
termination (DecodeTerminate) as specified in clause 9.3.3.2.4 require a minimum register precision of 9 bits for the variables
codIRange and codIOffset. The bypass decoding process for binary decisions (DecodeBypass) as specified in clause 9.3.3.2.3
requires a minimum register precision of 10 bits for the variable codIOffset and a minimum register precision of 9 bits for the
variable codIRange.


**9.3.2** **Binarization process**


Input to this process is a request for a syntax element.


Output of this process is the binarization of the syntax element, maxBinIdxCtx, ctxIdxOffset, and bypassFlag.


Table 9-34 specifies the type of binarization process, maxBinIdxCtx, and ctxIdxOffset associated with each syntax
element.


The specification of the unary (U) binarization process, the truncated unary (TU) binarization process, the concatenated
unary / k-th order Exp-Golomb (UEGk) binarization process, and the fixed-length (FL) binarization process are given in
clauses 9.3.2.1 to 9.3.2.4, respectively. Other binarizations are specified in clauses 9.3.2.5 to 9.3.2.7.


Except for I slices, the binarizations for the syntax element mb_type as specified in clause 9.3.2.5 consist of bin strings
given by a concatenation of prefix and suffix bit strings. The UEGk binarization as specified in clause 9.3.2.3, which is
used for the binarization of the syntax elements mvd_lX (X = 0, 1) and coeff_abs_level_minus1, and the binarization of
the coded_block_pattern also consist of a concatenation of prefix and suffix bit strings. For these binarization processes,
the prefix and the suffix bit string are separately indexed using the binIdx variable as specified further in clause 9.3.3. The
two sets of prefix bit strings and suffix bit strings are referred to as the binarization prefix part and the binarization suffix
part, respectively.


Associated with each binarization or binarization part of a syntax element is a specific value of the context index offset
(ctxIdxOffset) variable and a specific value of the maxBinIdxCtx variable as given in Table 9-34. When two values for
each of these variables are specified for one syntax element in Table 9-34, the value in the upper row is related to the prefix
part while the value in the lower row is related to the suffix part of the binarization of the corresponding syntax element.


The use of the DecodeBypass process and the variable bypassFlag is derived as follows:





- If no value is assigned to ctxIdxOffset for the corresponding binarization or binarization part in Table 9-34 labelled
as "na", all bins of the bit strings of the corresponding binarization or of the binarization prefix/suffix part are decoded
by invoking the DecodeBypass process as specified in clause 9.3.3.2.3. In such a case, bypassFlag is set equal to 1,
where bypassFlag is used to indicate that for parsing the value of the bin from the bitstream the DecodeBypass process
is applied.


- Otherwise, for each possible value of binIdx up to the specified value of maxBinIdxCtx given in Table 9-34, a specific
value of the variable ctxIdx is further specified in clause 9.3.3. bypassFlag is set equal to 0.


The possible values of the context index ctxIdx are in the range 0 to 1023, inclusive. The value assigned to ctxIdxOffset
specifies the lower value of the range of ctxIdx assigned to the corresponding binarization or binarization part of a syntax
element.


ctxIdx = ctxIdxOffset = 276 is assigned to the syntax element end_of_slice_flag and the bin of mb_type, which specifies
the I_PCM macroblock type as further specified in clause 9.3.3.1. For parsing the value of the corresponding bin from the
bitstream, the arithmetic decoding process for decisions before termination (DecodeTerminate) as specified in
clause 9.3.3.2.4 is applied.

NOTE – The bins of mb_type in I slices and the bins of the suffix for mb_type in SI slices that correspond to the same value of
binIdx share the same ctxIdx. The last bin of the prefix of mb_type and the first bin of the suffix of mb_type in P, SP, and B slices
may share the same ctxIdx.


**Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset**







































|Syntax element|Type of binarization|maxBinIdxCtx|ctxIdxOffset|
|---|---|---|---|
|mb_type<br>(SI slices only)|prefix and suffix<br>as specified in clause9.3.2.5|prefix: 0<br>suffix: 6|prefix: 0<br>suffix: 3|
|mb_type (I slices only)|as specified in clause9.3.2.5|6|3|
|mb_skip_flag<br>(P, SP slices only)|FL, cMax=1|0|11|
|mb_type (P, SP slices only)|prefix and suffix<br>as specified in clause9.3.2.5|prefix: 2<br>suffix: 5|prefix: 14<br>suffix: 17|
|sub_mb_type[ ]<br>(P, SP slices only)|as specified in clause9.3.2.5|2|21|
|mb_skip_flag<br>(B slices only)|FL, cMax=1|0|24|
|mb_type (B slices only)|prefix and suffix<br>as specified in clause9.3.2.5|prefix: 3<br>suffix: 5|prefix: 27<br>suffix: 32|
|sub_mb_type[ ] (B slices only)|as specified in clause9.3.2.5|3|36|
|mvd_l0[ ][ ][ 0 ], mvd_l1[ ][ ][ 0 ]|prefix and suffix as given by UEG3<br>with signedValFlag=1, uCoff=9|prefix: 4<br>suffix: na|prefix: 40<br>suffix: na (uses DecodeBypass)|
|mvd_l0[ ][ ][ 1 ], mvd_l1[ ][ ][ 1 ]|mvd_l0[ ][ ][ 1 ], mvd_l1[ ][ ][ 1 ]|prefix: 4<br>suffix: na|prefix: 47<br>suffix: na (uses DecodeBypass)|
|ref_idx_l0, ref_idx_l1|U|2|54|
|mb_qp_delta|as specified in clause9.3.2.7|2|60|
|intra_chroma_pred_mode|TU, cMax=3|1|64|
|prev_intra4x4_pred_mode_flag,<br>prev_intra8x8_pred_mode_flag|FL, cMax=1|0|68|
|rem_intra4x4_pred_mode,<br>rem_intra8x8_pred_mode|FL, cMax=7|0|69|
|mb_field_decoding_flag|FL, cMax=1|0|70|





**Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset**































|Syntax element|Type of binarization|maxBinIdxCtx|ctxIdxOffset|
|---|---|---|---|
|coded_block_pattern|prefix and suffix<br>as specified in clause9.3.2.6|prefix: 3<br>suffix: 1|prefix: 73<br>suffix: 77|
|coded_block_flag<br>(blocks with ctxBlockCat < 5)|FL, cMax=1|0|85|
|significant_coeff_flag<br>(frame coded blocks with ctxBlockCat < 5)|FL, cMax=1|0|105|
|last_significant_coeff_flag<br>(frame coded blocks with ctxBlockCat < 5)|FL, cMax=1|0|166|
|coeff_abs_level_minus1<br>(blocks with ctxBlockCat < 5)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 227<br>suffix: na, (uses DecodeBypass)|
|coeff_sign_flag|FL, cMax=1|0|na, (uses DecodeBypass)|
|end_of_slice_flag|FL, cMax=1|0|276|
|significant_coeff_flag<br>(field coded blocks with ctxBlockCat < 5)|FL, cMax=1|0|277|
|last_significant_coeff_flag<br>(field coded blocks with ctxBlockCat < 5)|FL, cMax=1|0|338|
|transform_size_8x8_flag|FL, cMax=1|0|399|
|significant_coeff_flag<br>(frame coded blocks with ctxBlockCat = = 5)|FL, cMax=1|0|402|
|last_significant_coeff_flag<br>(frame coded blocks with ctxBlockCat = = 5)|FL, cMax=1|0|417|
|coeff_abs_level_minus1<br>(blocks with ctxBlockCat = = 5)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 426<br>suffix: na, (uses DecodeBypass)|
|significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 5)|FL, cMax=1|0|436|
|last_significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 5)|FL, cMax=1|0|451|
|coded_block_flag<br>(5 < ctxBlockCat < 9)|FL, cMax=1|0|460|
|coded_block_flag<br>(9 < ctxBlockCat < 13)|FL, cMax=1|0|472|
|coded_block_flag<br>(ctxBlockCat = = 5, 9, or 13)|FL, cMax=1|0|1012|
|significant_coeff_flag<br>(frame coded blocks<br>with 5 < ctxBlockCat < 9)|FL, cMax=1|0|484|
|significant_coeff_flag<br>(frame coded blocks with<br>9 < ctxBlockCat < 13)|FL, cMax=1|0|528|
|last_significant_coeff_flag<br>(frame coded blocks with<br>5 < ctxBlockCat < 9)|FL, cMax=1|0|572|







**Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset**











































|Syntax element|Type of binarization|maxBinIdxCtx|ctxIdxOffset|
|---|---|---|---|
|last_significant_coeff_flag<br>(frame coded blocks with<br>9 < ctxBlockCat < 13)|FL, cMax=1|0|616|
|coeff_abs_level_minus1<br>(blocks with 5 < ctxBlockCat < 9)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 952<br>suffix: na, (uses DecodeBypass)|
|coeff_abs_level_minus1<br>(blocks with 9 < ctxBlockCat < 13)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 982<br>suffix: na, (uses DecodeBypass)|
|significant_coeff_flag<br>(field coded blocks with 5 < ctxBlockCat < 9)|FL, cMax=1|0|776|
|significant_coeff_flag<br>(field coded blocks with<br>9 < ctxBlockCat < 13)|FL, cMax=1|0|820|
|last_significant_coeff_flag<br>(field coded blocks with 5 < ctxBlockCat < 9)|FL, cMax=1|0|864|
|last_significant_coeff_flag<br>(field coded blocks with<br>9 < ctxBlockCat < 13)|FL, cMax=1|0|908|
|significant_coeff_flag<br>(frame coded blocks with ctxBlockCat = = 9)|FL, cMax=1|0|660|
|significant_coeff_flag<br>(frame coded blocks with<br>ctxBlockCat = = 13)|FL, cMax=1|0|718|
|last_significant_coeff_flag<br>(frame coded blocks with ctxBlockCat = = 9)|FL, cMax=1|0|690|
|last_significant_coeff_flag<br>(frame coded blocks with<br>ctxBlockCat = = 13)|FL, cMax=1|0|748|
|coeff_abs_level_minus1<br>(blocks with ctxBlockCat = = 9)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 708<br>suffix: na, (uses DecodeBypass)|
|coeff_abs_level_minus1<br>(blocks with ctxBlockCat = = 13)|prefix and suffix as given by UEG0<br>with signedValFlag=0, uCoff=14|prefix: 1<br>suffix: na|prefix: 766<br>suffix: na, (uses DecodeBypass)|
|significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 9)|FL, cMax=1|0|675|
|significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 13)|FL, cMax=1|0|733|
|last_significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 9)|FL, cMax=1|0|699|
|last_significant_coeff_flag<br>(field coded blocks with ctxBlockCat = = 13)|FL, cMax=1|0|757|


**9.3.2.1** **Unary (U) binarization process**


Input to this process is a request for a U binarization for a syntax element.


Output of this process is the U binarization of the syntax element.


The bin string of a syntax element having (unsigned integer) value synElVal is a bit string of length synElVal + 1 indexed
by binIdx. The bins for binIdx less than synElVal are equal to 1. The bin with binIdx equal to synElVal is equal to 0.


Table 9-35 illustrates the bin strings of the unary binarization for a syntax element.





**Table 9-35 – Bin string of the unary binarization (informative)**

|Value of syntax element|Bin string|Col3|Col4|Col5|Col6|Col7|
|---|---|---|---|---|---|---|
|0 (I_NxN)|0||||||
|1|1|0|||||
|2|1|1|0||||
|3|1|1|1|0|||
|4|1|1|1|1|0||
|5|1|1|1|1|1|0|
|…|||||||
|binIdx|0|1|2|3|4|5|



**9.3.2.2** **Truncated unary (TU) binarization process**


Input to this process is a request for a TU binarization for a syntax element and cMax.


Output of this process is the TU binarization of the syntax element.


For syntax element (unsigned integer) values less than cMax, the U binarization process as specified in clause 9.3.2.1 is
invoked. For the syntax element value equal to cMax the bin string is a bit string of length cMax with all bins being equal
to 1.

NOTE – TU binarization is always invoked with a cMax value equal to the largest possible value of the syntax element being
decoded.


**9.3.2.3** **Concatenated unary/ k-th order Exp-Golomb (UEGk) binarization process**


Input to this process is a request for a UEGk binarization for a syntax element, signedValFlag and uCoff.


Output of this process is the UEGk binarization of the syntax element.


A UEGk bin string is a concatenation of a prefix bit string and a suffix bit string. The prefix of the binarization is specified
by invoking the TU binarization process for the prefix part Min( uCoff, Abs( synElVal ) ) of a syntax element value
synElVal as specified in clause 9.3.2.2 with cMax = uCoff, where uCoff > 0.


The variable k for a UEGk bin string is dependent on the syntax element for which a UEGk binarization is requested.
Table 9-34 specifies the associated types of binarization for syntax elements, including the value of k for syntax elements
that use UEGk binarization.

NOTE 1 – For the syntax elements mvd_l0[ ][ ][ ] and mvd_l1[ ][ ][ ] a UEG3 binarization is used (k is equal to 3). For the syntax
element coeff_abs_level_minus1 a UEG0 binarization is used (k is equal to 0).


The UEGk bin string is derived as follows:


- If one of the following is true, the bin string of a syntax element having value synElVal consists only of a prefix bit
string:


   - signedValFlag is equal to 0 and the prefix bit string is not equal to the bit string of length uCoff with all bits
equal to 1,


   - signedValFlag is equal to 1 and the prefix bit string is equal to the bit string that consists of a single bit with
value equal to 0.





- Otherwise, the bin string of the UEGk suffix part of a syntax element value synElVal is specified by a process
equivalent to the following pseudo-code with k being initialized to the value that is specified in Table 9-34 for the
requested UEGk binarization process. At the beginning of the following pseudo-code, the bin string of a syntax
element having value synElVal is set equal to the empty string. Each call of the function put( X ), with X being equal
to 0 or 1, adds the binary value X at the end of the bin string.


if( Abs( synElVal ) >= uCoff ) {
sufS = Abs( synElVal ) − uCoff
stopLoop = 0
do {
if( sufS >= ( 1 << k ) ) {
put( 1 )
sufS = sufS − ( 1<<k )
k++
} else {
put( 0 ) (9-6)
while( k− − )
put( ( sufS >> k ) & 1 )
stopLoop = 1
}
} while( !stopLoop )
}
if( signedValFlag && synElVal ! = 0)
if( synElVal > 0 )
put( 0 )
else
put( 1 )


NOTE 2 – The specification for the k-th order Exp-Golomb (EGk) code uses 1's and 0's in reverse meaning for the unary part of the
Exp-Golomb code of 0-th order as specified in clause 9.1.


**9.3.2.4** **Fixed-length (FL) binarization process**


Input to this process is a request for a FL binarization for a syntax element and cMax.


Output of this process is the FL binarization of the syntax element.


FL binarization is constructed by using a fixedLength-bit unsigned integer bin string of the syntax element value, where
fixedLength = Ceil( Log2( cMax + 1 ) ). The indexing of bins for the FL binarization is such that the binIdx = 0 relates to
the least significant bit with increasing values of binIdx towards the most significant bit.


**9.3.2.5** **Binarization process for macroblock type and sub-macroblock type**


Input to this process is a request for a binarization for syntax elements mb_type or sub_mb_type[ ].


Output of this process is the binarization of the syntax element.


The binarization scheme for decoding of macroblock type in I slices is specified in Table 9-36.


For macroblock types in SI slices, the binarization consists of bin strings specified as a concatenation of a prefix and a
suffix bit string as follows.


The prefix bit string consists of a single bit, which is specified by b0 _=_ ( ( mb_type = = SI ) ? 0 : 1 ) _._ For the syntax
element value for which b0 is equal to 0, the bin string only consists of the prefix bit string. For the syntax element value
for which b0 is equal to 1, the binarization is given by concatenating the prefix b0 and the suffix bit string as specified in
Table 9-36 for macroblock type in I slices indexed by subtracting 1 from the value of mb_type in SI slices.





**Table 9-36 – Binarization for macroblock types in I slices**

|Value (name) of mb_type|Bin string|Col3|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
|0 (I_NxN)|0|||||||
|1 (I_16x16_0_0_0)|1|0|0|0|0|0||
|2 (I_16x16_1_0_0)|1|0|0|0|0|1||
|3 (I_16x16_2_0_0)|1|0|0|0|1|0||
|4 (I_16x16_3_0_0)|1|0|0|0|1|1||
|5 (I_16x16_0_1_0)|1|0|0|1|0|0|0|
|6 (I_16x16_1_1_0)|1|0|0|1|0|0|1|
|7 (I_16x16_2_1_0)|1|0|0|1|0|1|0|
|8 (I_16x16_3_1_0)|1|0|0|1|0|1|1|
|9 (I_16x16_0_2_0)|1|0|0|1|1|0|0|
|10 (I_16x16_1_2_0)|1|0|0|1|1|0|1|
|11 (I_16x16_2_2_0)|1|0|0|1|1|1|0|
|12 (I_16x16_3_2_0)|1|0|0|1|1|1|1|
|13 (I_16x16_0_0_1)|1|0|1|0|0|0||
|14 (I_16x16_1_0_1)|1|0|1|0|0|1||
|15 (I_16x16_2_0_1)|1|0|1|0|1|0||
|16 (I_16x16_3_0_1)|1|0|1|0|1|1||
|17 (I_16x16_0_1_1)|1|0|1|1|0|0|0|
|18 (I_16x16_1_1_1)|1|0|1|1|0|0|1|
|19 (I_16x16_2_1_1)|1|0|1|1|0|1|0|
|20 (I_16x16_3_1_1)|1|0|1|1|0|1|1|
|21 (I_16x16_0_2_1)|1|0|1|1|1|0|0|
|22 (I_16x16_1_2_1)|1|0|1|1|1|0|1|
|23 (I_16x16_2_2_1)|1|0|1|1|1|1|0|
|24 (I_16x16_3_2_1)|1|0|1|1|1|1|1|
|25 (I_PCM)|1|1||||||
|binIdx|0|1|2|3|4|5|6|



The binarization schemes for P macroblock types in P and SP slices and for B macroblocks in B slices are specified in
Table 9-37.


The bin string for I macroblock types in P and SP slices corresponding to mb_type values 5 to 30 consists of a concatenation
of a prefix, which consists of a single bit with value equal to 1 as specified in Table 9-37 and a suffix as specified in
Table 9-36, indexed by subtracting 5 from the value of mb_type.


mb_type equal to 4 (P_8x8ref0) is not allowed.


For I macroblock types in B slices (mb_type values 23 to 48) the binarization consists of bin strings specified as a
concatenation of a prefix bit string as specified in Table 9-37 and suffix bit strings as specified in Table 9-36, indexed by
subtracting 23 from the value of mb_type.





**Table 9-37 – Binarization for macroblock types in P, SP, and B slices**

|Slice type|Value (name) of mb_type|Bin string|Col4|Col5|Col6|Col7|Col8|Col9|
|---|---|---|---|---|---|---|---|---|
|P, SP slice|0 (P_L0_16x16)|0|0|0|||||
|P, SP slice|1 (P_L0_L0_16x8)|0|1|1|||||
|P, SP slice|2 (P_L0_L0_8x16)|0|1|0|||||
|P, SP slice|3 (P_8x8)|0|0|1|||||
|P, SP slice|4 (P_8x8ref0)|na|na|na|na|na|na|na|
|P, SP slice|5 to 30 (Intra, prefix only)|1|||||||
|B slice|0 (B_Direct_16x16)|0|||||||
|B slice|1 (B_L0_16x16)|1|0|0|||||
|B slice|2 (B_L1_16x16)|1|0|1|||||
|B slice|3 (B_Bi_16x16)|1|1|0|0|0|0||
|B slice|4 (B_L0_L0_16x8)|1|1|0|0|0|1||
|B slice|5 (B_L0_L0_8x16)|1|1|0|0|1|0||
|B slice|6 (B_L1_L1_16x8)|1|1|0|0|1|1||
|B slice|7 (B_L1_L1_8x16)|1|1|0|1|0|0||
|B slice|8 (B_L0_L1_16x8)|1|1|0|1|0|1||
|B slice|9 (B_L0_L1_8x16)|1|1|0|1|1|0||
|B slice|10 (B_L1_L0_16x8)|1|1|0|1|1|1||
|B slice|11 (B_L1_L0_8x16)|1|1|1|1|1|0||
|B slice|12 (B_L0_Bi_16x8)|1|1|1|0|0|0|0|
|B slice|13 (B_L0_Bi_8x16)|1|1|1|0|0|0|1|
|B slice|14 (B_L1_Bi_16x8)|1|1|1|0|0|1|0|
|B slice|15 (B_L1_Bi_8x16)|1|1|1|0|0|1|1|
|B slice|16 (B_Bi_L0_16x8)|1|1|1|0|1|0|0|
|B slice|17 (B_Bi_L0_8x16)|1|1|1|0|1|0|1|
|B slice|18 (B_Bi_L1_16x8)|1|1|1|0|1|1|0|
|B slice|19 (B_Bi_L1_8x16)|1|1|1|0|1|1|1|
|B slice|20 (B_Bi_Bi_16x8)|1|1|1|1|0|0|0|
|B slice|21 (B_Bi_Bi_8x16)|1|1|1|1|0|0|1|
|B slice|22 (B_8x8)|1|1|1|1|1|1||
|B slice|23 to 48 (Intra, prefix only)|1|1|1|1|0|1||
|binIdx|binIdx|0|1|2|3|4|5|6|



For P, SP, and B slices the specification of the binarization for sub_mb_type[ ] is given in Table 9-38.





**Table 9-38 – Binarization for sub-macroblock types in P, SP, and B slices**







|Slice type|Value (name) of sub_mb_type[ ]|Bin string|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
|P, SP slice|0 (P_L0_8x8)|1||||||
|P, SP slice|1 (P_L0_8x4)|0|0|||||
|P, SP slice|2 (P_L0_4x8)|0|1|1||||
|P, SP slice|3 (P_L0_4x4)|0|1|0||||
|B slice|0 (B_Direct_8x8)|0||||||
|B slice|1 (B_L0_8x8)|1|0|0||||
|B slice|2 (B_L1_8x8)|1|0|1||||
|B slice|3 (B_Bi_8x8)|1|1|0|0|0||
|B slice|4 (B_L0_8x4)|1|1|0|0|1||
|B slice|5 (B_L0_4x8)|1|1|0|1|0||
|B slice|6 (B_L1_8x4)|1|1|0|1|1||
|B slice|7 (B_L1_4x8)|1|1|1|0|0|0|
|B slice|8 (B_Bi_8x4)|1|1|1|0|0|1|
|B slice|9 (B_Bi_4x8)|1|1|1|0|1|0|
|B slice|10 (B_L0_4x4)|1|1|1|0|1|1|
|B slice|11 (B_L1_4x4)|1|1|1|1|0||
|B slice|12 (B_Bi_4x4)|1|1|1|1|1||
|binIdx|binIdx|0|1|2|3|4|5|


**9.3.2.6** **Binarization process for coded block pattern**


Input to this process is a request for a binarization for the syntax element coded_block_pattern.


Output of this process is the binarization of the syntax element.


The binarization of coded_block_pattern consists of a prefix part and (when present) a suffix part. The prefix part of the
binarization is given by the FL binarization of CodedBlockPatternLuma with cMax = 15. When ChromaArrayType is not
equal to 0 or 3, the suffix part is present and consists of the TU binarization of CodedBlockPatternChroma with cMax = 2.
The relationship between the value of the syntax element coded_block_pattern and the values of CodedBlockPatternLuma
and CodedBlockPatternChroma is given as specified in clause 7.4.5.


**9.3.2.7** **Binarization process for mb_qp_delta**


Input to this process is a request for a binarization for the syntax element mb_qp_delta.


Output of this process is the binarization of the syntax element.


The bin string of mb_qp_delta is derived by the U binarization of the mapped value of the syntax element mb_qp_delta,
where the assignment rule between the signed value of mb_qp_delta and its mapped value is given as specified in Table 9-3.


**9.3.3** **Decoding process flow**


Input to this process is a binarization of the requested syntax element, maxBinIdxCtx, bypassFlag and ctxIdxOffset as
specified in clause 9.3.2.


Output of this process is the value of the syntax element.


This process specifies how each bit of a bit string is parsed for each syntax element.





After parsing each bit, the resulting bit string is compared to all bin strings of the binarization of the syntax element and
the following applies:


- If the bit string is equal to one of the bin strings, the corresponding value of the syntax element is the output.


- Otherwise (the bit string is not equal to one of the bin strings), the next bit is parsed.


While parsing each bin, the variable binIdx is incremented by 1 starting with binIdx being set equal to 0 for the first bin.


When the binarization of the corresponding syntax element consists of a prefix and a suffix binarization part,, the variable
binIdx is set equal to 0 for the first bin of each part of the bin string (prefix part or suffix part). In this case, after parsing
the prefix bit string, the parsing process of the suffix bit string related to the binarizations specified in clauses 9.3.2.3 and
9.3.2.5 is invoked depending on the resulting prefix bit string as specified in clauses 9.3.2.3 and 9.3.2.5. Note that for the
binarization of the syntax element coded_block_pattern, the suffix bit string is present regardless of the prefix bit string of
length 4 as specified in clause 9.3.2.6.


Depending on the variable bypassFlag, the following applies:


- If bypassFlag is equal to 1, the bypass decoding process as specified in clause 9.3.3.2.3 is applied for parsing the value
of the bins from the bitstream.


- Otherwise (bypassFlag is equal to 0), the parsing of each bin is specified by the following two ordered steps:


1. Given binIdx, maxBinIdxCtx and ctxIdxOffset, ctxIdx is derived as specified in clause 9.3.3.1.


2. Given ctxIdx, the value of the bin from the bitstream as specified in clause 9.3.3.2 is decoded.


**9.3.3.1** **Derivation process for ctxIdx**


Inputs to this process are binIdx, maxBinIdxCtx and ctxIdxOffset.


Output of this process is ctxIdx.


Table 9-39 shows the assignment of ctxIdx increments (ctxIdxInc) to binIdx for all ctxIdxOffset values except those related
to the syntax elements coded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1.


The ctxIdx to be used with a specific binIdx is specified by first determining the ctxIdxOffset associated with the given
bin string or part thereof. The ctxIdx is determined as follows:


- If the ctxIdxOffset is listed in Table 9-39, the ctxIdx for a binIdx is the sum of ctxIdxOffset and ctxIdxInc, which is
found in Table 9-39. When more than one value is listed in Table 9-39 for a binIdx, the assignment process for
ctxIdxInc for that binIdx is further specified in the clauses given in parenthesis of the corresponding table entry.


- Otherwise (ctxIdxOffset is not listed in Table 9-39), the ctxIdx is specified to be the sum of the following terms:
ctxIdxOffset and ctxIdxBlockCatOffset(ctxBlockCat) as specified in Table 9-40 and ctxIdxInc(ctxBlockCat).
Clause 9.3.3.1.3 specifies which ctxBlockCat is used. Clause 9.3.3.1.1.9 specifies the assignment of
ctxIdxInc(ctxBlockCat) for coded_block_flag, and clause 9.3.3.1.3 specifies the assignment of
ctxIdxInc(ctxBlockCat) for significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1.


All bins with binIdx greater than maxBinIdxCtx are parsed using the value of ctxIdx being assigned to binIdx equal to
maxBinIdxCtx.


All entries in Table 9-39 labelled with "na" correspond to values of binIdx that do not occur for the corresponding
ctxIdxOffset.


ctxIdx = 276 is assigned to the binIdx of mb_type indicating the I_PCM mode. For parsing the value of the corresponding
bins from the bitstream, the arithmetic decoding process for decisions before termination as specified in clause 9.3.3.2.4 is
applied.





**Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax**

**elements coded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1**



























































|ctxIdxOffset|binIdx|Col3|Col4|Col5|Col6|Col7|Col8|
|---|---|---|---|---|---|---|---|
|**ctxIdxOffset**|**0 **|**1 **|**2 **|**3 **|**4 **|** 5**|**>= 6**|
|0|0,1,2<br>(clause9.3.3.1.1.3)|na|na|na|na|na|na|
|3|0,1,2<br>(clause9.3.3.1.1.3)|ctxIdx=276|3|4|5,6<br>(clause<br>9.3.3.1.2)|6,7<br>(clause<br>9.3.3.1.2)|7|
|11|0,1,2<br>(clause9.3.3.1.1.1)|na|na|na|na|na|na|
|14|0|1|2,3<br>(clause<br>9.3.3.1.2)|na|na|na|na|
|17|0|ctxIdx=276|1|2|2,3<br>(clause<br>9.3.3.1.2)|3|3|
|21|0|1|2|na|na|na|na|
|24|0,1,2<br>(clause9.3.3.1.1.1)|na|na|na|na|na|na|
|27|0,1,2<br>(clause9.3.3.1.1.3)|3|4,5<br>(clause<br>9.3.3.1.2)|5|5|5|5|
|32|0|ctxIdx=276|1|2|2,3<br>(clause<br>9.3.3.1.2)|3|3|
|36|0|1|2,3<br>(clause<br>9.3.3.1.2)|3|3|3|na|
|40|0,1,2<br>(clause9.3.3.1.1.7)|3|4|5|6|6|6|
|47|0,1,2<br>(clause9.3.3.1.1.7)|3|4|5|6|6|6|
|54|0,1,2,3<br>(clause9.3.3.1.1.6)|4|5|5|5|5|5|
|60|0,1<br>(clause9.3.3.1.1.5)|2|3|3|3|3|3|
|64|0,1,2<br>(clause9.3.3.1.1.8)|3|3|na|na|na|na|
|68|0|na|na|na|na|na|na|
|69|0|0|0|na|na|na|na|
|70|0,1,2<br>(clause9.3.3.1.1.2)|na|na|na|na|na|na|
|73|0,1,2,3<br>(clause9.3.3.1.1.4)|0,1,2,3<br>(clause<br>9.3.3.1.1.4)|0,1,2,3<br>(clause<br>9.3.3.1.1.4)|0,1,2,3<br>(clause<br>9.3.3.1.1.4)|na|na|na|
|77|0,1,2,3<br>(clause9.3.3.1.1.4)|4,5,6,7<br>(clause<br>9.3.3.1.1.4)|na|na|na|na|na|
|276|0|na|na|na|na|na|na|
|399|0,1,2<br>(clause9.3.3.1.1.10)|na|na<br>|na|na|na|na|





Table 9-40 shows the values of ctxIdxBlockCatOffset depending on ctxBlockCat for the syntax elements
coded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1. The specification of
ctxBlockCat is given in Table 9-42.


**Table 9-40 – Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag,**

**significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1**

|Syntax element|ctxBlockCat (as specified in Table 9-42)|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**Syntax element**|**0 **|**1 **|**2 **|**3 **|~~**4 **~~|**5 **|**6 **|**7 **|**8 **|**9 **|**10**|**11**|**12**|**13**|
|coded_block_flag|0|4|8|12|16|0|0|4|8|4|0|4|8|8|
|significant_coeff_flag|0|15|29|44|47|0|0|15|29|0|0|15|29|0|
|last_significant_coeff_flag|0|15|29|44|47|0|0|15|29|0|0|15|29|0|
|coeff_abs_level_minus1|0|10|20|30|39|0|0|10|20|0|0|10|20|0|



**9.3.3.1.1** **Assignment process of ctxIdxInc using neighbouring syntax elements**


Clause 9.3.3.1.1.1 specifies the derivation process of ctxIdxInc for the syntax element mb_skip_flag.


Clause 9.3.3.1.1.2 specifies the derivation process of ctxIdxInc for the syntax element mb_field_decoding_flag.


Clause 9.3.3.1.1.3 specifies the derivation process of ctxIdxInc for the syntax element mb_type.


Clause 9.3.3.1.1.4 specifies the derivation process of ctxIdxInc for the syntax element coded_block_pattern.


Clause 9.3.3.1.1.5 specifies the derivation process of ctxIdxInc for the syntax element mb_qp_delta.


Clause 9.3.3.1.1.6 specifies the derivation process of ctxIdxInc for the syntax elements ref_idx_l0 and ref_idx_l1.


Clause 9.3.3.1.1.7 specifies the derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1.


Clause 9.3.3.1.1.8 specifies the derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode.


Clause 9.3.3.1.1.9 specifies the derivation process of ctxIdxInc for the syntax element coded_block_flag.


Clause 9.3.3.1.1.10 specifies the derivation process of ctxIdxInc for the syntax element transform_size_8x8_flag.


**9.3.3.1.1.1** **Derivation process of ctxIdxInc for the syntax element mb_skip_flag**


Output of this process is ctxIdxInc.


When MbaffFrameFlag is equal to 1 and mb_field_decoding_flag has not been decoded (yet) for the current macroblock
pair with top macroblock address 2 * ( CurrMbAddr / 2 ), the inference rule for the syntax element
mb_field_decoding_flag as specified in clause 7.4.4 is applied.


The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to
mbAddrA and mbAddrB.


Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If mbAddrN is not available or mb_skip_flag for the macroblock mbAddrN is equal to 1, condTermFlagN is set equal
to 0.


- Otherwise (mbAddrN is available and mb_skip_flag for the macroblock mbAddrN is equal to 0), condTermFlagN is
set equal to 1.


The variable ctxIdxInc is derived by:


ctxIdxInc = condTermFlagA + condTermFlagB (9-7)


**9.3.3.1.1.2** **Derivation process of ctxIdxInc for the syntax element mb_field_decoding_flag**


Output of this process is ctxIdxInc.





The derivation process for neighbouring macroblock addresses and their availability in MBAFF frames as specified in
clause 6.4.10 is invoked and the output is assigned to mbAddrA and mbAddrB.


When both macroblocks mbAddrN and mbAddrN + 1 have mb_type equal to P_Skip or B_Skip, the inference rule for the
syntax element mb_field_decoding_flag as specified in clause 7.4.4 is applied for the macroblock mbAddrN.


Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, condTermFlagN is set equal to 0:


   - mbAddrN is not available,


   - the macroblock mbAddrN is a frame macroblock.


- Otherwise, condTermFlagN is set equal to 1.


The variable ctxIdxInc is derived by


ctxIdxInc = condTermFlagA + condTermFlagB (9-8)


**9.3.3.1.1.3** **Derivation process of ctxIdxInc for the syntax element mb_type**


Input to this process is ctxIdxOffset.


Output of this process is ctxIdxInc.


The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to
mbAddrA and mbAddrB.


Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, condTermFlagN is set equal to 0:


   - mbAddrN is not available,


   - ctxIdxOffset is equal to 0 and mb_type for the macroblock mbAddrN is equal to SI,


   - ctxIdxOffset is equal to 3 and mb_type for the macroblock mbAddrN is equal to I_NxN,


   - ctxIdxOffset is equal to 27 and mb_type for the macroblock mbAddrN is equal to B_Skip or B_Direct_16x16.


- Otherwise, condTermFlagN is set equal to 1.


The variable ctxIdxInc is derived as


ctxIdxInc = condTermFlagA + condTermFlagB (9-9)


**9.3.3.1.1.4** **Derivation process of ctxIdxInc for the syntax element coded_block_pattern**


Inputs to this process are ctxIdxOffset and binIdx.


Output of this process is ctxIdxInc.


Depending on the value of the variable ctxIdxOffset, the following ordered steps are specified:


- If ctxIdxOffset is equal to 73, the following applies:


1. The derivation process for neighbouring 8x8 luma blocks specified in clause 6.4.11.2 is invoked with

luma8x8BlkIdx = binIdx as input and the output is assigned to mbAddrA, mbAddrB, luma8x8BlkIdxA, and
luma8x8BlkIdxB.


2. Let the variable condTermFlagN (with N being either A or B) be derived as follows:


      - If any of the following conditions are true, condTermFlagN is set equal to 0:


        - mbAddrN is not available,


        - mb_type for the macroblock mbAddrN is equal to I_PCM,


        - the macroblock mbAddrN is not the current macroblock CurrMbAddr and the macroblock mbAddrN

does not have mb_type equal to P_Skip or B_Skip, and
( ( CodedBlockPatternLuma >> luma8x8BlkIdxN ) & 1 ) is not equal to 0 for the value of
CodedBlockPatternLuma for the macroblock mbAddrN,





        - the macroblock mbAddrN is the current macroblock CurrMbAddr and the prior decoded bin value bk

of coded_block_pattern with k = luma8x8BlkIdxN is not equal to 0.


      - Otherwise, condTermFlagN is set equal to 1.


3. The variable ctxIdxInc is derived as


ctxIdxInc = condTermFlagA + 2 * condTermFlagB (9-10)


- Otherwise (ctxIdxOffset is equal to 77), the following ordered steps are specified:


1. The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is

assigned to mbAddrA and mbAddrB.


2. Let the variable condTermFlagN (with N being either A or B) be derived as follows:


      - If mbAddrN is available and mb_type for the macroblock mbAddrN is equal to I_PCM, condTermFlagN is
set equal to 1.


      - Otherwise, if any of the following conditions are true, condTermFlagN is set equal to 0:


        - mbAddrN is not available or the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip,


        - binIdx is equal to 0 and CodedBlockPatternChroma for the macroblock mbAddrN is equal to 0,


        - binIdx is equal to 1 and CodedBlockPatternChroma for the macroblock mbAddrN is not equal to 2.


      - Otherwise, condTermFlagN is set equal to 1.


3. The variable ctxIdxInc is derived as


ctxIdxInc = condTermFlagA + 2 * condTermFlagB + ( ( binIdx = = 1 ) ? 4 : 0 ) (9-11)


NOTE – When a macroblock is coded in Intra_16x16 macroblock prediction mode, the values of CodedBlockPatternLuma and
CodedBlockPatternChroma for the macroblock are derived from mb_type as specified in Table 7-11.


**9.3.3.1.1.5** **Derivation process of ctxIdxInc for the syntax element mb_qp_delta**


Output of this process is ctxIdxInc.


Let prevMbAddr be the macroblock address of the macroblock that precedes the current macroblock in decoding order.
When the current macroblock is the first macroblock of a slice, prevMbAddr is marked as not available.


Let the variable ctxIdxInc be derived as follows:


- If any of the following conditions are true, ctxIdxInc is set equal to 0:


   - prevMbAddr is not available or the macroblock prevMbAddr has mb_type equal to P_Skip or B_Skip,


   - mb_type of the macroblock prevMbAddr is equal to I_PCM,


   - The macroblock prevMbAddr is not coded in Intra_16x16 macroblock prediction mode and both
CodedBlockPatternLuma and CodedBlockPatternChroma for the macroblock prevMbAddr are equal to 0,


   - mb_qp_delta for the macroblock prevMbAddr is equal to 0.


- Otherwise, ctxIdxInc is set equal to 1.


**9.3.3.1.1.6** **Derivation process of ctxIdxInc for the syntax elements ref_idx_l0 and ref_idx_l1**


Input to this process is mbPartIdx.


Output of this process is ctxIdxInc.


The interpretation of ref_idx_lX and Pred_LX within this clause is specified as follows:


- If this process is invoked for the derivation of ref_idx_l0, ref_idx_lX is interpreted as ref_idx_l0 and Pred_LX is
interpreted as Pred_L0.


- Otherwise (this process is invoked for the derivation of ref_idx_l1), ref_idx_lX is interpreted as ref_idx_l1 and
Pred_LX is interpreted as Pred_L1.


The derivation process for neighbouring partitions specified in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType
set equal to sub_mb_type[ mbPartIdx ], and subMbPartIdx = 0 as input and the output is assigned to
mbAddrA\mbPartIdxA and mbAddrB\mbPartIdxB.





With ref_idx_lX[ mbPartIdxN ] (with N being either A or B) specifying the syntax element for the macroblock mbAddrN,
let the variable refIdxZeroFlagN be derived as follows:


- If MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the macroblock mbAddrN is a
field macroblock,


refIdxZeroFlagN = ( ( ref_idx_lX[ mbPartIdxN ] > 1 ) ? 0 : 1 ) (9-12)


- Otherwise,


refIdxZeroFlagN = ( ( ref_idx_lX[ mbPartIdxN ] > 0 ) ? 0 : 1 ) (9-13)


Let the variable predModeEqualFlagN be specified as follows:


- If mb_type for the macroblock mbAddrN is equal to B_Direct_16x16 or B_Skip, predModeEqualFlagN is set equal
to 0.


- Otherwise, if the macroblock mbAddrN has mb_type equal to P_8x8 or B_8x8, the following applies:


   - If SubMbPredMode( sub_mb_type[ mbPartIdxN ] ) is not equal to Pred_LX and not equal to BiPred,
predModeEqualFlagN is set equal to 0, where sub_mb_type specifies the syntax element list for the macroblock
mbAddrN.


   - Otherwise, predModeEqualFlagN is set equal to 1.


- Otherwise, the following applies:


   - If MbPartPredMode( mb_type, mbPartIdxN ) is not equal to Pred_LX and not equal to BiPred,
predModeEqualFlagN is set equal to 0, where mb_type specifies the syntax element for the macroblock
mbAddrN.


   - Otherwise, predModeEqualFlagN is set equal to 1.


Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, condTermFlagN is set equal to 0:


   - mbAddrN is not available,


   - the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip,


   - the macroblock mbAddrN is coded in an Intra macroblock prediction mode,


   - predModeEqualFlagN is equal to 0,


   - refIdxZeroFlagN is equal to 1.


- Otherwise, condTermFlagN is set equal to 1.


The variable ctxIdxInc is derived as


ctxIdxInc = condTermFlagA + 2 * condTermFlagB (9-14)


**9.3.3.1.1.7** **Derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1**


Inputs to this process are mbPartIdx, subMbPartIdx, and ctxIdxOffset.


Output of this process is ctxIdxInc.


The interpretation of mvd_lX and Pred_LX within this clause is specified as follows:


- If this process is invoked for the derivation of mvd_l0, mvd_lX is interpreted as mvd_l0 and Pred_LX is interpreted
as Pred_L0.


- Otherwise (this process is invoked for the derivation of mvd_l1), mvd_lX is interpreted as mvd_l1 and Pred_LX is
interpreted as Pred_L1.


The derivation process for neighbouring partitions specified in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType
set equal to sub_mb_type[ mbPartIdx ], and subMbPartIdx as input and the output is assigned to
mbAddrA\mbPartIdxA\subMbPartIdxA and mbAddrB\mbPartIdxB\subMbPartIdxB.


Let the variable compIdx be derived as follows:





- If ctxIdxOffset is equal to 40, compIdx is set equal to 0.


- Otherwise (ctxIdxOffset is equal to 47), compIdx is set equal to 1.


Let the variable predModeEqualFlagN be specified as follows:


- If mb_type for the macroblock mbAddrN is equal to B_Direct_16x16 or B_Skip, predModeEqualFlagN is set equal
to 0.


- Otherwise, if the macroblock mbAddrN has mb_type equal to P_8x8 or B_8x8, the following applies:


   - If SubMbPredMode( sub_mb_type[ mbPartIdxN ] ) is not equal to Pred_LX and not equal to BiPred,
predModeEqualFlagN is set equal to 0, where sub_mb_type specifies the syntax element list for the macroblock
mbAddrN.


   - Otherwise, predModeEqualFlagN is set equal to 1.


- Otherwise, the following applies:


   - If MbPartPredMode( mb_type, mbPartIdxN ) is not equal to Pred_LX and not equal to BiPred,
predModeEqualFlagN is set equal to 0, where mb_type specifies the syntax element for the macroblock
mbAddrN.


   - Otherwise, predModeEqualFlagN is set equal to 1.


Let the variable absMvdCompN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, absMvdCompN is set equal to 0:


   - mbAddrN is not available,


   - the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip,


   - the macroblock mbAddrN is coded in an Intra macroblock prediction mode,


   - predModeEqualFlagN is equal to 0.


- Otherwise, the following applies:


   - If compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the
macroblock mbAddrN is a field macroblock,


absMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] ) * 2 (9-15)


   - Otherwise, if compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a field macroblock,
and the macroblock mbAddrN is a frame macroblock,


absMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] ) / 2 (9-16)


   - Otherwise,


absMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] ) (9-17)


The variable ctxIdxInc is derived as follows:


- If absMvdCompA is greater than 32 or absMvdCompA is greater than 32, ctxIdxInc is set equal to 2.


- Otherwise, if absMvdCompA + absMvdCompB is greater than 32, ctxIdxInc is set equal to 2.


- Otherwise, if absMvdCompA + absMvdCompB is greater than 2, ctxIdxInc is set equal to 1.


- Otherwise (absMvdCompA + absMvdCompB is less than or equal to 2), ctxIdxInc is set equal to 0.
NOTE – Although the above form of expression for the derivation of ctxIdxInc could have been somewhat simplified, the form
shown above was selected to assist the reader in avoiding a potential dynamic range problem in the derivation process.


**9.3.3.1.1.8** **Derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode**


Output of this process is ctxIdxInc.


The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to
mbAddrA and mbAddrB.


Let the variable condTermFlagN (with N being replaced by either A or B) be derived as follows:





- If any of the following conditions are true, condTermFlagN is set equal to 0:


   - mbAddrN is not available,


   - The macroblock mbAddrN is coded in an Inter macroblock prediction mode,


   - mb_type for the macroblock mbAddrN is equal to I_PCM,


   - intra_chroma_pred_mode for the macroblock mbAddrN is equal to 0.


- Otherwise, condTermFlagN is set equal to 1.


The variable ctxIdxInc is derived by:


ctxIdxInc = condTermFlagA + condTermFlagB (9-18)


**9.3.3.1.1.9** **Derivation process of ctxIdxInc for the syntax element coded_block_flag**


Input to this process is ctxBlockCat and additional input is specified as follows:


- If ctxBlockCat is equal to 0, 6, or 10, no additional input.


- Otherwise, if ctxBlockCat is equal to 1 or 2, luma4x4BlkIdx.


- Otherwise, if ctxBlockCat is equal to 3, the chroma component index iCbCr.


- Otherwise, if ctxBlockCat is equal to 4, chroma4x4BlkIdx and the chroma component index iCbCr.


- Otherwise, if ctxBlockCat is equal to 5, luma8x8BlkIdx.


- Otherwise, if ctxBlockCat is equal to 7 or 8, cb4x4BlkIdx.


- Otherwise, if ctxBlockCat is equal to 9, cb8x8BlkIdx.


- Otherwise, if ctxBlockCat is equal to 11 or 12, cr4x4BlkIdx.


- Otherwise (ctxBlockCat is equal to 13), cr8x8BlkIdx.


Output of this process is ctxIdxInc( ctxBlockCat ).


Let the variable transBlockN (with N being either A or B) be derived as follows:


- If ctxBlockCat is equal to 0, 6, or 10, the following ordered steps are specified:


1. The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is

assigned to mbAddrN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available and the macroblock mbAddrN is coded in Intra_16x16 macroblock prediction
mode, the following applies:


         - If ctxBlockCat is equal to 0, the luma DC block of macroblock mbAddrN is assigned to transBlockN.


         - Otherwise, if ctxBlockCat is equal to 6, the Cb DC block of macroblock mbAddrN is assigned to
transBlockN.


         - Otherwise (ctxBlockCat is equal to 10), the Cr DC block of macroblock mbAddrN is assigned to
transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 1 or 2, the following ordered steps are specified:


1. The derivation process for neighbouring 4x4 luma blocks specified in clause 6.4.11.4 is invoked with

luma4x4BlkIdx as input and the output is assigned to mbAddrN, luma4x4BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, ( ( CodedBlockPatternLuma >> ( luma4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the
macroblock mbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4
luma block with index luma4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or
B_Skip, ( ( CodedBlockPatternLuma >> ( luma4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the





macroblock mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8
luma block with index ( luma4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 3, the following ordered steps are specified:


1. The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is

assigned to mbAddrN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, and CodedBlockPatternChroma is not equal to 0 for the macroblock mbAddrN, the chroma DC
block of chroma component iCbCr of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 4, the following ordered steps are specified:


1. The derivation process for neighbouring 4x4 chroma blocks specified in clause 6.4.11.5 is invoked with

chroma4x4BlkIdx as input and the output is assigned to mbAddrN, chroma4x4BlkIdxN (with N being either A
or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, and CodedBlockPatternChroma is equal to 2 for the macroblock mbAddrN, the 4x4 chroma block
with chroma4x4BlkIdxN of the chroma component iCbCr of macroblock mbAddrN is assigned to
transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 5, the following ordered steps are specified:


1. The derivation process for neighbouring 8x8 luma blocks specified in clause 6.4.11.2 is invoked with

luma8x8BlkIdx as input and the output is assigned to mbAddrN, luma8x8BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, ( ( CodedBlockPatternLuma >>luma8x8BlkIdx) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 luma block
with index luma8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to7 or 8, the following ordered steps are specified:


1. The derivation process for neighbouring 4x4 Cb blocks specified in clause 6.4.11.5 is invoked with
cb4x4BlkIdx as input and the output is assigned to mbAddrN, cb4x4BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, (( CodedBlockPatternLuma >> ( cb4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4 Cb block
with index cb4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or
B_Skip, ( ( CodedBlockPatternLuma >> ( cb4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the
macroblock mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8
Cb block with index ( cb4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 9, the following ordered steps are specified:


1. The derivation process for neighbouring 8x8 Cb blocks specified in clause 6.4.11.3 is invoked with

cb8x8BlkIdx as input and the output is assigned to mbAddrN, cb8x8BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:





      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, ( ( CodedBlockPatternLuma >>cb8x8BlkIdx) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cb block
with index cb8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise, if ctxBlockCat is equal to 11 or 12, the following ordered steps are specified:


1. The derivation process for neighbouring 4x4 Cr blocks specified in clause 6.4.11.5 is invoked with cr4x4BlkIdx

as input and the output is assigned to mbAddrN, cr4x4BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM, ( ( CodedBlockPatternLuma >> ( cr4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4 Cr block with
index cr4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or
B_Skip, ( ( CodedBlockPatternLuma >> ( cr4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cr block with
index ( cr4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


- Otherwise (ctxBlockCat is equal to 13), the following ordered steps are specified:


1. The derivation process for neighbouring 8x8 Cr blocks specified in clause 6.4.11.3 is invoked with cr8x8BlkIdx

as input and the output is assigned to mbAddrN, cr8x8BlkIdxN (with N being either A or B).


2. The variable transBlockN is derived as follows:


      - If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or
I_PCM,, ( ( CodedBlockPatternLuma >>cr8x8BlkIdx) & 1 ) is not equal to 0 for the macroblock
mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cr block with
index cr8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN.


      - Otherwise, transBlockN is marked as not available.


Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, condTermFlagN is set equal to 0:


    - mbAddrN is not available and the current macroblock is coded in an Inter macroblock prediction mode,


    - mbAddrN is available and transBlockN is not available and mb_type for the macroblock mbAddrN is not equal
to I_PCM,


    - The current macroblock is coded in an Intra macroblock prediction mode, constrained_intra_pred_flag is equal
to 1, the macroblock mbAddrN is available and coded in an Inter macroblock prediction mode, and slice data
partitioning is in use (nal_unit_type is in the range of 2 through 4, inclusive).


- Otherwise, if any of the following conditions are true, condTermFlagN is set equal to 1:


    - mbAddrN is not available and the current macroblock is coded in an Intra macroblock prediction mode,


    - mb_type for the macroblock mbAddrN is equal to I_PCM.


- Otherwise, condTermFlagN is set equal to the value of the coded_block_flag of the transform block transBlockN that
was decoded for the macroblock mbAddrN.


The variable ctxIdxInc( ctxBlockCat ) is derived by


ctxIdxInc( ctxBlockCat ) = condTermFlagA + 2 * condTermFlagB (9-19)


**9.3.3.1.1.10** **Derivation process of ctxIdxInc for the syntax element transform_size_8x8_flag**


Output of this process is ctxIdxInc.


The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to
mbAddrA and mbAddrB.





Let the variable condTermFlagN (with N being either A or B) be derived as follows:


- If any of the following conditions are true, condTermFlagN is set equal to 0:


   - mbAddrN is not available,


   - transform_size_8x8_flag for the macroblock mbAddrN is equal to 0.


- Otherwise, condTermFlagN is set equal to 1.


The variable ctxIdxInc is derived by


ctxIdxInc = condTermFlagA + condTermFlagB (9-20)


**9.3.3.1.2** **Assignment process of ctxIdxInc using prior decoded bin values**


Inputs to this process are ctxIdxOffset and binIdx.


Output of this process is ctxIdxInc.


Table 9-41 contains the specification of ctxIdxInc for the given values of ctxIdxOffset and binIdx.


For each value of ctxIdxOffset and binIdx, ctxIdxInc is derived by using some of the values of prior decoded bin values
( b0, b1, b2,…, bk ), where the value of the index k is less than the value of binIdx.


**Table 9-41 – Specification of ctxIdxInc for specific values of ctxIdxOffset and binIdx**







|Value (name) of ctxIdxOffset|binIdx|ctxIdxInc|
|---|---|---|
|3|4|(b3 != 0) ? 5: 6|
|3|5|(b3 != 0) ? 6: 7|
|14|2|(b1 != 1) ? 2: 3|
|17|4|(b3 != 0) ? 2: 3|
|27|2|(b1 != 0) ? 4: 5|
|32|4|(b3 != 0) ? 2: 3|
|36|2|(b1 != 0) ? 2: 3|


**9.3.3.1.3** **Assignment process of ctxIdxInc for syntax elements significant_coeff_flag, last_significant_coeff_flag,**

**and coeff_abs_level_minus1**


Inputs to this process are ctxIdxOffset and binIdx.


Output of this process is ctxIdxInc.


The assignment process of ctxIdxInc for syntax elements significant_coeff_flag, last_significant_coeff_flag, and
coeff_abs_level_minus1 as well as for coded_block_flag depends on categories of different blocks denoted by the variable
ctxBlockCat. The specification of these block categories is given in Table 9-42.





**Table 9-42 – Specification of ctxBlockCat for the different blocks**

|Block description|maxNumCoeff|ctxBlockCat|
|---|---|---|
|block of luma DC transform coefficient levels<br>(i.e., list Intra16x16DCLevel as described in clause7.4.5.3)|16|0|
|block of luma AC transform coefficient levels<br>(i.e., list Intra16x16ACLevel[ i ] as described in clause7.4.5.3)|15|1|
|block of 16 luma transform coefficient levels<br>(i.e., list LumaLevel4x4[ i ] as described in clause7.4.5.3)|16|2|
|block of chroma DC transform coefficient levels when ChromaArrayType is equal to 1 or 2<br>(i.e., list ChromaDCLevel as described in clause7.4.5.3)|4 * NumC8x8|3|
|block of chroma AC transform coefficient levels when ChromaArrayType is equal to 1 or 2<br>(i.e., list ChromaACLevel as described in clause7.4.5.3)|15|4|
|block of 64 luma transform coefficient levels<br>(i.e., list LumaLevel8x8[ i ] as described in clause7.4.5.3)|64|5|
|block of Cb DC transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CbIntra16x16DCLevel as described in clause7.4.5.3)|16|6|
|block of Cb AC transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CbIntra16x16ACLevel[ i ] as described in clause7.4.5.3)|15|7|
|block of 16 Cb transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CbLevel4x4[ i ] as described in clause7.4.5.3)|16|8|
|block of 64 Cb transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CbLevel8x8[ i ] as described in clause7.4.5.3)|64|9|
|block of Cr DC transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CrIntra16x16DCLevel as described in clause7.4.5.3)|16|10|
|block of Cr AC transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CrIntra16x16ACLevel[ i ] as described in clause7.4.5.3)|15|11|
|block of 16 Cr transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CrLevel4x4[ i ] as described in clause7.4.5.3)|16|12|
|block of 64 Cr transform coefficient levels when ChromaArrayType is equal to 3<br>(i.e., list CrLevel8x8[ i ] as described in clause7.4.5.3)|64|13|



Let the variable levelListIdx be set equal to the index of the list of transform coefficient levels as specified in clause 7.4.5.3.


For the syntax elements significant_coeff_flag and last_significant_coeff_flag in blocks with ctxBlockCat not equal to 3,
5, 9, and 13, the variable ctxIdxInc is derived by


ctxIdxInc = levelListIdx (9-21)


where levelListIdx ranges from 0 to maxNumCoeff - 2, inclusive.


For the syntax elements significant_coeff_flag and last_significant_coeff_flag in blocks with ctxBlockCat = = 3, the
variable ctxIdxInc is derived by


ctxIdxInc = Min( levelListIdx / NumC8x8, 2 ) (9-22)


where levelListIdx ranges from 0 to 4 * NumC8x8 - 2, inclusive.


For the syntax elements significant_coeff_flag and last_significant_coeff_flag in 8x8 luma, Cb, or Cr blocks with
ctxBlockCat = = 5, 9, or 13, Table 9-43 contains the specification of ctxIdxInc for the given values of levelListIdx, where
levelListIdx ranges from 0 to 62, inclusive.





**Table 9-43 – Mapping of scanning position to ctxIdxInc for ctxBlockCat = = 5, 9, or 13**

|levelListIdx|ctxIdxInc for significant_coeff_flag (frame coded macroblocks)|ctxIdxInc for significant_coeff_flag (field coded macroblocks)|ctxIdxInc for last_significant_coeff_flag|levelListIdx|ctxIdxInc for significant_coeff_flag (frame coded macroblocks)|ctxIdxInc for significant_coeff_flag (field coded macroblocks)|ctxIdxInc for last_significant_coeff_flag|
|---|---|---|---|---|---|---|---|
|**0**|0|0|0|**32**|7|9|3|
|**1**|1|1|1|**33**|6|9|3|
|**2**|2|1|1|**34**|11|10|3|
|**3**|3|2|1|**35**|12|10|3|
|**4**|4|2|1|**36**|13|8|3|
|**5**|5|3|1|**37**|11|11|3|
|**6**|5|3|1|**38**|6|12|3|
|**7**|4|4|1|**39**|7|11|3|
|**8**|4|5|1|**40**|8|9|4|
|**9**|3|6|1|**41**|9|9|4|
|**10**|3|7|1|**42**|14|10|4|
|**11**|4|7|1|**43**|10|10|4|
|**12**|4|7|1|**44**|9|8|4|
|**13**|4|8|1|**45**|8|13|4|
|**14**|5|4|1|**46**|6|13|4|
|**15**|5|5|1|**47**|11|9|4|
|**16**|4|6|2|**48**|12|9|5|
|**17**|4|9|2|**49**|13|10|5|
|**18**|4|10|2|**50**|11|10|5|
|**19**|4|10|2|**51**|6|8|5|
|**20**|3|8|2|**52**|9|13|6|
|**21**|3|11|2|**53**|14|13|6|
|**22**|6|12|2|**54**|10|9|6|
|**23**|7|11|2|**55**|9|9|6|
|**24**|7|9|2|**56**|11|10|7|
|**25**|7|9|2|**57**|12|10|7|
|**26**|8|10|2|**58**|13|14|7|
|**27**|9|10|2|**59**|11|14|7|






**Table 9-43 – Mapping of scanning position to ctxIdxInc for ctxBlockCat = = 5, 9, or 13**

|levelListIdx|ctxIdxInc for significant_coeff_flag (frame coded macroblocks)|ctxIdxInc for significant_coeff_flag (field coded macroblocks)|ctxIdxInc for last_significant_coeff_flag|levelListIdx|ctxIdxInc for significant_coeff_flag (frame coded macroblocks)|ctxIdxInc for significant_coeff_flag (field coded macroblocks)|ctxIdxInc for last_significant_coeff_flag|
|---|---|---|---|---|---|---|---|
|**28**|10|8|2|**60**|14|14|8|
|**29**|9|11|2|**61**|10|14|8|
|**30**|8|12|2|**62**|12|14|8|
|**31**|7|11|2|||||



Let numDecodAbsLevelEq1 denote the accumulated number of decoded transform coefficient levels with absolute value
equal to 1, and let numDecodAbsLevelGt1 denote the accumulated number of decoded transform coefficient levels with
absolute value greater than 1. Both numbers are related to the same transform coefficient block, where the current decoding
process takes place. Then, for decoding of coeff_abs_level_minus1, ctxIdxInc for coeff_abs_level_minus1 is specified
depending on binIdx as follows:


- If binIdx is equal to 0, ctxIdxInc is derived by


ctxIdxInc = ( ( numDecodAbsLevelGt1 != 0 ) ? 0: Min( 4, 1 + numDecodAbsLevelEq1 ) ) (9-23)


- Otherwise (binIdx is greater than 0), ctxIdxInc is derived by


ctxIdxInc = 5 + Min( 4 − ( ( ctxBlockCat = = 3 ) ? 1 : 0 ), numDecodAbsLevelGt1 ) (9-24)


**9.3.3.2** **Arithmetic decoding process**


Inputs to this process are the bypassFlag, ctxIdx as derived in clause 9.3.3.1, and the state variables codIRange and
codIOffset of the arithmetic decoding engine.


Output of this process is the value of the bin.


Figure 9-2 illustrates the whole arithmetic decoding process for a single bin. For decoding the value of a bin, the context
index ctxIdx is passed to the arithmetic decoding process DecodeBin(ctxIdx), which is specified as follows:


- If bypassFlag is equal to 1, DecodeBypass( ) as specified in clause 9.3.3.2.3 is invoked.


- Otherwise, if bypassFlag is equal to 0 and ctxIdx is equal to 276, DecodeTerminate( ) as specified in clause 9.3.3.2.4
is invoked.


- Otherwise (bypassFlag is equal to 0 and ctxIdx is not equal to 276), DecodeDecision( ) as specified in clause 9.3.3.2.1
is applied.





**Figure 9-2 – Overview of the arithmetic decoding process for a single bin (informative)**


NOTE – Arithmetic coding is based on the principle of recursive interval subdivision. Given a probability estimation p( 0 ) and
p( 1 ) = 1   - p( 0 ) of a binary decision ( 0, 1 ), an initially given code sub-interval with the range codIRange will be subdivided into
two sub-intervals having range p( 0 ) * codIRange and codIRange   - p( 0 ) * codIRange, respectively. Depending on the decision,
which has been observed, the corresponding sub-interval will be chosen as the new code interval, and a binary code string pointing
into that interval will represent the sequence of observed binary decisions. It is useful to distinguish between the most probable
symbol (MPS) and the least probable symbol (LPS), so that binary decisions have to be identified as either MPS or LPS, rather than
0 or 1. Given this terminology, each context is specified by the probability pLPS of the LPS and the value of MPS (valMPS), which
is either 0 or 1.
The arithmetic core engine in this Recommendation | International Standard has three distinct properties:

   - The probability estimation is performed by means of a finite-state machine with a table-based transition process between 64
different representative probability states { pLPS(pStateIdx) | 0 <= pStateIdx < 64 } for the LPS probability pLPS. The
numbering of the states is arranged in such a way that the probability state with index pStateIdx = 0 corresponds to an LPS
probability value of 0.5, with decreasing LPS probability towards higher state indices.

   - The range codIRange representing the state of the coding engine is quantized to a small set {Q1,…,Q4} of pre-set quantization
values prior to the calculation of the new interval range. Storing a table containing all 64x4 pre-computed product values of
Qi * pLPS(pStateIdx) allows a multiplication-free approximation of the product codIRange * pLPS(pStateIdx).

   - For syntax elements or parts thereof for which an approximately uniform probability distribution is assumed to be given a
separate simplified encoding and decoding bypass process is used.


**9.3.3.2.1** **Arithmetic decoding process for a binary decision**


Inputs to this process are ctxIdx, codIRange, and codIOffset.


Outputs of this process are the decoded value binVal, and the updated variables codIRange and codIOffset.


Figure 9-3 shows the flowchart for decoding a single decision (DecodeDecision):


1. The value of the variable codIRangeLPS is derived as follows:


    - Given the current value of codIRange, the variable qCodIRangeIdx is derived by


qCodIRangeIdx =( codIRange >> 6 ) & 3 (9-25)


    - Given qCodIRangeIdx and pStateIdx associated with ctxIdx, the value of the variable rangeTabLPS as
specified in Table 9-44 is assigned to codIRangeLPS:


codIRangeLPS = rangeTabLPS[ pStateIdx ][ qCodIRangeIdx ] (9-26)





2. The variable codIRange is set equal to codIRange  - codIRangeLPS and the following applies:


    - If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1 − valMPS, codIOffset
is decremented by codIRange, and codIRange is set equal to codIRangeLPS.


    - Otherwise, the variable binVal is set equal to valMPS.


Given the value of binVal, the state transition is performed as specified in clause 9.3.3.2.1.1. Depending on the current
value of codIRange, renormalization is performed as specified in clause 9.3.3.2.2.


**9.3.3.2.1.1** **State transition process**


Inputs to this process are the current pStateIdx, the decoded value binVal and valMPS values of the context variable
associated with ctxIdx.


Outputs of this process are the updated pStateIdx and valMPS of the context variable associated with ctxIdx.


Depending on the decoded value binVal, the update of the two variables pStateIdx and valMPS associated with ctxIdx is
derived as specified by the following pseudo-code:


if( binVal = = valMPS )
pStateIdx = transIdxMPS( pStateIdx )
else { (9-27)
if( pStateIdx = = 0 )
valMPS = 1       - valMPS
pStateIdx = transIdxLPS( pStateIdx )
}


Table 9-45 specifies the transition rules transIdxMPS( ) and transIdxLPS( ) after decoding the value of valMPS and
1 - valMPS, respectively.





**Figure 9-** 3 **– Flowchart for decoding a decision**





**Table 9-44 – Specification of rangeTabLPS depending on pStateIdx and qCodIRangeIdx**











|pStateIdx|qCodIRangeIdx|Col3|Col4|Col5|pStateIdx|qCodIRangeIdx|Col8|Col9|Col10|
|---|---|---|---|---|---|---|---|---|---|
|**pStateIdx**|**0 **|**1 **|**2 **|**3 **|**3 **|**0 **|**1 **|**2 **|**3 **|
|**0 **|128|176|208|240|**32**|27|33|39|45|
|**1 **|128|167|197|227|**33**|26|31|37|43|
|**2 **|128|158|187|216|**34**|24|30|35|41|
|**3 **|123|150|178|205|**35**|23|28|33|39|
|**4 **|116|142|169|195|**36**|22|27|32|37|
|**5 **|111|135|160|185|**37**|21|26|30|35|
|**6 **|105|128|152|175|**38**|20|24|29|33|
|**7 **|100|122|144|166|**39**|19|23|27|31|
|**8 **|95|116|137|158|**40**|18|22|26|30|
|**9 **|90|110|130|150|**41**|17|21|25|28|
|**10**|85|104|123|142|**42**|16|20|23|27|
|**11**|81|99|117|135|**43**|15|19|22|25|
|**12**|77|94|111|128|**44**|14|18|21|24|
|**13**|73|89|105|122|**45**|14|17|20|23|
|**14**|69|85|100|116|**46**|13|16|19|22|
|**15**|66|80|95|110|**47**|12|15|18|21|
|**16**|62|76|90|104|**48**|12|14|17|20|
|**17**|59|72|86|99|**49**|11|14|16|19|
|**18**|56|69|81|94|**50**|11|13|15|18|
|**19**|53|65|77|89|**51**|10|12|15|17|
|**20**|51|62|73|85|**52**|10|12|14|16|
|**21**|48|59|69|80|**53**|9|11|13|15|
|**22**|46|56|66|76|**54**|9|11|12|14|
|**23**|43|53|63|72|**55**|8|10|12|14|
|**24**|41|50|59|69|**56**|8|9|11|13|
|**25**|39|48|56|65|**57**|7|9|11|12|
|**26**|37|45|54|62|**58**|7|9|10|12|
|**27**|35|43|51|59|**59**|7|8|10|11|
|**28**|33|41|48|56|**60**|6|8|9|11|
|**29**|32|39|46|53|**61**|6|7|9|10|
|**30**|30|37|43|50|**62**|6|7|8|9|
|**31**|29|35|41|48|**63**|2|2|2|2|





**Table 9-45 – State transition table**

|pStateIdx|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**transIdxLPS**|0|0|1|2|2|4|4|5|6|7|8|9|9|11|11|12|
|**transIdxMPS**|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
|**pStateIdx**|**16**|**17**|**18**|**19**|**20**|**21**|**22**|**23**|**24**|**25**|**26**|**27**|**28**|**29**|**30**|**31**|
|**transIdxLPS**|13|13|15|15|16|16|18|18|19|19|21|21|22|22|23|24|
|**transIdxMPS**|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|
|**pStateIdx**|**32**|**33**|**34**|**35**|**36**|**37**|**38**|**39**|**40**|**41**|**42**|**43**|**44**|**45**|**46**|**47**|
|**transIdxLPS**|24|25|26|26|27|27|28|29|29|30|30|30|31|32|32|33|
|**transIdxMPS**|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|
|**pStateIdx**|**48**|**49**|**50**|**51**|**52**|**53**|**54**|**55**|**56**|**57**|**58**|**59**|**60**|**61**|**62**|**63**|
|**transIdxLPS**|33|33|34|34|35|35|35|36|36|36|37|37|37|38|38|63|
|**transIdxMPS**|49|50|51|52|53|54|55|56|57|58|59|60|61|62|62|63|



**9.3.3.2.2** **Renormalization process in the arithmetic decoding engine**


Inputs to this process are bits from slice data and the variables codIRange and codIOffset.


Outputs of this process are the updated variables codIRange and codIOffset.


A flowchart of the renormalization is shown in Figure 9-4. The current value of codIRange is first compared to 256 and
further steps are specified as follows:


- If codIRange is greater than or equal to 256, no renormalization is needed and the RenormD process is finished;


- Otherwise (codIRange is less than 256), the renormalization loop is entered. Within this loop, the value of codIRange
is doubled, i.e., left-shifted by 1 and a single bit is shifted into codIOffset by using read_bits( 1 ).


The bitstream shall not contain data that result in a value of codIOffset being greater than or equal to codIRange upon
completion of this process.















**Figure 9-** 4 **– Flowchart of renormalization**





**9.3.3.2.3** **Bypass decoding process for binary decisions**


Inputs to this process are bits from slice data and the variables codIRange and codIOffset.


Outputs of this process are the updated variable codIOffset and the decoded value binVal.


The bypass decoding process is invoked when bypassFlag is equal to 1. Figure 9-5 shows a flowchart of the corresponding
process.


First, the value of codIOffset is doubled, i.e., left-shifted by 1 and a single bit is shifted into codIOffset by using
read_bits( 1 ). Then, the value of codIOffset is compared to the value of codIRange and further steps are specified as
follows:


- If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1 and codIOffset is decremented
by codIRange.


- Otherwise (codIOffset is less than codIRange), the variable binVal is set equal to 0 _._


The bitstream shall not contain data that result in a value of codIOffset being greater than or equal to codIRange upon
completion of this process.


**Figure 9-** 5 **– Flowchart of bypass decoding process**


**9.3.3.2.4** **Decoding process for binary decisions before termination**


Inputs to this process are bits from slice data and the variables codIRange and codIOffset.


Outputs of this process are the updated variables codIRange and codIOffset, and the decoded value binVal.


This special decoding routine applies to decoding of end_of_slice_flag and of the bin indicating the I_PCM mode
corresponding to ctxIdx equal to 276. Figure 9-6 shows the flowchart of the corresponding decoding process, which is
specified as follows.


First, the value of codIRange is decremented by 2. Then, the value of codIOffset is compared to the value of codIRange
and further steps are specified as follows:


- If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1, no renormalization is carried
out, and CABAC decoding is terminated. The last bit inserted in register codIOffset is equal to 1. When decoding
end_of_slice_flag, this last bit inserted in register codIOffset is interpreted as rbsp_stop_one_bit.


- Otherwise (codIOffset is less than codIRange), the variable binVal is set equal to 0 and renormalization is performed
as specified in clause 9.3.3.2.2.

NOTE – This procedure may also be implemented using DecodeDecision(ctxIdx) with ctxIdx = 276. In the case where
the decoded value is equal to 1, seven more bits would be read by DecodeDecision(ctxIdx) and a decoding process would
have to adjust its bitstream pointer accordingly to properly decode following syntax elements.





**Figure 9-** 6 **– Flowchart of decoding a decision before termination**


**9.3.4** **Arithmetic encoding process (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


Inputs to this process are decisions that are to be encoded and written.


Outputs of this process are bits that are written to the RBSP.


This informative clause describes an arithmetic encoding engine that matches the arithmetic decoding engine described in
clause 9.3.3.2. The encoding engine is essentially symmetric with the decoding engine, i.e., procedures are called in the
same order. The following procedures are described in this section: InitEncoder, EncodeDecision, EncodeBypass,
EncodeTerminate, which correspond to InitDecoder, DecodeDecision, DecodeBypass, and DecodeTerminate,
respectively. The state of the arithmetic encoding engine is represented by a value of the variable codILow pointing to the
lower end of a sub-interval and a value of the variable codIRange specifying the corresponding range of that sub-interval.


**9.3.4.1** **Initialization process for the arithmetic encoding engine (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


This process is invoked before encoding the first macroblock of a slice, and after encoding any pcm_alignment_zero_bit
and all pcm_sample_luma and pcm_sample_chroma data for a macroblock of type I_PCM.


Outputs of this process are the values codILow, codIRange, firstBitFlag, bitsOutstanding, and BinCountsInNALunits of
the arithmetic encoding engine.


In the initialization procedure of the encoder, codILow is set equal to 0, and codIRange is set equal to 510. Furthermore,
firstBitFlag is set equal to 1 and the counter bitsOutstanding is set equal to 0.


Depending on whether the current slice is the first slice of a coded picture, the following applies:


- If the current slice is the first slice of a coded picture, the counter BinCountsInNALunits is set equal to 0.


- Otherwise (the current slice is not the first slice of a coded picture), the counter BinCountsInNALunits is not modified.
The value of BinCountsInNALunits is the result of encoding all the slices of a coded picture that precede the current
slice in decoding order. After initializing for the first slice of a coded picture as specified in this clause,
BinCountsInNALunits is incremented as specified in clauses 9.3.4.2, 9.3.4.4, and 9.3.4.5.
NOTE – The minimum register precision required for storing the values of the variables codILow and codIRange after invocation
of any of the arithmetic encoding processes specified in clauses 9.3.4.2, 9.3.4.4, and 9.3.4.5 is 10 bits and 9 bits, respectively. The
encoding process for a binary decision (EncodeDecision) as specified in clause 9.3.4.2 and the encoding process for a binary decision
before termination (EncodeTerminate) as specified in clause 9.3.4.5 require a minimum register precision of 10 bits for the variable
codILow and a minimum register precision of 9 bits for the variable codIRange. The bypass encoding process for binary decisions





(EncodeBypass) as specified in clause 9.3.4.4 requires a minimum register precision of 11 bits for the variable codILow and a
minimum register precision of 9 bits for the variable codIRange. The precision required for the counters bitsOutstanding and
BinCountsInNALunits should be sufficiently large to prevent overflow of the related registers. When maxBinCountInSlice denotes
the maximum total number of binary decisions to encode in one slice and maxBinCountInPic denotes the maximum total number of
binary decisions to encode a picture, the minimum register precision required for the variables bitsOutstanding and
BinCountsInNALunits is given by Ceil( Log2( maxBinCountInSlice + 1 ) ) and Ceil( Log2( maxBinCountInPic + 1 ) ),
respectively.


**9.3.4.2** **Encoding process for a binary decision (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


Inputs to this process are the context index ctxIdx, the value of binVal to be encoded, and the variables codIRange, codILow
and BinCountsInNALunits.


Outputs of this process are the variables codIRange, codILow, and BinCountsInNALunits.


Figure 9-7 shows the flowchart for encoding a single decision. In a first step, the variable codIRangeLPS is derived as
follows.


Given the current value of codIRange, codIRange is mapped to the index qCodIRangeIdx of a quantized value of
codIRange by using Equation 9-25. The value of qCodIRangeIdx and the value of pStateIdx associated with ctxIdx are
used to determine the value of the variable rangeTabLPS as specified in Table 9-44, which is assigned to codIRangeLPS.
The value of codIRange − codIRangeLPS is assigned to codIRange.


In a second step, the value of binVal is compared to valMPS associated with ctxIdx. When binVal is different from valMPS,
codIRange is added to codILow and codIRange is set equal to the value codIRangeLPS. Given the encoded decision, the
state transition is performed as specified in clause 9.3.3.2.1.1. Depending on the current value of codIRange,
renormalization is performed as specified in clause 9.3.4.3. Finally, the variable BinCountsInNALunits is incremented
by 1.





**Figure 9-** 7 **– Flowchart for encoding a decision**


**9.3.4.3** **Renormalization process in the arithmetic encoding engine (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


Inputs to this process are the variables codIRange, codILow, firstBitFlag, and bitsOutstanding.


Outputs of this process are zero or more bits written to the RBSP and the updated variables codIRange, codILow,
firstBitFlag, and bitsOutstanding.





Renormalization is illustrated in Figure 9-8.































**Figure 9-** 8 **– Flowchart of renormalization in the encoder**


The PutBit( ) procedure described in Figure 9-9 provides carry over control. It uses the function WriteBits( B, N ) that
writes N bits with value B to the bitstream and advances the bitstream pointer by N bit positions. This function assumes
the existence of a bitstream pointer with an indication of the position of the next bit to be written to the bitstream by the
encoding process.





**Figure 9-** 9 **– Flowchart of PutBit(B)**


**9.3.4.4** **Bypass encoding process for binary decisions (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


Inputs to this process are the variables binVal, codILow, codIRange, bitsOutstanding, and BinCountsInNALunits.


Output of this process is a bit written to the RBSP and the updated variables codILow, bitsOutstanding, and
BinCountsInNALunits.


This encoding process applies to all binary decisions with bypassFlag equal to 1. Renormalization is included in the
specification of this process as given in Figure 9-10.





**Figure 9-** 10 **– Flowchart of encoding bypass**


**9.3.4.5** **Encoding process for a binary decision before termination (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


Inputs to this process are the variables binVal, codIRange, codILow, bitsOutstanding, and BinCountsInNALunits.


Outputs of this process are zero or more bits written to the RBSP and the updated variables codILow, codIRange,
bitsOutstanding, and BinCountsInNALunits.


This encoding routine shown in Figure 9-11 applies to encoding of the end_of_slice_flag and of the bin indicating the
I_PCM mb_type both associated with ctxIdx equal to 276.





**Figure 9-** 11 **– Flowchart of encoding a decision before termination**


When the value of binVal to encode is equal to 1, CABAC encoding is terminated and the flushing procedure shown in
Figure 9-12 is applied. In this flushing procedure, the last bit written by WriteBits( B, N ) is equal to 1. When encoding
end_of_slice_flag, this last bit is interpreted as the rbsp_stop_one_bit.















**Figure 9-** 12 **– Flowchart of flushing at termination**





**9.3.4.6** **Byte stuffing process (informative)**


This clause does not form an integral part of this Recommendation | International Standard.


This process is invoked after encoding the last macroblock of the last slice of a picture and after encapsulation.


Inputs to this process are the number of bytes NumBytesInVclNALunits of all VCL NAL units of a picture, the number of
macroblocks PicSizeInMbs in the picture, and the number of binary symbols BinCountsInNALunits resulting from
encoding the contents of all VCL NAL units of the picture.

NOTE – The value of BinCountsInNALunits is the result of encoding all slices of a coded picture. After initializing for the first slice
of a coded picture as specified in clause 9.3.4.1, BinCountsInNALunits is incremented as specified in clauses 9.3.4.2, 9.3.4.4, and
9.3.4.5.


Outputs of this process are zero or more bytes appended to the NAL unit.


Let the variable k be set equal to Ceil( ( Ceil( 3 * ( 32 * BinCountsInNALunits − RawMbBits * PicSizeInMbs ) ÷ 1024 ) −
NumBytesInVclNALunits ) ÷ 3 ). Depending on the variable k the following applies:


- If k is less than or equal to 0, no cabac_zero_word is appended to the NAL unit.


- Otherwise (k is greater than 0), the 3-byte sequence 0x000003 is appended k times to the NAL unit after encapsulation,
where the first two bytes 0x0000 represent a cabac_zero_word and the third byte 0x03 represents an
emulation_prevention_three_byte.
